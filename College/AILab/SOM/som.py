# -*- coding: utf-8 -*-
"""SOM.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gY8FH10JVdaXYXxlsK7Z1S3aEYimUUV5

# Self Organizing Map
"""



"""To train a SOM, we follow these steps:

1. Choose grid size
2. Set random weight W of shape (1, n_cols)
3. Choose an input vector from the data
4. Calculte Euclidian distance between Xi and Wj,i  - the minimum is the BMU
5. Update the weights: w(t+1) = w(t) + h(t) * lr(t) * (x - w(t))
6. Repeat: Repeat steps 3-5 for a specified number of iterations, adjusting the learning rate and neighborhood function over time as needed.


Where:
* **Wj,i**: represent the Weights of the node j (W1,1 W1,2, ... W1,n_cols)
* **BMU** (Best Matching Unit) is the node with the minimum euclidian to the input X.
* **h**: the neighboring value. The closer a node is to the BMU, the higher h will be.
* **lr**: is the learning rate

**Neighboring Function**
The neighboring fucntion calculates the dist
"""

import numpy as np
def neighborhood_function(winning_neuron, current_neuron, radius):
    # Euclidan distance between BMU and another neuron
    # D = sqrt(sum(Xi - Wi) ^ 2)
    distance = np.linalg.norm(winning_neuron - current_neuron)

    # we  update only neurons in the perimeter
    # the smaller the distance between BMU and the neuron, the higher the returned value will be
    # which means drastic updates.
    if distance <= radius:
        return np.exp(-distance**2 / (2*radius**2))
    else:
        return 0

"""## The SOM class"""

import random
import numpy as np
import matplotlib.pyplot as plt


class SOM:

    def __init__(self, input_size, map_size):
        """
        Initializes a Self Organizing Maps.

        Parameters
        ----------
        input_size: is the number of features in the input data
        map_size: tuple
            Size of the SOM map, which is the number of neurons or nodes in the grid.
        weights: np array
            Weights of the SOM neurons in a 2D numpy array of the same shape as `map_size`.
        """
        self.input_size = input_size
        self.map_size = map_size
        self.weights = np.random.rand(map_size[0], map_size[1], input_size)

    def train(self, data, n_iter, lr):
        """
        Train the SOM.

        Parameters
        ----------
        data: 2D np array
            Input data. An array of shape (n_samples, input_size).
        n_iter: number
            Number of iterations
        lr: float
            Learning rate
        """

        # Select random row from the data
        # Find the Best Matching Unit
        # Update neurons weights in the  BMU neighborhood
        for i in range(n_iter):
            v = data[random.randint(0, len(data) - 1)]
            bmu = self._find_bmu(v)
            self._update_weights(v, bmu, lr, i, n_iter)

    def _find_bmu(self, v):
        """
        Find the best matching unit (BMU) by computing the euclidan distance
        between the input vector `v` and the neurons weights.

        The BMU is the neuron which is the closest to the input vector `v`.

        Parameters
        ----------
        v: np array
            Input vector, which is a row from the dataset.

        Returns
        -------
        bmu: tuple
            (x,y) coordinates of the BMU in the map
        """

        # Euclidean distance between `v` and weights of each neuron
        distances = np.linalg.norm(self.weights - v, axis=2)
        bmu_index = np.argmin(distances)

        # convert the index i of the BMU in a (x,y) coordinates in the map
        bmu = np.unravel_index(bmu_index, self.map_size)

        return bmu

    def _update_weights(self, v, bmu, lr, iteration, n_iter):
        """
        Update the weights of all the neurons in the SOM.

        Parameters
        ----------
        v: np array
            input vector that was fed into the SOM.

        bmu: tuple
            Coordinates of the BMU in the SOM grid.

        lr: scalar
            Learning rate for the current iteration. A scalar value between 0 and 1
            that controls the amount by which the weights are updated.

        iter: integer
            Current iteration of the SOM training process.

        n_iter: integer
            Total number of iterations to train the the SOM.
        """
        n_rows = self.map_size[0]
        n_cols = self.map_size[1]

        # Determine radius and compute the Gaussian neighborhood
        radius = self.map_size[0] / 2 * np.exp(-iteration / n_iter)
        neighborhood = self._gaussian(bmu, radius)

        # decrase learning rate
        decay = np.exp(-iteration / n_iter)

        # Update the weights of the neurons in the neighborhood of the BMU
        for i in range(n_rows):
            for j in range(n_cols):
                # weights of the neuron at position (i,j)
                w = self.weights[i, j]

                # distance between current neuron position and BMU position
                distance = np.linalg.norm([i - bmu[0], j - bmu[1]])

                # if the current neuron is in the radius
                if distance <= radius:
                    influence = neighborhood[i, j] * decay
                    w += lr * influence * (v - w)

                self.weights[i, j] = w

    def _gaussian(self, bmu, radius):
        """
        Compute the Euclidian distance between the BMU and each neuron,
        then return a value inversely proportional to the distance,
        i.e the lower the distance (close neuron), the higher the returned value (influence).
        The distance are computed using the coordinates of the neurons on the map.
        """

        # distance between each neuron of the map and the BMU (in coordinates)
        x, y = np.indices(self.map_size)
        distance = np.linalg.norm([x - bmu[0], y - bmu[1]], axis=0)  # 2D array

        sigma = radius / 2

        # compute the Gaussian function on each neuron based on the distance
        # this will help us determine the weights
        return np.exp(-(distance ** 2) / (2 * sigma ** 2))

    def predict(self, data):
        """
        Find the BMU for each input vector then return the coordinates
        that represent the cluster of the input vetor.

        Parameters
        ----------
        data: 2D np array
            Input data. An array of shape (n_samples, input_size).
        """
        predictions = []

        for input_vector in data:
            bmu = self._find_bmu(input_vector)
            predictions.append(bmu)

        return predictions

    def quantization_error(self, data):
        error = 0.0
        for input_vector in data:
            bmu = self._find_bmu(input_vector)
            error += np.linalg.norm(input_vector - self.weights[bmu])
        return error / len(data)

    def visualize_som(self, data):
        # Get the weight vectors from the SOM object
        weights = self.weights

        # Predict the BMU for each input vector
        bmu_indices = self.predict(data)

        # Create a colormap with a unique color for each BMU
        colormap = {}
        for bmu_index in bmu_indices:
            if bmu_index not in colormap:
                colormap[bmu_index] = np.random.rand(3,)

        # Create a 2D grid of subplots for each neuron in the SOM
        fig, axs = plt.subplots(self.map_size[0], self.map_size[1], figsize=(10, 10))
        # Flatten the subplots array so we can loop through it
        axs = axs.ravel()

        # Loop through each neuron in the SOM and plot its weight vector as a point
        for i in range(self.map_size[0]):
            for j in range(self.map_size[1]):
                # Get the weight vector for this neuron
                w = weights[i, j]
                # Get the BMU index for this neuron
                bmu_index = np.unravel_index(np.argmin(np.linalg.norm(w - self.weights, axis=2)), self.map_size)
                # Get the color for this BMU index
                color = colormap[bmu_index]
                # Plot the weight vector as a point on the corresponding subplot
                axs[i * self.map_size[1] + j].scatter(w[0], w[1], color=color)
                axs[i * self.map_size[1] + j].set_xticks([])
                axs[i * self.map_size[1] + j].set_yticks([])

        # Add a title to the figure
        fig.suptitle('SOM Visualization')
        # Show the plot
        plt.show()

# !pip install minisom

# from minisom import MiniSom
# # import sklearn
# from sklearn.datasets import load_iris
# # from sklearn.preprocessing import MinMaxScaler

# import math
# import numpy as np

# import matplotlib.pyplot as plt

from minisom import MiniSom

from sklearn.datasets import load_iris
from sklearn.preprocessing import MinMaxScaler

import math
import numpy as np

import matplotlib.pyplot as plt

iris = load_iris()
features = iris.data
labels = iris.target

print(features[0])

sc = MinMaxScaler(feature_range = (0,1))
features = sc.fit_transform(features)

sigma = 1.5
lr = 0.5
n_features = features.shape[1]
n_samples = features.shape[0]

map_size = 5 * math.sqrt(n_samples)
map_height = map_width = math.ceil(math.sqrt(map_size))


print(f'(map_height, map_width) = ({map_height}, {map_width})')
print(f'Number of features: {n_features}')

som = MiniSom(x=map_height, y=map_width, input_len=n_features, sigma=sigma, learning_rate=lr,
              neighborhood_function='gaussian', random_seed=123)

som.pca_weights_init(features)
som.train(data=features, num_iteration=1000, verbose=True)  # random training

print('-------------\nDistance Map\n------------')
print(f'Shape: {som.distance_map().shape}')
print(f'First Line: {som.distance_map().T[0]}')

frequencies = som.activation_response(features)
print(f'Frequencies:\n {np.array(frequencies, np.uint)}')

print(iris.target_names)

plt.figure(figsize=(map_height, map_width))

# plot U-matrix
u_matrix = som.distance_map().T
plt.pcolor(u_matrix, cmap='bone_r')
plt.colorbar()

# plot markers
markers = ['o', 's', '^']   # 'setosa', 'versicolor' 'virginica'
colors = ['r', 'g', 'b']
for feature, label in zip(features, labels):
    w = som.winner(feature)
    plt.plot(w[0] + 0.5, w[1] + 0.5,
        markers[label], markeredgecolor = colors[label],
        markerfacecolor = 'None', markersize = 10, markeredgewidth = 1)

plt.show()

def plot_distance_map(ax, fig):
    """Plot the distance map"""
    p = ax.pcolor(som.distance_map().T, cmap='bone_r') # cmap='Blues'
    # ax.colorbar()
    fig.colorbar(p, ax=ax)

def plot_clusters_scatter(ax):
    """
    Create a scatter plot of the winning neurons.
    Each neuron is assigned the color of the cluster it belongs to.
    """
    # Get the winning neuron coordinates for each sample
    # The coordinates are transformed into an array for the scatter plot: (1,1) => [1,1]
    winning_neurons = np.array([som.winner(x) for x in features])

    # Add a random offset to avoid overlaps between points within the same cell
    offset = np.random.uniform(low=-0.4, high=0.4, size=(len(features), 2))
    winning_neurons = winning_neurons + offset

    # Define the colors based on the labels
    colors = ['#ff0400', 'g', '#e88325']
    label_colors = [colors[label] for label in labels]

    # Create the scatter plot
    # 1st column represent x and second, y coordinate
    ax.scatter(winning_neurons[:,0], winning_neurons[:,1], s=10, c=label_colors)

def plot_clusters_markers(ax):
    """
    Plot the winning neurons as markers.
    Each marker is assigned the color of the cluster ir belongs to.
    """
    markers = ['o', 's', '^']
    colors = ['#ff0400', 'g', '#e88325']
    for i, feature in enumerate(features):
        w = som.winner(feature)
        ax.plot(w[0] + 0.5, w[1] + 0.5,
            markers[labels[i]], markeredgecolor = colors[labels[i]],
            markerfacecolor = 'None', markersize = 10, markeredgewidth = 1)

    # legend
    ax.legend(handles=[plt.Line2D([], [], color='#ff0400', marker='o', linestyle='None', label='Setosa'),
                    plt.Line2D([], [], color='green', marker='s', linestyle='None', label='Versicolor'),
                    plt.Line2D([], [], color='#e88325', marker='^', linestyle='None', label='Virginica')],
                    bbox_to_anchor=(1.5, 1.03))

fig, axes = plt.subplots(1, 3, figsize=(12, 4))

plot_distance_map(axes[0], fig)
plot_clusters_scatter(axes[1])
plot_clusters_markers(axes[2])

plt.suptitle("Plants species clusters")
plt.show()

plt.figure(figsize=(5, 4))

frequencies = som.activation_response(features)
plt.pcolor(frequencies.T, cmap='Blues')
plt.colorbar()
plt.show()

