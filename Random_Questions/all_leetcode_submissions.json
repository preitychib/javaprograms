[
  {
    "question_id": 3553,
    "code": "class Solution {\n    public boolean checkTwoChessboards(String c1, String c2) {\n        \n        int a=c1.charAt(0) -'a';\n        int b=c2.charAt(0) -'a';\n        int c=c1.charAt(1) -'1';\n        int d=c2.charAt(1) -'1';\n        \n        if(a%2==b%2){\n                if(c%2==d%2)\n                    return true;\n                return false;\n        }else{\n\n            if(c%2!=d%2)\n                    return true;\n                return false;\n        }\n    }\n}",
    "title_slug": "check-if-two-chessboard-squares-have-the-same-color",
    "problem_url": "https://leetcode.com/problems/check-if-two-chessboard-squares-have-the-same-color/"
  },
  {
    "question_id": 3568,
    "code": "class Solution {\n    public int generateKey(int num1, int num2, int num3) {\n        \n        int key=0;\n        int power=1;\n        for(int i=0;i<4;i++){\n            int a= num1%10;\n            int b= num2%10;\n            int c= num3%10;\n            \n            num1/=10;\n            num2/=10;\n            num3/=10;\n            \n            key+= power* (Math.min(Math.min(a,b),c)) ;\n            power*=10;\n        }\n        return key;\n    }\n}",
    "title_slug": "find-the-key-of-the-numbers",
    "problem_url": "https://leetcode.com/problems/find-the-key-of-the-numbers/"
  },
  {
    "question_id": 3553,
    "code": "class Solution {\n    public boolean checkTwoChessboards(String c1, String c2) {\n        \n        int a=c1.charAt(0) -'a' +1;\n        int b=c2.charAt(0) -'a' +1;\n        int c=c1.charAt(1) -'1' +1;\n        int d=c2.charAt(1) -'1' +1;\n        \n        if(a%2==b%2){\n                if(c%2==d%2)\n                    return true;\n                return false;\n        }else{\n\n            if(c%2!=d%2)\n                    return true;\n                return false;\n        }\n    }\n}",
    "title_slug": "check-if-two-chessboard-squares-have-the-same-color",
    "problem_url": "https://leetcode.com/problems/check-if-two-chessboard-squares-have-the-same-color/"
  },
  {
    "question_id": 1135,
    "code": "# Write your MySQL query statement below\n\nselect customer_id \nfrom Customer\n\ngroup by customer_id\n\nhaving \ncount(distinct product_key) = (select count(product_key) from Product);",
    "title_slug": "customers-who-bought-all-products",
    "problem_url": "https://leetcode.com/problems/customers-who-bought-all-products/"
  },
  {
    "question_id": 1245,
    "code": "# Write your MySQL query statement below\nselect activity_date as day,\ncount(distinct user_id) as active_users\nfrom Activity \nwhere activity_date between '2019-06-28' and '2019-07-27'\ngroup by activity_date ",
    "title_slug": "user-activity-for-the-past-30-days-i",
    "problem_url": "https://leetcode.com/problems/user-activity-for-the-past-30-days-i/"
  },
  {
    "question_id": 2805,
    "code": "/**\n * @param {number[]} nums\n * @return {void}\n */\nvar ArrayWrapper = function(nums) {\n    this.nums=nums;\n};\n\n/**\n * @return {number}\n */\nArrayWrapper.prototype.valueOf = function() {\n    return this.nums.reduce((sum,num)=> sum+num,0);\n}\n\n/**\n * @return {string}\n */\nArrayWrapper.prototype.toString = function() {\n    return `[${this.nums.join(',')}]`;\n}\n\n/**\n * const obj1 = new ArrayWrapper([1,2]);\n * const obj2 = new ArrayWrapper([3,4]);\n * obj1 + obj2; // 10\n * String(obj1); // \"[1,2]\"\n * String(obj2); // \"[3,4]\"\n */",
    "title_slug": "array-wrapper",
    "problem_url": "https://leetcode.com/problems/array-wrapper/"
  },
  {
    "question_id": 2812,
    "code": "class Solution {\n    public int theMaximumAchievableX(int num, int t) {\n        return num+ (t*2);\n    }\n}",
    "title_slug": "find-the-maximum-achievable-number",
    "problem_url": "https://leetcode.com/problems/find-the-maximum-achievable-number/"
  },
  {
    "question_id": 3543,
    "code": "class Solution {\n    public int countKConstraintSubstrings(String s, int k) {\n        int n=s.length();\n        int ans=0;\n        for(int i=0;i<n;i++){\n            int zero=0; int one=0;\n            for(int j=i;j<n;j++){\n                if(s.charAt(j)=='0') zero++;\n                else one++;\n                if(zero<=k || one<=k) ans++;\n                else break;\n            }\n        }\n\n        return ans;\n    }\n}",
    "title_slug": "count-substrings-that-satisfy-k-constraint-i",
    "problem_url": "https://leetcode.com/problems/count-substrings-that-satisfy-k-constraint-i/"
  },
  {
    "question_id": 3543,
    "code": "class Solution {\n    public int countKConstraintSubstrings(String s, int k) {\n        int n=s.length();\n        int ans=1;\n        for(int i=0;i<n-1;i++){\n            int zero=0; int one=0;\n            for(int j=i;j<n;j++){\n                if(s.charAt(j)=='0') zero++;\n                else one++;\n                if(zero<=k || one<=k) ans++;\n                else break;\n            }\n        }\n        return ans;\n    }\n}",
    "title_slug": "count-substrings-that-satisfy-k-constraint-i",
    "problem_url": "https://leetcode.com/problems/count-substrings-that-satisfy-k-constraint-i/"
  },
  {
    "question_id": 19,
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode slow=new ListNode(0,head);\n        ListNode fast=head;\n\n        for(int i=0;i<n;i++)\n            fast=fast.next; // move n time forward\n\n        while(fast!=null){\n            slow=slow.next;\n            fast=fast.next;\n        }\n        if(slow.next==head){\n            slow.next=slow.next.next;\n            return slow.next;\n        }\n        slow.next=slow.next.next;\n        return head;\n    }\n}",
    "title_slug": "remove-nth-node-from-end-of-list",
    "problem_url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/"
  },
  {
    "question_id": 139,
    "code": "class Solution {\n    boolean check(String s, int start, HashSet<String> set, HashMap<Integer, Boolean> dp) {\n        if (start == s.length()) {\n            return true;\n        }\n        if (dp.containsKey(start)) {\n            return dp.get(start);\n        }\n        \n        for (int end = start + 1; end <= s.length(); end++) {\n            if (set.contains(s.substring(start, end)) && check(s, end, set, dp)) {\n                dp.put(start, true);\n                return true;\n            }\n        }\n        \n        dp.put(start, false);\n        return false;\n    }\n    \n    public boolean wordBreak(String s, List<String> wordDict) {\n        HashSet<String> set = new HashSet<>(wordDict);\n        HashMap<Integer, Boolean> dp = new HashMap<>();\n        return check(s, 0, set, dp);\n    }\n}",
    "title_slug": "word-break",
    "problem_url": "https://leetcode.com/problems/word-break/"
  },
  {
    "question_id": 226,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root==null)\n            return root;\n\n        \n        TreeNode left=invertTree(root.left);\n        TreeNode right=invertTree(root.right);\n\n        root.left=right;\n        root.right=left;\n        return root;\n    }\n}",
    "title_slug": "invert-binary-tree",
    "problem_url": "https://leetcode.com/problems/invert-binary-tree/"
  },
  {
    "question_id": 104,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int helper(TreeNode node){\n        if(node==null){\n            return 0;\n        }\n        return Math.max(helper(node.left)+1, helper(node.right)+1);\n    }\n    public int maxDepth(TreeNode root) {\n        return helper(root);\n    }\n}",
    "title_slug": "maximum-depth-of-binary-tree",
    "problem_url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/"
  },
  {
    "question_id": 3533,
    "code": "class Solution {\n    public int finalPositionOfSnake(int n, List<String> commands) {\n        int x=0;\n        for(String s: commands){\n\n            if(s.equals(\"UP\")){\n                x-=n;\n            }else if(s.equals(\"RIGHT\")){\n                x+=1;\n\n            }else if(s.equals(\"DOWN\")){\n                x+=n;\n            }\n            else if(s.equals(\"LEFT\")){\n                x+=-1;\n            }\n        }\n        return x;\n    }\n}",
    "title_slug": "snake-in-matrix",
    "problem_url": "https://leetcode.com/problems/snake-in-matrix/"
  },
  {
    "question_id": 5,
    "code": "public class Solution {\n    public String longestPalindrome(String s) {\n        if (s.length() <= 1) {\n            return s;\n        }\n\n        int maxLen = 1;\n        String maxStr = s.substring(0, 1);\n\n        for (int i = 0; i < s.length(); i++) {\n            for (int j = i + maxLen; j <= s.length(); j++) {\n                if (j - i > maxLen && isPalindrome(s.substring(i, j))) {\n                    maxLen = j - i;\n                    maxStr = s.substring(i, j);\n                }\n            }\n        }\n\n        return maxStr;\n    }\n\n    private boolean isPalindrome(String str) {\n        int left = 0;\n        int right = str.length() - 1;\n\n        while (left < right) {\n            if (str.charAt(left) != str.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n\n        return true;\n    }\n}",
    "title_slug": "longest-palindromic-substring",
    "problem_url": "https://leetcode.com/problems/longest-palindromic-substring/"
  },
  {
    "question_id": 3,
    "code": "class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int left=0;\n        int n=s.length();\n        int maxlength=0;\n        HashSet<Character> set = new HashSet();\n        for(int right=0;right < n;right++ ){\n            while(set.contains(s.charAt(right))){\n                set.remove(s.charAt(left));\n                left++;\n            }\n            set.add(s.charAt(right));\n            maxlength= Math.max(maxlength,right-left+1);\n        }\n        return maxlength;\n        \n            }\n           \n        }\n    \n       ",
    "title_slug": "longest-substring-without-repeating-characters",
    "problem_url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/"
  },
  {
    "question_id": 2798,
    "code": "/**\n * @param {Array} arr\n * @param {number} size\n * @return {Array}\n */\nvar chunk = function(arr, size) {\n    if (size <= 0) return [];\n    let res=[];\n    for(let i=0;i < arr.length; i += size)\n        res.push(arr.slice(i,i+size));\n\n    return res;\n};",
    "title_slug": "chunk-array",
    "problem_url": "https://leetcode.com/problems/chunk-array/"
  },
  {
    "question_id": 15,
    "code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        List<List<Integer>> ans = new ArrayList<>();\n        Arrays.sort(nums);\n        int n=nums.length;\n        for(int i=0;i<n-2;i++){\n            if(i!=0 && nums[i]==nums[i-1]) continue;\n            int p1=i+1;\n            int p2=n-1;\n            while(p1<p2){\n                int sum=nums[i]+nums[p1]+nums[p2];\n                if(sum==0){\n                    ans.add(new ArrayList<>(Arrays.asList(nums[i],nums[p1],nums[p2])));\n                    p2--; p1++;\n\n                    while(p1<p2 && nums[p1-1]==nums[p1]){\n                    p1++;\n                    }\n                    while(p1<p2 && nums[p2]==nums[p2+1]){\n                        p2--;\n                    }\n                }else if(sum>0){\n                    p2--;\n                }else\n                    p1++;\n            }\n        }\n        return ans;\n    }\n}",
    "title_slug": "3sum",
    "problem_url": "https://leetcode.com/problems/3sum/"
  },
  {
    "question_id": 15,
    "code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Set<List<Integer>> ans = new HashSet<>();\n        Arrays.sort(nums);\n        int n=nums.length;\n        for(int i=0;i<n-2;i++){\n            int p1=i+1;\n            int p2=n-1;\n            while(p1<p2){\n                int sum=nums[i]+nums[p1]+nums[p2];\n                if(sum==0){\n                    ans.add(new ArrayList<>(Arrays.asList(nums[i],nums[p1],nums[p2])));\n                    p2--; p1++;\n                }else if(sum>0){\n                    p2--;\n                }else\n                    p1++;\n            }\n        }\n\n        return new ArrayList<>(ans);\n    }\n}",
    "title_slug": "3sum",
    "problem_url": "https://leetcode.com/problems/3sum/"
  },
  {
    "question_id": 15,
    "code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Set<List<Integer>> ans = new HashSet<>();\n        Arrays.sort(nums);\n        int n=nums.length;\n        for(int i=0;i<n-2;i++){\n            int p1=i+1;\n            int p2=n-1;\n            while(p1<p2){\n                int sum=nums[i]+nums[p1]+nums[p2];\n                if(sum==0){\n                    ans.add(new ArrayList<>(Arrays.asList(nums[i],nums[p1],nums[p2])));\n                    p2--;\n                }else if(sum>0){\n                    p2--;\n                }else\n                    p1++;\n            }\n        }\n\n        return new ArrayList<>(ans);\n    }\n}",
    "title_slug": "3sum",
    "problem_url": "https://leetcode.com/problems/3sum/"
  },
  {
    "question_id": 53,
    "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n       \n       int largest_sum=nums[0];\n       int sum=nums[0];\n\n       for(int i=1;i<nums.length;i++){\n\n        sum = Math.max(sum+nums[i],nums[i]);\n        largest_sum= Math.max(largest_sum,sum);\n       }\n\n       return largest_sum;\n    }\n}",
    "title_slug": "maximum-subarray",
    "problem_url": "https://leetcode.com/problems/maximum-subarray/"
  },
  {
    "question_id": 3515,
    "code": "class Solution {\n    public boolean canAliceWin(int[] nums) {\n        int s=0,d=0;\n        for(int i: nums){\n            if(i>=0&&i<=9) s+=i;\n            else d+=i;\n        }\n        if(s==d) return false;\n        return  true;\n    }\n}",
    "title_slug": "find-if-digit-game-can-be-won",
    "problem_url": "https://leetcode.com/problems/find-if-digit-game-can-be-won/"
  },
  {
    "question_id": 2,
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        \n        ListNode sum= new ListNode();\n        ListNode ans=sum;\n        int carry=0;\n        while((l1!=null)  && (l2!=null)){\n            int x= l1.val + l2.val+carry;\n            ans.next=new ListNode(x%10);\n            ans=ans.next;\n            carry=x/10;\n            l1=l1.next; l2=l2.next;\n        }\n\n        while(l1!=null){\n            int x=l1.val+carry;\n            ans.next= new ListNode(x%10);\n            carry=x/10;\n            l1=l1.next;ans=ans.next;\n        }\n        while(l2!=null){\n            int x=l2.val+carry;\n            ans.next= new ListNode(x%10);\n            carry=x/10;\n            l2=l2.next; ans=ans.next;\n        }\n\n        if(carry>0){\n            ans.next= new ListNode(carry%10);\n        }\n        return sum.next;\n\n    }\n}",
    "title_slug": "add-two-numbers",
    "problem_url": "https://leetcode.com/problems/add-two-numbers/"
  },
  {
    "question_id": 139,
    "code": "class Solution {\n    boolean check(String s, int start, HashSet<String> set, HashMap<Integer, Boolean> dp) {\n        if (start == s.length()) {\n            return true;\n        }\n        if (dp.containsKey(start)) {\n            return dp.get(start);\n        }\n        \n        for (int end = start + 1; end <= s.length(); end++) {\n            if (set.contains(s.substring(start, end)) && check(s, end, set, dp)) {\n                dp.put(start, true);\n                return true;\n            }\n        }\n        \n        dp.put(start, false);\n        return false;\n    }\n    \n    public boolean wordBreak(String s, List<String> wordDict) {\n        HashSet<String> set = new HashSet<>(wordDict);\n        HashMap<Integer, Boolean> dp = new HashMap<>();\n        return check(s, 0, set, dp);\n    }\n}",
    "title_slug": "word-break",
    "problem_url": "https://leetcode.com/problems/word-break/"
  },
  {
    "question_id": 2519,
    "code": "class Solution {\n    public int[] findArray(int[] pref) {\n        // int n=pref.length;\n        // int ans[] = new int[n];\n        // ans[0]=pref[0];\n        // for(int i=1;i<n;i++){\n        //     ans[i]= pref[i]^pref[i-1];\n        // }\n        // return ans;\n\n        for(int i = pref.length - 1; i > 0; i--) {\n            pref[i] = pref[i] ^ pref[i - 1];\n        }\n        return pref;\n    }\n}",
    "title_slug": "find-the-original-array-of-prefix-xor",
    "problem_url": "https://leetcode.com/problems/find-the-original-array-of-prefix-xor/"
  },
  {
    "question_id": 2519,
    "code": "class Solution {\n    public int[] findArray(int[] pref) {\n        int n=pref.length;\n        int ans[] = new int[n];\n        ans[0]=pref[0];\n        for(int i=1;i<n;i++){\n            ans[i]= pref[i]^pref[i-1];\n        }\n        return ans;\n    }\n}",
    "title_slug": "find-the-original-array-of-prefix-xor",
    "problem_url": "https://leetcode.com/problems/find-the-original-array-of-prefix-xor/"
  },
  {
    "question_id": 1441,
    "code": "class Solution {\n    public int minFlips(int a, int b, int c) {\n        \n        int count=0;\n        while(a > 0 || b > 0 || c > 0){\n            int lastc=c&1;\n            int lasta=a&1;\n            int lastb=b&1;\n            System.out.println(lastc+\" \"+lasta+\" \"+lastb);\n            if(lastc==1){\n                if(lasta==0 && lastb==0)\n                    count++;\n            }else{\n                if(lasta!=lastb)\n                    count++;\n                else if(lasta==1) count+=2;\n            }\n            c=c>>1;\n            a=a>>1;\n            b=b>>1;\n        }\n\n        return count;\n    }\n}",
    "title_slug": "minimum-flips-to-make-a-or-b-equal-to-c",
    "problem_url": "https://leetcode.com/problems/minimum-flips-to-make-a-or-b-equal-to-c/"
  },
  {
    "question_id": 226,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root==null)\n            return root;\n\n        \n        TreeNode left=invertTree(root.left);\n        TreeNode right=invertTree(root.right);\n\n        root.left=right;\n        root.right=left;\n        return root;\n    }\n}",
    "title_slug": "invert-binary-tree",
    "problem_url": "https://leetcode.com/problems/invert-binary-tree/"
  },
  {
    "question_id": 789,
    "code": "class KthLargest {\n    PriorityQueue<Integer> pQueue;\n    int k;\n    public KthLargest(int k, int[] nums) {\n        this.k=k;\n        pQueue = new PriorityQueue<Integer>();\n        for(int x: nums){\n            pQueue.offer(x);\n            if(pQueue.size()>k){\n                pQueue.poll();\n            }\n        }\n    }\n    \n    public int add(int val) {\n        pQueue.offer(val);\n        if(pQueue.size()>k){\n            pQueue.poll();\n        }\n        return pQueue.peek();\n    }\n}\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest obj = new KthLargest(k, nums);\n * int param_1 = obj.add(val);\n */",
    "title_slug": "kth-largest-element-in-a-stream",
    "problem_url": "https://leetcode.com/problems/kth-largest-element-in-a-stream/"
  },
  {
    "question_id": 789,
    "code": "class KthLargest {\n    PriorityQueue<Integer> pQueue;\n    int k;\n    public KthLargest(int k, int[] nums) {\n        this.k=k;\n        pQueue = new PriorityQueue<Integer>();\n        for(int x: nums){\n            pQueue.offer(x);\n            if(pQueue.size()>k){\n                pQueue.poll();\n            }\n        }\n    }\n    \n    public int add(int val) {\n        pQueue.offer(val);\n        if(pQueue.size()>k){\n            pQueue.poll();\n        }\n        return pQueue.peek();\n    }\n}\n\n/**\n * Your KthLargest object will be instantiated and called as such:\n * KthLargest obj = new KthLargest(k, nums);\n * int param_1 = obj.add(val);\n */",
    "title_slug": "kth-largest-element-in-a-stream",
    "problem_url": "https://leetcode.com/problems/kth-largest-element-in-a-stream/"
  },
  {
    "question_id": 230,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    void helper(TreeNode temp, int k, Stack<Integer> s){\n        if(temp==null){\n            return;\n        }\n\n        helper(temp.left,k,s);\n        if(s.size()==k){\n            return;\n        }\n        s.push(temp.val);\n        helper(temp.right,k,s);\n    }\n    public int kthSmallest(TreeNode root, int k) {\n        Stack<Integer> s= new Stack<>();\n        helper(root,k,s);\n        return s.peek();\n    }\n}",
    "title_slug": "kth-smallest-element-in-a-bst",
    "problem_url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/"
  },
  {
    "question_id": 230,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    void helper(TreeNode temp, int k, Stack<Integer> s){\n        if(temp==null || s.size()==k){\n            return;\n        }\n\n        helper(temp.left,k,s);\n        if(s.size()==k){\n            return;\n        }\n        s.push(temp.val);\n        helper(temp.right,k,s);\n    }\n    public int kthSmallest(TreeNode root, int k) {\n        Stack<Integer> s= new Stack<>();\n\n        helper(root,k,s);\n        return s.peek();\n    }\n}",
    "title_slug": "kth-smallest-element-in-a-bst",
    "problem_url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/"
  },
  {
    "question_id": 3508,
    "code": "class Solution {\n    public int minChanges(int n, int k) {\n      if((n&k)!=k)\n        return -1;\n            \n      int x= (k^n);\n\n      int oneBitsCount = Integer.bitCount(x);\n      return oneBitsCount;\n\n    }\n}",
    "title_slug": "number-of-bit-changes-to-make-two-integers-equal",
    "problem_url": "https://leetcode.com/problems/number-of-bit-changes-to-make-two-integers-equal/"
  },
  {
    "question_id": 3462,
    "code": "class Solution {\n    public boolean doesAliceWin(String s) {\n\n        for(char c: s.toCharArray()){\n            if(c=='a'|| c=='e'||c=='i'|| c=='o'||c=='u')\n                return true;\n        }\n        return false;\n    }\n}",
    "title_slug": "vowels-game-in-a-string",
    "problem_url": "https://leetcode.com/problems/vowels-game-in-a-string/"
  },
  {
    "question_id": 207,
    "code": "class Solution {\n\n    boolean checkcycle(HashMap<Integer, ArrayList<Integer>> adj,HashSet<Integer> visit,HashSet<Integer> dfs,int i){\n        if(dfs.contains(i))\n            return true;\n\n        if(visit.contains(i))\n            return false;\n\n        visit.add(i); dfs.add(i);\n        boolean flag=false;\n        if(adj.containsKey(i)){\n            for(int x: adj.get(i)){\n                flag|=checkcycle(adj,visit,dfs,x);\n            }\n        }\n\n        dfs.remove(i);\n        return flag;\n        \n    }\n\n    public boolean canFinish(int n, int[][] prereq) {\n        int m=prereq.length;\n        HashMap<Integer, ArrayList<Integer>> adj = new HashMap<>();\n\n        for (int i = 0; i < m; i++) {\n            adj.putIfAbsent(prereq[i][0], new ArrayList<>());\n            adj.get(prereq[i][0]).add(prereq[i][1]);\n            // System.out.println(prereq[i][0]);\n        }\n\n        HashSet<Integer> visit= new HashSet<Integer>();\n        HashSet<Integer> dfs= new HashSet<Integer>();\n\n        for (int i=0;i<n;i++)  {\n            if(!visit.contains(i) && checkcycle(adj,visit,dfs,i)){\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "title_slug": "course-schedule",
    "problem_url": "https://leetcode.com/problems/course-schedule/"
  },
  {
    "question_id": 560,
    "code": "class Solution {\n    public int subarraySum(int[] nums, int k) {\n        HashMap<Integer, Integer> map = new HashMap<>();\n        int count = 0;\n        int sum = 0;\n        \n        map.put(0, 1);\n        for (int i = 0; i < nums.length; i++) {\n            sum += nums[i]; \n            if (map.containsKey(sum - k)) {\n                count += map.get(sum - k);\n            }\n\n            map.put(sum, map.getOrDefault(sum, 0) + 1); \n            }\n        \n        return count;\n    }\n}",
    "title_slug": "subarray-sum-equals-k",
    "problem_url": "https://leetcode.com/problems/subarray-sum-equals-k/"
  },
  {
    "question_id": 226,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root==null)\n            return root;\n\n        \n        TreeNode left=invertTree(root.left);\n        TreeNode right=invertTree(root.right);\n\n        root.left=right;\n        root.right=left;\n        return root;\n    }\n}",
    "title_slug": "invert-binary-tree",
    "problem_url": "https://leetcode.com/problems/invert-binary-tree/"
  },
  {
    "question_id": 226,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if(root==null) return root;\n        Queue<TreeNode> q= new LinkedList<>();\n        q.offer(root);\n        while(!q.isEmpty()) {\n            TreeNode x= q.poll();\n            if(x.right!=null) q.offer(x.right);\n            if(x.left!=null) q.offer(x.left);\n            TreeNode temp=x.right!=null? x.right:null;\n            x.right=x.left!=null?x.left:null;\n            x.left=temp;\n        }\n        return root;\n    }\n}",
    "title_slug": "invert-binary-tree",
    "problem_url": "https://leetcode.com/problems/invert-binary-tree/"
  },
  {
    "question_id": 19,
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode slow=new ListNode(0,head);\n        ListNode fast=head;\n\n        for(int i=0;i<n;i++)\n            fast=fast.next; // move n time forward\n\n        while(fast!=null){\n            slow=slow.next;\n            fast=fast.next;\n        }\n        if(slow.next==head){\n            slow.next=slow.next.next;\n            return slow.next;\n        }\n        slow.next=slow.next.next;\n        return head;\n    }\n}",
    "title_slug": "remove-nth-node-from-end-of-list",
    "problem_url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/"
  },
  {
    "question_id": 19,
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode slow=new ListNode(0,head);\n        ListNode fast=head;\n\n        for(int i=0;i<n;i++)\n            fast=fast.next; // move n time forward\n\n        \n        System.out.println(fast==null);\n        while(fast!=null){\n            slow=slow.next;\n            fast=fast.next;\n        }\n        if(slow.next==head){\n            slow.next=slow.next.next;\n            return slow.next;\n        }\n        slow.next=slow.next.next;\n        return head;\n    }\n}",
    "title_slug": "remove-nth-node-from-end-of-list",
    "problem_url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/"
  },
  {
    "question_id": 62,
    "code": "class Solution {\n    int helper(int m,int n,int i, int j,int[][] dp){\n        if(i==m && j==n)\n            return 1;\n        if(dp[i][j]!=-1)\n            return dp[i][j];\n        int ans=0;\n        if(i+1<=m){\n            ans+=helper(m,n,i+1,j,dp);\n        }\n        if(j+1<=n){\n            ans+=helper(m,n,i,j+1,dp);\n        }\n\n        return dp[i][j]=ans;\n    }\n    public int uniquePaths(int m, int n) {\n        \n        // down or right\n        // down is [m+1][n]\n        // right is [m][n+1]\n        int[][] dp= new int[m][n];\n        for(int[] d:dp)\n            Arrays.fill(d,-1);\n        return helper(m-1,n-1,0,0,dp);\n    }\n}\n",
    "title_slug": "unique-paths",
    "problem_url": "https://leetcode.com/problems/unique-paths/"
  },
  {
    "question_id": 2,
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        \n        ListNode sum= new ListNode();\n        ListNode ans=sum;\n        int carry=0;\n        while((l1!=null)  && (l2!=null)){\n            int x= l1.val + l2.val+carry;\n            ans.next=new ListNode(x%10);\n            ans=ans.next;\n            carry=x/10;\n            l1=l1.next; l2=l2.next;\n        }\n\n        while(l1!=null){\n            int x=l1.val+carry;\n            ans.next= new ListNode(x%10);\n            carry=x/10;\n            l1=l1.next;ans=ans.next;\n        }\n        while(l2!=null){\n            int x=l2.val+carry;\n            ans.next= new ListNode(x%10);\n            carry=x/10;\n            l2=l2.next; ans=ans.next;\n        }\n\n        if(carry>0){\n            ans.next= new ListNode(carry%10);\n        }\n        return sum.next;\n\n    }\n}",
    "title_slug": "add-two-numbers",
    "problem_url": "https://leetcode.com/problems/add-two-numbers/"
  },
  {
    "question_id": 2,
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        \n        ListNode sum= new ListNode();\n        ListNode ans=sum;\n        int carry=0;\n        while((l1!=null)  && (l2!=null)){\n            int x= l1.val + l2.val+carry;\n            ans.next=new ListNode(x%10);\n            ans=ans.next;\n            carry=x/10;\n            l1=l1.next; l2=l2.next;\n        }\n\n        while(l1!=null){\n            int x=l1.val+carry;\n            ans.next= new ListNode(x%10);\n            carry=x/10;\n            l1=l1.next;ans=ans.next;\n        }\n        while(l2!=null){\n            int x=l2.val+carry;\n            ans.next= new ListNode(x%10);\n            carry=x/10;\n            l2=l2.next; ans=ans.next;\n        }\n\n        while(carry!=0){\n            int x=carry;\n            ans.next= new ListNode(x%10);\n            carry=x/10;\n            ans=ans.next;\n        }\n        return sum.next;\n\n    }\n}",
    "title_slug": "add-two-numbers",
    "problem_url": "https://leetcode.com/problems/add-two-numbers/"
  },
  {
    "question_id": 141,
    "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow=head;\n        ListNode fast=head;\n\n\n        while(fast!=null && fast.next!=null ){\n            slow=slow.next;\n            fast=fast.next.next;\n            if(slow==fast)\n                return true;\n\n        }\n        return false;\n    }\n}",
    "title_slug": "linked-list-cycle",
    "problem_url": "https://leetcode.com/problems/linked-list-cycle/"
  },
  {
    "question_id": 141,
    "code": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        ListNode slow=head;\n        ListNode fast=head;\n\n\n        while(fast!=null && fast.next!=null ){\n\n            slow=slow.next;\n            if(fast!=null && fast.next!=null)\n            fast=fast.next.next;\n            else return false;\n\n            if(slow==fast)\n                return true;\n\n        }\n        return false;\n    }\n}",
    "title_slug": "linked-list-cycle",
    "problem_url": "https://leetcode.com/problems/linked-list-cycle/"
  },
  {
    "question_id": 14,
    "code": "class Solution {\n    public String longestCommonPrefix(String[] strs) {\n        StringBuilder s= new StringBuilder();\n        int n=strs.length;\n        char last=' ';\n        int j=0;\n       while(j<strs[0].length()){\n            boolean flag=true;\n            for(int i=0;i<n;i++){\n                if(i==0)\n                    last=strs[i].charAt(j); \n                else\n                    if(strs[i].length()<=j || strs[i].charAt(j)!=last){\n                        flag=false;\n                        break;\n                    }\n            }\n\n            if(!flag) \n                return s.toString();\n            else s.append(last);\n\n            j++;\n       }\n       return s.toString();\n    }\n}",
    "title_slug": "longest-common-prefix",
    "problem_url": "https://leetcode.com/problems/longest-common-prefix/"
  },
  {
    "question_id": 85,
    "code": "class Solution {\n\n    public int largestRectangleArea(int[] heights) {\n        // lowest element to the left of all\n        int n= heights.length;\n        Stack<Integer> s= new Stack<>();\n        int[] left= new int[n]; // smaller to the left\n        Arrays.fill(left,-1);\n        for(int i=0;i<n;i++){\n            while(!s.isEmpty() && heights[s.peek()]>=heights[i]){\n                s.pop();\n            }\n            if(!s.isEmpty()) left[i]=s.peek()+1;\n            s.push(i);\n        }\n\n        s= new Stack<>();\n        int[] right= new int[n]; // smaller to the right\n        Arrays.fill(right,-1);\n        for(int i=n-1;i>=0;i--){\n            while(!s.isEmpty() && heights[s.peek()]>=heights[i]){\n                s.pop();\n            }\n            if(!s.isEmpty()) right[i]=s.peek()-1;\n            s.push(i);\n        }\n\n        int maxarea=heights[0];\n        for(int i=0;i<n;i++){\n            int l = left[i]==-1?0:left[i];\n            int r = right[i]==-1?n-1:right[i];\n            maxarea= Math.max(maxarea, heights[i]*(r-l+1));\n        }\n        \n        return maxarea;\n    }\n    public int maximalRectangle(char[][] matrix) {\n        int n=matrix.length; //row\n        int m=matrix[0].length; //column\n        int arr[] = new int[m];\n        int ans=-1;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(matrix[i][j]=='1')\n                    arr[j]+=1;\n                else arr[j]=0;\n            }\n        ans=Math.max(ans,largestRectangleArea(arr));\n        }\n        return ans;\n    }\n}",
    "title_slug": "maximal-rectangle",
    "problem_url": "https://leetcode.com/problems/maximal-rectangle/"
  },
  {
    "question_id": 3501,
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        HashSet<Integer> set= new HashSet<>();\n\n        for(int i:nums) set.add(i);\n\n        ListNode x=new ListNode(0,head);\n        ListNode temp=x;\n        while(temp.next!=null){\n            if(set.contains(temp.next.val)){\n                temp.next=temp.next.next;\n            }else\n                temp=temp.next;\n        }\n\n        return x.next;\n        \n    }\n}",
    "title_slug": "delete-nodes-from-linked-list-present-in-array",
    "problem_url": "https://leetcode.com/problems/delete-nodes-from-linked-list-present-in-array/"
  },
  {
    "question_id": 3501,
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode modifiedList(int[] nums, ListNode head) {\n        HashSet<Integer> set= new HashSet<>();\n\n        for(int i:nums) set.add(i);\n\n        ListNode tempHead= new ListNode(0);\n        tempHead.next=head;\n\n        ListNode prev=tempHead;\n        ListNode current=head;\n\n        while(current!=null){\n\n            if(set.contains(current.val)){\n                prev.next=current.next;\n            }else{\n                prev=current;\n            }\n            current=current.next;\n        }\n        return tempHead.next;\n    }\n}",
    "title_slug": "delete-nodes-from-linked-list-present-in-array",
    "problem_url": "https://leetcode.com/problems/delete-nodes-from-linked-list-present-in-array/"
  },
  {
    "question_id": 3484,
    "code": "class Solution {\n    public String getSmallestString(String s) {\n        boolean parity=(s.charAt(0)-'0')%2==0?true:false;\n        for(int i=1;i<s.length();i++){\n            boolean newparity=(s.charAt(i)-'0')%2==0?true:false;\n            if(parity==newparity && (s.charAt(i-1)-'0')>(s.charAt(i)-'0')){\n                StringBuilder sb = new StringBuilder(s);\n                char temp = sb.charAt(i-1);\n                sb.setCharAt(i-1, sb.charAt(i));\n                sb.setCharAt(i, temp);\n                return sb.toString();\n            }\n            parity=newparity;\n        }\n        return s;\n\n    }\n}",
    "title_slug": "lexicographically-smallest-string-after-a-swap",
    "problem_url": "https://leetcode.com/problems/lexicographically-smallest-string-after-a-swap/"
  },
  {
    "question_id": 547,
    "code": "class Solution {\n\n    void dfs(int[] visited, int i,int[][] isConnected){\n        visited[i]=1;\n        for(int j=0;j<visited.length;j++){\n            if(isConnected[i][j]==1 && visited[j]==0){\n                dfs(visited,j,isConnected);\n            }\n        }\n    }\n    public int findCircleNum(int[][] isConnected) {\n       \n        int m=isConnected.length;\n        int n= isConnected[0].length;\n        int[] visited= new int[n];\n        int count=0;\n        for(int i=0;i<m;i++)\n            if(visited[i]==0){\n                dfs(visited,i,isConnected);\n                count++;\n            }\n\n        return count;\n            \n                \n    }\n}",
    "title_slug": "number-of-provinces",
    "problem_url": "https://leetcode.com/problems/number-of-provinces/"
  },
  {
    "question_id": 42,
    "code": "class Solution {\n    public int trap(int[] height) {\n        // need greatest element to the left and right of each element\n        int n=height.length;\n        if(n<2) return 0;\n        int[] left= new int[n];\n        left[0]=-1;\n        for(int i=1;i<n;i++){\n            if(height[i-1]>left[i-1]){\n                left[i]=height[i-1];\n            }else left[i]=left[i-1];\n        }\n\n        int[] right= new int[n];\n        right[n-1]=-1;\n        for(int i=n-2;i>=0;i--){\n            if(height[i+1]>right[i+1]){\n                right[i]=height[i+1];\n            }else right[i]=right[i+1];\n        }\n        // System.out.println(Arrays.toString(left));\n        // System.out.println(Arrays.toString(right));\n        // now i want to add up the area till i find any index whose \n\n        int maxarea=0;\n        int area=0;\n        int x= Math.min(left[1],right[1]);\n        for(int i=1;i<n-1;i++){\n            x= Math.min(left[i],right[i]);\n            // System.out.println(x+\" \"+area+\" \"+left[i]+\" \"+right[i]);\n            if(x<=height[i]){\n                maxarea=Math.max(maxarea,area);\n                continue;\n            }\n            area+= (x-height[i]);\n        }\n        return area;\n    }\n}",
    "title_slug": "trapping-rain-water",
    "problem_url": "https://leetcode.com/problems/trapping-rain-water/"
  },
  {
    "question_id": 3492,
    "code": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int m=grid.length;\n        int n=grid[0].length;\n        int ans=0;\n        int[][][] count= new int[m][n][2]; // count occurence of x,y in each prefix sum  \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[j][i]=='X')\n                    count[j][i][0]++;\n                if(grid[j][i]=='Y')\n                    count[j][i][1]++;\n                \n                if(j>0){\n                    count[j][i][0]+=count[j-1][i][0];\n                    count[j][i][1]+=count[j-1][i][1];\n                }\n\n                if(i>0){\n                count[j][i][0]+=count[j][i-1][0];\n                count[j][i][1]+=count[j][i-1][1];\n                }\n                \n                if(i>0 && j>0){\n                    count[j][i][0]-=count[j-1][i-1][0];\n                    count[j][i][1]-=count[j-1][i-1][1];\n                }\n                 if(count[j][i][0]>0 && count[j][i][0]==count[j][i][1])\n                    ans++;\n\n            }\n        }\n        return ans;\n    }\n    \n}",
    "title_slug": "count-submatrices-with-equal-frequency-of-x-and-y",
    "problem_url": "https://leetcode.com/problems/count-submatrices-with-equal-frequency-of-x-and-y/"
  },
  {
    "question_id": 3492,
    "code": "class Solution {\n    public int numberOfSubmatrices(char[][] grid) {\n        int m=grid.length;\n        int n=grid[0].length;\n        int[][][] count= new int[m][n][2]; // count occurence of x,y in each prefix sum  \n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(grid[j][i]=='X')\n                    count[j][i][0]++;\n                if(grid[j][i]=='Y')\n                    count[j][i][1]++;\n                \n                if(j>0){\n                    count[j][i][0]+=count[j-1][i][0];\n                    count[j][i][1]+=count[j-1][i][1];\n                }\n\n            }\n        }\n\n        int ans=0;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(j>0){\n                count[i][j][0]+=count[i][j-1][0];\n                count[i][j][1]+=count[i][j-1][1];\n                }\n\n                if(count[i][j][0]>0 && count[i][j][0]==count[i][j][1])\n                    ans++;\n            }\n        }\n        return ans;\n    }\n    \n}",
    "title_slug": "count-submatrices-with-equal-frequency-of-x-and-y",
    "problem_url": "https://leetcode.com/problems/count-submatrices-with-equal-frequency-of-x-and-y/"
  },
  {
    "question_id": 416,
    "code": "class Solution {\n    static Boolean helper(int[] arr, int n,int sum,Boolean[][] dp){\n        if(sum==0)\n            return true;\n        if(n==0){\n            return false;\n        }\n        \n        if(dp[n][sum]!=null)\n            return dp[n][sum];\n        \n        Boolean notpick= helper(arr,n-1,sum,dp);\n        Boolean pick= false;\n        if(arr[n-1]<=sum) {\n           pick=helper(arr,n-1,sum-arr[n-1],dp);\n        }\n        return dp[n][sum]=pick||notpick;\n    }\n    public boolean canPartition(int[] nums) {\n        int sum=0;\n        for(int i:nums) sum+=i;\n\n        if(sum%2==1) return false;\n        int n= nums.length;\n        sum/=2;\n        Boolean[][] dp = new Boolean[n+1][sum+1];\n        for(Boolean[] d:dp) Arrays.fill(d,null);\n        return helper(nums,n,sum,dp);\n    }\n}",
    "title_slug": "partition-equal-subset-sum",
    "problem_url": "https://leetcode.com/problems/partition-equal-subset-sum/"
  },
  {
    "question_id": 20,
    "code": "class Solution {\n    public boolean isValid(String s) {\n        Stack<Character> stack = new Stack<Character>();\n        \n        for (char c : s.toCharArray()) {\n            if (c == '(' || c == '{' || c == '[') {\n                stack.push(c);\n            } else {\n                if (stack.isEmpty()) {\n                    return false;\n                }\n                char top = stack.pop();\n                if (c == ')' && top != '(') {\n                    return false;\n                } else if (c == '}' && top != '{') {\n                    return false;\n                } else if (c == ']' && top != '[') {\n                    return false;\n                }\n            }\n        }\n        \n        return stack.isEmpty();\n    }\n}\n",
    "title_slug": "valid-parentheses",
    "problem_url": "https://leetcode.com/problems/valid-parentheses/"
  },
  {
    "question_id": 3463,
    "code": "class Solution {\n    public int numberOfAlternatingGroups(int[] colors) {\n        int ans=0;\n        int n=colors.length;\n        for(int i=0;i<n;i++){\n            if(colors[i%n]!=colors[(i+1)%n] && colors[i%n]==colors[(i+2)%n]) \n                ans++;\n        }\n        return ans;\n    }\n}",
    "title_slug": "alternating-groups-i",
    "problem_url": "https://leetcode.com/problems/alternating-groups-i/"
  },
  {
    "question_id": 3453,
    "code": "class Solution {\n    \n    void helper(List<String> ans,int n,StringBuilder s){\n        if(n==0){\n            ans.add(s.toString());\n            return;\n        }\n        if(s.length()<1 || s.charAt(s.length()-1)!='0'){\n            s.append('0');\n            helper(ans,n-1,s); \n            s.setLength(s.length() - 1);\n        }\n        s.append('1');\n        helper(ans,n-1,s);\n        s.setLength(s.length() - 1);\n        \n    }\n    \n        \n    public List<String> validStrings(int n) {\n        \n        List<String> ans= new ArrayList<String>();\n        helper(ans,n,new StringBuilder());\n        return ans;\n    }\n}",
    "title_slug": "generate-binary-strings-without-adjacent-zeros",
    "problem_url": "https://leetcode.com/problems/generate-binary-strings-without-adjacent-zeros/"
  },
  {
    "question_id": 3468,
    "code": "class Solution {\n    public String getEncryptedString(String s, int k) {\n        StringBuilder ans= new StringBuilder();\n        int n=s.length();\n        for(int i=0;i<n;i++){\n            ans.append(s.charAt((i+k)%n));\n        }\n        return ans.toString();\n    }\n}",
    "title_slug": "find-the-encrypted-string",
    "problem_url": "https://leetcode.com/problems/find-the-encrypted-string/"
  },
  {
    "question_id": 3483,
    "code": "class Solution {\n    public int numberOfAlternatingGroups(int[] colors, int k) {\n        \n        int ans=0;\n        int n=colors.length;\n        int count=1;\n        // this n+k-2 is because\n        // for the n-1 we need to check for k-1 more element\n        for(int i=0;i<n+k-2;i++){\n            // sliding window \n            // of k set is valid for (i,j) then check for (i+1,j+1) \n            if(colors[i%n]!=colors[(i+1)%n]) count++;\n            else count=1;\n            if(count>=k) ans++;\n        }\n        return ans;\n    }\n}",
    "title_slug": "alternating-groups-ii",
    "problem_url": "https://leetcode.com/problems/alternating-groups-ii/"
  },
  {
    "question_id": 3483,
    "code": "class Solution {\n    public int numberOfAlternatingGroups(int[] colors, int k) {\n        \n        int ans=0;\n        int n=colors.length;\n        int count=1;\n        for(int i=0;i<n+k-2;i++){\n            // sliding window \n            // of k set is valid for (i,j) then check for (i+1,j+1) \n            if(colors[i%n]!=colors[(i+1)%n]) count++;\n            else count=1;\n            if(count>=k) ans++;\n        }\n        return ans;\n    }\n}",
    "title_slug": "alternating-groups-ii",
    "problem_url": "https://leetcode.com/problems/alternating-groups-ii/"
  },
  {
    "question_id": 3463,
    "code": "class Solution {\n    public int numberOfAlternatingGroups(int[] colors) {\n        int ans=0;\n        int n=colors.length;\n        int i=0;\n        do{\n            if(colors[i]!=colors[(i+1)%n] && colors[i]==colors[(i+2)%n]) \n                ans++;\n           // System.out.println(colors[i]+\" \"+colors[(i+1)%n]+\" \"+colors[(i+2)%n]+\" \"+i);\n            i= (i+1)%n;\n        }while(i!=0);\n        return ans;\n    }\n}",
    "title_slug": "alternating-groups-i",
    "problem_url": "https://leetcode.com/problems/alternating-groups-i/"
  },
  {
    "question_id": 3264,
    "code": "class Solution {\n    public long maximumPoints(int[] enemyEnergies, int currentEnergy) {\n        int ind=0;\n        int n=enemyEnergies.length;\n        for(int i=1;i<n;i++){\n            if(enemyEnergies[i]<enemyEnergies[ind]){\n                ind=i;\n            }\n        }   \n        if(enemyEnergies[ind]>currentEnergy) return 0;\n        long total=currentEnergy;\n        for(int i=0;i<n;i++){\n            if(i==ind) continue;\n            total+=enemyEnergies[i];\n        }\n        // System.out.println(total+\" \"+ind);\n        return (long)(total/enemyEnergies[ind]);\n    }\n}",
    "title_slug": "maximum-points-after-enemy-battles",
    "problem_url": "https://leetcode.com/problems/maximum-points-after-enemy-battles/"
  },
  {
    "question_id": 608,
    "code": "# Write your MySQL query statement below\n\nselect id, \n\ncase when p_id is null then \"Root\"\n     when id in (select p_id from tree) then \"Inner\"\n     else \"Leaf\"\nend as type\n     from Tree ;",
    "title_slug": "tree-node",
    "problem_url": "https://leetcode.com/problems/tree-node/"
  },
  {
    "question_id": 84,
    "code": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        // lowest element to the left of all\n        int n= heights.length;\n        Stack<Integer> s= new Stack<>();\n        int[] left= new int[n]; // smaller to the left\n        Arrays.fill(left,-1);\n        for(int i=0;i<n;i++){\n            while(!s.isEmpty() && heights[s.peek()]>=heights[i]){\n                s.pop();\n            }\n            if(!s.isEmpty()) left[i]=s.peek()+1;\n            s.push(i);\n        }\n\n        s= new Stack<>();\n        int[] right= new int[n]; // smaller to the right\n        Arrays.fill(right,-1);\n        for(int i=n-1;i>=0;i--){\n            while(!s.isEmpty() && heights[s.peek()]>=heights[i]){\n                s.pop();\n            }\n            if(!s.isEmpty()) right[i]=s.peek()-1;\n            s.push(i);\n        }\n\n        int maxarea=heights[0];\n        for(int i=0;i<n;i++){\n            int l = left[i]==-1?0:left[i];\n            int r = right[i]==-1?n-1:right[i];\n            maxarea= Math.max(maxarea, heights[i]*(r-l+1));\n        }\n        \n        return maxarea;\n    }\n}",
    "title_slug": "largest-rectangle-in-histogram",
    "problem_url": "https://leetcode.com/problems/largest-rectangle-in-histogram/"
  },
  {
    "question_id": 84,
    "code": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        // lowest element to the left of all\n        int n= heights.length;\n        Stack<Integer> s= new Stack<>();\n        int[] left= new int[n]; // smaller to the left\n        Arrays.fill(left,-1);\n        for(int i=0;i<n;i++){\n            while(!s.isEmpty() && heights[s.peek()]>=heights[i]){\n                s.pop();\n            }\n            if(!s.isEmpty()) left[i]=s.peek()+1;\n            s.push(i);\n        }\n\n        s= new Stack<>();\n        int[] right= new int[n]; // smaller to the right\n        Arrays.fill(right,-1);\n        for(int i=n-1;i>=0;i--){\n            while(!s.isEmpty() && heights[s.peek()]>=heights[i]){\n                s.pop();\n            }\n            if(!s.isEmpty()) right[i]=s.peek()-1;\n            s.push(i);\n        }\n\n        // System.out.println(Arrays.toString(left));\n        // System.out.println(Arrays.toString(right));\n        int maxarea=heights[0];\n        for(int i=0;i<n;i++){\n            int l = left[i]==-1?0:left[i];\n            int r = right[i]==-1?n-1:right[i];\n            maxarea= Math.max(maxarea, heights[i]*(r-l+1));\n        }\n\n\n        return maxarea;\n    }\n}",
    "title_slug": "largest-rectangle-in-histogram",
    "problem_url": "https://leetcode.com/problems/largest-rectangle-in-histogram/"
  },
  {
    "question_id": 155,
    "code": "public class Pair{\n    int val;\n    int min;\n\n    Pair(int v,int m){\n        val=v; min=m;\n    }\n    int getVal(){\n        return val;\n    }\n    int getMin(){\n        return min;\n    }\n\n}\nclass MinStack {\n    Stack<Pair> s;\n    public MinStack() {\n        s= new Stack<>();\n    }\n    \n    public void push(int val) {\n        \n        int min= s.isEmpty()?val:s.peek().getMin();\n        if(val<min){\n            min=val;\n        }\n        s.push(new Pair(val,min));\n    }\n    \n    public void pop() {\n        s.pop();\n    }\n    \n    public int top() {\n        return s.peek().getVal();\n    }\n    \n    public int getMin() {\n        return s.peek().getMin();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */",
    "title_slug": "min-stack",
    "problem_url": "https://leetcode.com/problems/min-stack/"
  },
  {
    "question_id": 155,
    "code": "class MinStack {\n    Stack<Integer> s;\n    Stack<Integer> min;\n    public MinStack() {\n        s= new Stack<>();\n        min=new Stack<>();\n    }\n    \n    public void push(int val) {\n        s.push(val);\n        if(min.isEmpty() || min.peek()>=val) {\n            min.push(val);}\n    }\n    \n    public void pop() {\n        if(min.peek().equals(s.peek())) {\n        min.pop();}\n        s.pop();\n    }\n    \n    public int top() {\n        return s.peek();\n    }\n    \n    public int getMin() {\n        return min.peek();\n    }\n}\n\n/**\n * Your MinStack object will be instantiated and called as such:\n * MinStack obj = new MinStack();\n * obj.push(val);\n * obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.getMin();\n */",
    "title_slug": "min-stack",
    "problem_url": "https://leetcode.com/problems/min-stack/"
  },
  {
    "question_id": 937,
    "code": "public class Pair{\n    int ind;\n    int stock;\n\n    Pair(int ind,int stock){\n        this.ind=ind;\n        this.stock=stock;\n    }\n    int getVal(){\n        return stock;\n    }\n    int getInd(){\n        return ind;\n    }\n\n}\n\nclass StockSpanner {\n    int val;\n    int number;\n    Stack<Pair> s= new Stack<>();\n\n    public StockSpanner() {\n        val=1;\n        number=0;\n\n    }\n    public int next(int price) {\n        \n        while(!s.isEmpty() && s.peek().getVal()<=price){\n            s.pop();\n        }\n            \n        if(s.isEmpty()) val=number+1;\n        else val= number-s.peek().getInd();\n        s.push(new Pair(number,price));\n        number++;\n        return val;\n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = new StockSpanner();\n * int param_1 = obj.next(price);\n */",
    "title_slug": "online-stock-span",
    "problem_url": "https://leetcode.com/problems/online-stock-span/"
  },
  {
    "question_id": 496,
    "code": "class Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        int m=nums1.length; int n=nums2.length;\n        int[] ans = new int[m];\n        \n        HashMap<Integer,Integer> ht = new HashMap<>();\n\n        for(int i=0;i<m;i++){\n            ht.put(nums1[i],-1);\n        }\n        Stack<Integer> s = new Stack<>();\n\n        for(int i=n-1;i>=0;i--){\n            \n            while(!s.isEmpty() && s.peek()<=nums2[i]){\n                s.pop();\n            }\n\n            if(!s.isEmpty() && ht.containsKey(nums2[i])){\n                ht.put(nums2[i],s.peek());\n            } \n            s.push(nums2[i]);\n        }\n\n        for(int i=0;i<m;i++){\n            ans[i]=ht.get(nums1[i]);\n\n        }\n\n        return ans;\n    }\n}",
    "title_slug": "next-greater-element-i",
    "problem_url": "https://leetcode.com/problems/next-greater-element-i/"
  },
  {
    "question_id": 103,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n         List<List<Integer>> result = new ArrayList<>();\n        helper(result,0,root);\n        return result;\n    }\n    // for better understanding create a recursion tree. (kinda love the intuition)\n    void helper(List<List<Integer>> result, int level,TreeNode temp){\n        if(temp==null){\n            return;\n        }\n\n        // for first call of every level add the list\n        // this statement will be excuted first and is capabale to \n        // create list in the correct sequence thanks to recursion\n        if(level==result.size()){\n            result.add(new ArrayList<Integer>());\n        }\n\n        // add the value to result at the current level.\n        if(level%2==0){\n        result.get(level).add(temp.val);\n        }else{\n            result.get(level).addFirst(temp.val);\n        }\n        helper(result,level+1,temp.left);\n        helper(result,level+1,temp.right);\n    }\n}",
    "title_slug": "binary-tree-zigzag-level-order-traversal",
    "problem_url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/"
  },
  {
    "question_id": 3469,
    "code": "class Solution {\n\n    int helper(int red, int blue, int ans,int last){\n        if((last==1 && red<ans) || (last==0 && blue<ans))\n            return ans-1;\n\n        if(last==1)\n            return helper(red-ans,blue,ans+1,0);\n        else\n            return helper(red,blue-ans,ans+1,1);\n       \n    }\n    public int maxHeightOfTriangle(int red, int blue) {\n        // 0 red 1 blue\n        return Math.max(helper(red,blue,1,1),helper(red,blue,1,0));\n    }\n}",
    "title_slug": "maximum-height-of-a-triangle",
    "problem_url": "https://leetcode.com/problems/maximum-height-of-a-triangle/"
  },
  {
    "question_id": 3469,
    "code": "class Solution {\n\n    int helper(int red, int blue, int ans,int last){\n        System.out.println((last==0?\"red\":\"blue\")+\" \"+ans+\" \"+red+\" \"+blue);\n        if((last==1 && red<ans) || (last==0 && blue<ans))\n            return ans-1;\n\n        if(last==1)\n            return helper(red-ans,blue,ans+1,0);\n        else\n            return helper(red,blue-ans,ans+1,1);\n       \n    }\n    public int maxHeightOfTriangle(int red, int blue) {\n        // 0 red 1 blue\n        return Math.max(helper(red,blue,1,1),helper(red,blue,1,0));\n    }\n}",
    "title_slug": "maximum-height-of-a-triangle",
    "problem_url": "https://leetcode.com/problems/maximum-height-of-a-triangle/"
  },
  {
    "question_id": 1882,
    "code": "# Write your MySQL query statement below\nselect m.employee_id, m.name, count(e.employee_id) as reports_count,\n round(avg(e.age),0) as average_age\n from employees m join employees e on m.employee_id=e.reports_to \n group by m.employee_id order by m.employee_id",
    "title_slug": "the-number-of-employees-which-report-to-each-employee",
    "problem_url": "https://leetcode.com/problems/the-number-of-employees-which-report-to-each-employee/"
  },
  {
    "question_id": 56,
    "code": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n        ArrayList<int[]> ans = new ArrayList<>();\n        int n= intervals.length;\n        int prev1=intervals[0][0];\n        int prev2=intervals[0][1];\n        ans.add(new int[]{prev1,prev2});\n        for(int i=1;i<n;i++){\n            int index=ans.size()-1;\n            int[] arr=ans.get(index);\n            \n            if(intervals[i][0]>arr[1]){\n                ans.add(intervals[i]);\n            }else{\n                if(intervals[i][1]>arr[1])\n                    ans.set(index,new int[]{arr[0],intervals[i][1]});\n            }\n        } \n        \n        int[][] ansArr = new int[ans.size()][2];\n        for(int i=0;i<ans.size();i++)\n            ansArr[i] = ans.get(i);\n\n        return ansArr;\n    }\n}",
    "title_slug": "merge-intervals",
    "problem_url": "https://leetcode.com/problems/merge-intervals/"
  },
  {
    "question_id": 56,
    "code": "class Solution {\n    public int[][] merge(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n        ArrayList<int[]> ans = new ArrayList<>();\n\n        int n= intervals.length;\n        int prev1=intervals[0][0];\n        int prev2=intervals[0][1];\n        ans.add(new int[]{prev1,prev2});\n        for(int i=1;i<n;i++){\n            int index=ans.size()-1;\n            int[] arr=ans.get(index);\n            \n            if(intervals[i][0]>arr[1]){\n                ans.add(intervals[i]);\n            }else{\n                ans.set(index,new int[]{arr[0],Math.max(intervals[i][1],arr[1])});\n            }\n\n\n        } \n        \n        int[][] ansArr = new int[ans.size()][2];\n        for(int i=0;i<ans.size();i++)\n            ansArr[i] = ans.get(i);\n\n        return ansArr;\n    }\n}",
    "title_slug": "merge-intervals",
    "problem_url": "https://leetcode.com/problems/merge-intervals/"
  },
  {
    "question_id": 503,
    "code": "class Solution {\n    public int[] nextGreaterElements(int[] nums) {\n        \n        HashMap<Integer,Integer> map = new HashMap<>();\n        int n=nums.length;\n        for(int i=1;i<=n;i++){\n            map.put(i,nums[i-1]);\n        }\n\n        int[] ans= new int[n];\n        Arrays.fill(ans,-1);\n\n        for(int i=0;i<n;i++){\n\n            int j=(i+1)%n;\n            while(j!=i){\n                if(nums[j]>nums[i]){\n                    ans[i]=nums[j];\n                    break;\n                }\n\n                j= (j+1)%n;\n            }\n        }\n        return ans;\n    }\n}",
    "title_slug": "next-greater-element-ii",
    "problem_url": "https://leetcode.com/problems/next-greater-element-ii/"
  },
  {
    "question_id": 116,
    "code": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n    \n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\nclass Solution {\n    public Node connect(Node root) {\n        if(root==null || root.left==null) return root;\n        Queue<Node> q=  new LinkedList<>();\n\n        q.offer(root.left);\n        q.offer(root.right);\n        int count=0;\n        int pow=1;\n        Node pre=root.left;\n        while(!q.isEmpty()){\n           Node nextOne=q.poll();\n           if(nextOne.left!=null){\n            q.offer(nextOne.left);\n            q.offer(nextOne.right);\n           }\n           count++;\n           if(count==1) { \n            pre=nextOne;\n            continue;\n            }\n           pre.next=nextOne;\n           pre=nextOne;\n           \n           if(count==Math.pow(2,pow)){\n            count=0;\n            pow++;\n           }\n           \n        }\n\n        return root;\n    }\n}",
    "title_slug": "populating-next-right-pointers-in-each-node",
    "problem_url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/"
  },
  {
    "question_id": 116,
    "code": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n    public Node next;\n\n    public Node() {}\n    \n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, Node _left, Node _right, Node _next) {\n        val = _val;\n        left = _left;\n        right = _right;\n        next = _next;\n    }\n};\n*/\n\nclass Solution {\n    public Node connect(Node root) {\n        if(root==null || root.left==null) return root;\n        Queue<Node> q=  new LinkedList<>();\n\n        q.offer(root.left);\n        q.offer(root.right);\n        int count=0;\n        int pow=1;\n        Node pre=root.left;\n        while(!q.isEmpty()){\n           Node nextOne=q.poll();\n           if(nextOne.left!=null){\n            q.offer(nextOne.left);\n            q.offer(nextOne.right);\n           }\n           count++;\n           if(count==1) { \n            pre=nextOne;\n            continue;\n            }\n           pre.next=nextOne;\n           pre=nextOne;\n           \n           if(count==Math.pow(2,pow)){\n            count=0;\n            pow++;\n            // pre=q.isEmpty()?null:q.pop();\n           }\n           \n        }\n\n        return root;\n    }\n}",
    "title_slug": "populating-next-right-pointers-in-each-node",
    "problem_url": "https://leetcode.com/problems/populating-next-right-pointers-in-each-node/"
  },
  {
    "question_id": 540,
    "code": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int n=nums.length;\n        if(n==1) return nums[0];\n        int start=0, end=n-1;\n\n        while(start<=end){\n            int mid= (start + end)/2;\n\n            if(mid>0&& nums[mid-1]!=nums[mid] && mid<n-1 && nums[mid]!=nums[mid+1]){\n                return nums[mid];\n            }\n            else if((mid>0&& nums[mid-1]==nums[mid])){\n                if(mid%2==1){\n                    start=mid+1;\n                }else end=mid-1;\n            }else if(mid<n-1 && nums[mid]==nums[mid+1]){\n                if(mid%2==0){\n                    start=mid+1;\n                }else end=mid-1;\n            }else if(mid==0 && mid<n-1 ){\n                if(nums[mid+1]==nums[mid])\n                    start=mid+1;\n                else return nums[mid];\n            }else if(mid==n-1 && mid-1>0){\n                if(nums[mid-1]==nums[mid])\n                    end=mid-1;\n                else return nums[mid];\n            }\n\n            // System.out.println(start+\" \"+mid+\" \"+end);\n        }\n\n        return nums[start];\n    }\n}",
    "title_slug": "single-element-in-a-sorted-array",
    "problem_url": "https://leetcode.com/problems/single-element-in-a-sorted-array/"
  },
  {
    "question_id": 3476,
    "code": "class Solution {\n    public int minimumOperations(int[] nums) {\n        int op=0;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]%3==1 || nums[i]%3==2) op++;\n        }\n        return op;\n    }\n}",
    "title_slug": "find-minimum-operations-to-make-all-elements-divisible-by-three",
    "problem_url": "https://leetcode.com/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/"
  },
  {
    "question_id": 3475,
    "code": "class Solution {\n\n    public void flip(int i, int j, int[] nums){\n        for(int k=i;k<=j;k++){\n            nums[k]= nums[k]==0?1:0;\n        }\n    }\n    public int minOperations(int[] nums) {\n        \n        int op=0; int n=nums.length;\n        for(int i=0;i<n-2;i++){\n            if(nums[i]==0){\n                flip(i,i+2,nums);\n                op++;\n            }\n        }\n\n        for(int i:nums){\n            if(i==0) return -1;\n        }\n        return op;\n    }\n}",
    "title_slug": "minimum-operations-to-make-binary-array-elements-equal-to-one-i",
    "problem_url": "https://leetcode.com/problems/minimum-operations-to-make-binary-array-elements-equal-to-one-i/"
  },
  {
    "question_id": 60,
    "code": "class Solution {\n    int fact(int n){\n        if(n<1) return 1;\n        int f=1;\n        for(int i=2;i<=n;i++){\n            f*=i;\n        }\n        return f;\n    }\n\n\n    String helper(int d, int k,TreeSet<Integer> set){\n        if(d<1) return \"\";\n        int inc= fact(d-1);\n\n        int index= k/inc;\n\n        Iterator<Integer> iterator = set.iterator();\n        int currentIndex = 0;\n        int element = 0;\n\n        while (iterator.hasNext()) {\n            element = iterator.next();\n            if (currentIndex == index) {\n                break;\n            }\n            currentIndex++;\n        }\n\n        int nextK= k%inc;\n        set.remove(element);\n\n        return (\"\"+ element) + helper(d-1,nextK,set);\n\n    }\n    public String getPermutation(int n, int k) {\n        TreeSet<Integer> set = new TreeSet<Integer>();\n        for(int i=1;i<=n;i++)\n            set.add(i);\n\n        \n        return helper(n,k-1,set);\n    }\n}",
    "title_slug": "permutation-sequence",
    "problem_url": "https://leetcode.com/problems/permutation-sequence/"
  },
  {
    "question_id": 60,
    "code": "class Solution {\n    int fact(int n){\n        if(n<1) return 1;\n        int f=1;\n        for(int i=2;i<=n;i++){\n            f*=i;\n        }\n        return f;\n    }\n\n\n    String helper(int d, int k,TreeSet<Integer> set){\n        if(d<1) return \"\";\n        int inc= fact(d-1);\n\n        int index= k/inc;\n\n        Iterator<Integer> iterator = set.iterator();\n        int currentIndex = 0;\n        int element = 0;\n\n        while (iterator.hasNext()) {\n            element = iterator.next();\n            if (currentIndex == index) {\n                break;\n            }\n            currentIndex++;\n        }\n\n        int nextK= k%inc;\n        System.out.println(k+\" \"+inc+\" \"+index + \" \"+ element + \" \"+nextK);\n        set.remove(element);\n\n        return (\"\"+ element) + helper(d-1,nextK,set);\n\n    }\n    public String getPermutation(int n, int k) {\n        // return \"\";\n        TreeSet<Integer> set = new TreeSet<Integer>();\n        for(int i=1;i<=n;i++)\n            set.add(i);\n\n        \n        return helper(n,k-1,set);\n    }\n}",
    "title_slug": "permutation-sequence",
    "problem_url": "https://leetcode.com/problems/permutation-sequence/"
  },
  {
    "question_id": 540,
    "code": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int n=nums.length;\n        if(n==1) return nums[0];\n        int start=0, end=n-1;\n\n        while(start<=end){\n            int mid= (start + end)/2;\n\n            if(mid>0&& nums[mid-1]!=nums[mid] && mid<n-1 && nums[mid]!=nums[mid+1]){\n                return nums[mid];\n            }\n            else if((mid>0&& nums[mid-1]==nums[mid])){\n                if(mid%2==1){\n                    start=mid+1;\n                }else end=mid-1;\n            }else if(mid<n-1 && nums[mid]==nums[mid+1]){\n                if(mid%2==0){\n                    start=mid+1;\n                }else end=mid-1;\n            }else if(mid==0 && mid<n-1 ){\n                if(nums[mid+1]==nums[mid])\n                    start=mid+1;\n                else return nums[mid];\n            }else if(mid==n-1 && mid-1>0){\n                if(nums[mid-1]==nums[mid])\n                    end=mid-1;\n                else return nums[mid];\n            }\n\n            // System.out.println(start+\" \"+mid+\" \"+end);\n        }\n\n        return nums[start];\n    }\n}",
    "title_slug": "single-element-in-a-sorted-array",
    "problem_url": "https://leetcode.com/problems/single-element-in-a-sorted-array/"
  },
  {
    "question_id": 540,
    "code": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n        int n=nums.length;\n        int ans=nums[0];\n        for(int i=1;i<n;i++){\n            ans^=nums[i];\n        }\n\n        return ans;\n    }\n}",
    "title_slug": "single-element-in-a-sorted-array",
    "problem_url": "https://leetcode.com/problems/single-element-in-a-sorted-array/"
  },
  {
    "question_id": 74,
    "code": "class Solution {\n    public boolean searchMatrix(int[][] mat, int target) {\n        int m=mat.length;\n        int n=mat[0].length;\n        int start=0,end=m-1; \n     \n        while(start<=end){\n            int mid=(start+end)/2;\n            if(target<mat[mid][0])\n                end=mid-1;\n            else if(mid+1<m && target>=mat[mid+1][0])\n                start=mid+1;\n            else{\n\n                int row=mid;\n                start=0; end=n-1; \n                while(start<=end){\n                    mid=(start+end)/2;\n\n                    if(mat[row][mid]==target)\n                        return true;\n                    else if(mat[row][mid]>target)\n                        end=mid-1;\n                    else start=mid+1;\n                }\n                return false;\n            }\n        }\n        return false;\n    }\n}",
    "title_slug": "search-a-2d-matrix",
    "problem_url": "https://leetcode.com/problems/search-a-2d-matrix/"
  },
  {
    "question_id": 74,
    "code": "class Solution {\n    public boolean searchMatrix(int[][] mat, int target) {\n        int m=mat.length;\n        int n=mat[0].length;\n        int start=0,end=m-1; \n     \n        while(start<=end){\n            int mid=(start+end)/2;\n            if(target<mat[mid][0])\n                end=mid-1;\n            else if(mid+1<m && target>=mat[mid+1][0])\n                start=mid+1;\n            else{\n                for(int i=0;i<n;i++){\n                    if(mat[mid][i]==target)\n                        return true;\n                }\n                return false;\n            }\n                // System.out.println(start+\" \"+mid+ \" \"+end);\n        }\n        return false;\n    }\n}",
    "title_slug": "search-a-2d-matrix",
    "problem_url": "https://leetcode.com/problems/search-a-2d-matrix/"
  },
  {
    "question_id": 11,
    "code": "class Solution {\n    public int maxArea(int[] height) {\n        int n=height.length;\n        int start=0;\n        int end=n-1;\n        int maxarea=0;\n        int i=1; int j=1;\n        while(start<end){\n            int h=Math.min(height[start],height[end]);\n            int area= (end-start)*h;\n            maxarea=Math.max(area,maxarea);\n            while(start<end && height[start]<=h)\n                start++;\n            while(start<end && height[end]<=h)\n             end--;\n        }\n\n        return maxarea;\n    }\n}",
    "title_slug": "container-with-most-water",
    "problem_url": "https://leetcode.com/problems/container-with-most-water/"
  },
  {
    "question_id": 11,
    "code": "class Solution {\n    public int maxArea(int[] height) {\n        int n=height.length;\n        int start=0;\n        int end=n-1;\n        int maxarea=0;\n        int i=1; int j=1;\n        while(start<end){\n            int area= (end-start)*Math.min(height[start],height[end]);\n            maxarea=Math.max(area,maxarea);\n            if(height[start]<height[end]){\n                start++;\n            }else end--;\n        }\n\n        return maxarea;\n    }\n}",
    "title_slug": "container-with-most-water",
    "problem_url": "https://leetcode.com/problems/container-with-most-water/"
  },
  {
    "question_id": 215,
    "code": "class Solution {\n    public int findKthLargest(int[] nums, int k) {\n        \n        PriorityQueue<Integer> pQueue = new PriorityQueue<Integer>();\n\n        for(int x: nums){\n            pQueue.offer(x);\n            if(pQueue.size()>k){\n                pQueue.poll();\n            }\n        }\n\n        return pQueue.poll();\n\n    }\n}",
    "title_slug": "kth-largest-element-in-an-array",
    "problem_url": "https://leetcode.com/problems/kth-largest-element-in-an-array/"
  },
  {
    "question_id": 22,
    "code": "class Solution {\n    void helper(List<String> ans, int open,int close,StringBuilder bal){\n        if(close==0){\n            ans.add(bal.toString());\n            return;\n        }\n\n        if(open<close){\n            helper(ans,open,close-1,bal.append(\")\"));\n            bal.setLength(bal.length() - 1);\n        }\n        if(open>0){\n            helper(ans,open-1,close,bal.append(\"(\"));\n            bal.setLength(bal.length() - 1);\n        }\n\n\n    }\n    public List<String> generateParenthesis(int n) {\n        List<String> ans= new ArrayList<>();\n        helper(ans,n,n,new StringBuilder(\"\"));\n        return ans;\n    }\n}",
    "title_slug": "generate-parentheses",
    "problem_url": "https://leetcode.com/problems/generate-parentheses/"
  },
  {
    "question_id": 22,
    "code": "class Solution {\n    void helper(List<String> ans, int open,int close,String bal){\n        if(close==0){\n            ans.add(bal);\n            return;\n        }\n\n        if(open<close){\n            helper(ans,open,close-1,bal+\")\");\n        }\n        if(open>0)\n            helper(ans,open-1,close,bal+\"(\");\n\n\n    }\n    public List<String> generateParenthesis(int n) {\n        List<String> ans= new ArrayList<>();\n        helper(ans,n,n,\"\");\n        return ans;\n    }\n}",
    "title_slug": "generate-parentheses",
    "problem_url": "https://leetcode.com/problems/generate-parentheses/"
  },
  {
    "question_id": 800,
    "code": "class Solution {\n    void helper(List<String> ans,String out, String in, int i){\n        if(i==in.length()){\n            ans.add(out);\n            return;\n        }\n\n\n        if(in.charAt(i)>='0' && in.charAt(i)<='9'){\n            helper(ans,out+\"\"+in.charAt(i),in,i+1); // not take in case of digit\n        }\n        else{\n            //not take\n               char ch=in.charAt(i);\n                helper(ans,out+\"\"+ch,in,i+1);\n\n            // take\n                if(in.charAt(i)>='a' && in.charAt(i)<='z'){\n                    ch-=32;\n                    helper(ans,out+\"\"+ch,in,i+1);\n                }\n                if(in.charAt(i)>='A' && in.charAt(i)<='Z'){\n                    ch+=32;\n                    helper(ans,out+\"\"+ch,in,i+1);}\n        }\n        \n    }\n    public List<String> letterCasePermutation(String s) {\n        List<String> ans= new ArrayList<>();\n        helper(ans,\"\",s,0);\n        return ans;\n    }\n}",
    "title_slug": "letter-case-permutation",
    "problem_url": "https://leetcode.com/problems/letter-case-permutation/"
  },
  {
    "question_id": 3422,
    "code": "class Solution {\n    public int valueAfterKSeconds(int n, int k) {\n        int MOD = 1000000007;\n        int[] cur=new int[n];\n        Arrays.fill(cur,1);\n        for(int j=0;j<k;j++){\n            cur[0]=1;\n            for(int i=1;i<n;i++)\n                cur[i]=(cur[i-1]+cur[i])%MOD;\n        }\n        return cur[n-1]%MOD;\n        \n    }\n}",
    "title_slug": "find-the-n-th-value-after-k-seconds",
    "problem_url": "https://leetcode.com/problems/find-the-n-th-value-after-k-seconds/"
  },
  {
    "question_id": 3422,
    "code": "class Solution {\n    public int valueAfterKSeconds(int n, int k) {\n        int MOD = 1000000007;\n        int[] cur=new int[n];\n        Arrays.fill(cur,1);\n        for(int j=0;j<k;j++){\n            cur[0]=1;\n            for(int i=1;i<n;i++)\n                cur[i]=(cur[i-1]+cur[i])%MOD;\n        }\n        return cur[n-1]%MOD;\n        \n    }\n}",
    "title_slug": "find-the-n-th-value-after-k-seconds",
    "problem_url": "https://leetcode.com/problems/find-the-n-th-value-after-k-seconds/"
  },
  {
    "question_id": 3422,
    "code": "class Solution {\n    public int valueAfterKSeconds(int n, int k) {\n        int MOD = 1000000007;\n        int[] prev=new int[n];\n        Arrays.fill(prev,1);\n        for(int j=0;j<k;j++){\n            int[] cur=new int[n];\n            cur[0]=1;\n            for(int i=1;i<n;i++)\n                cur[i]=(cur[i-1]+prev[i])%MOD;\n            prev=cur;\n        }\n        return prev[n-1]%MOD;\n        \n    }\n}",
    "title_slug": "find-the-n-th-value-after-k-seconds",
    "problem_url": "https://leetcode.com/problems/find-the-n-th-value-after-k-seconds/"
  },
  {
    "question_id": 3450,
    "code": "class Solution {\n    public int numberOfChild(int n, int k) {\n        int i=0;\n        boolean pass=true;\n        int sec=1;\n        while(sec<=k){\n\n            \n            if(pass){\n                i++;\n                if(i==n-1) pass=false;\n            }else{\n                i--;\n                if(i==0)\n                    pass=true;\n            }\n            sec++;\n            // System.out.println(\"i: \"+i);\n            // System.out.println(\"k: \"+k);\n            \n        }\n        \n        return i;\n    }\n}",
    "title_slug": "find-the-child-who-has-the-ball-after-k-seconds",
    "problem_url": "https://leetcode.com/problems/find-the-child-who-has-the-ball-after-k-seconds/"
  },
  {
    "question_id": 3413,
    "code": "class Solution {\n    public int findWinningPlayer(int[] skills, int k) {\n        Deque<Integer> dq = new ArrayDeque<>();\n        int n = skills.length;\n        int row = 0;\n        int index = -1;\n        int prev = -1;\n\n        for (int i = 0; i < n; i++) {\n            dq.offer(i);\n        }\n        \n        // k%=n;\n        // System.out.println(k);\n        int j=0;\n        while (j <n) {\n            int first = dq.poll();\n            int second = dq.poll();\n\n            if (skills[first] < skills[second]) {\n                dq.offer(first);  \n                dq.addFirst(second);  \n                index = second;\n            } else {\n                dq.offer(second);  \n                dq.addFirst(first);  \n                index = first;\n            }\n\n            // System.out.println(index + \" \" + prev);\n\n            if (prev == -1 || index == prev)\n                row++;\n            else\n                row = 1;\n\n            prev = index;\n            j++;\n            \n            if(row==k)\n                break;\n        }\n\n        return dq.peek();\n    }\n}\n",
    "title_slug": "find-the-first-player-to-win-k-games-in-a-row",
    "problem_url": "https://leetcode.com/problems/find-the-first-player-to-win-k-games-in-a-row/"
  },
  {
    "question_id": 3447,
    "code": "class Solution {\n    public String clearDigits(String s) {\n    StringBuilder sb = new StringBuilder(s);\n    Stack<Integer> ind = new Stack<>();\n    int n = sb.length();\n\n    for (int i = 0; i < n; i++) {\n        if (sb.charAt(i) >= 'a' && sb.charAt(i) <= 'z') {\n            ind.push(i);\n        } else {\n            sb.deleteCharAt(i);\n            i--; \n            n--;\n            // System.out.println(ind.peek()+ \" \"+i+\" \"+n);\n            if(!ind.isEmpty()) {\n                // System.out.println(ind.peek()+ \" \"+i);\n                sb.deleteCharAt(ind.pop());\n                n--;\n                i--; \n            }\n        }\n        \n    }\n\n    return sb.toString();\n    }\n}",
    "title_slug": "clear-digits",
    "problem_url": "https://leetcode.com/problems/clear-digits/"
  },
  {
    "question_id": 347,
    "code": "class Solution {\n    class Pair {\n    int first;\n    int second;\n\n    Pair(int first, int second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    public int getFirst() {\n        return first;\n    }\n\n    public int getSecond() {\n        return second;\n    }\n\n    @Override\n    public String toString() {\n        return \"(\" + first + \", \" + second + \")\";\n    }\n    }\n\n    public int[] topKFrequent(int[] nums, int k) {\n        HashMap<Integer, Integer> map= new HashMap<>();\n\n        for(int x:nums){\n\n            if(map.containsKey(x)){\n                map.put(x,map.get(x)+1);\n            }else\n                map.put(x,1);\n        }\n\n        PriorityQueue<Pair> minHeap = new PriorityQueue<>(Comparator.comparingInt(Pair::getFirst));\n\n        for( Map.Entry<Integer,Integer> entry : map.entrySet()){\n            \n            minHeap.offer(new Pair(entry.getValue(),entry.getKey()));\n\n            if(minHeap.size()>k){\n                minHeap.poll();\n            }\n        }\n\n        int[] ans= new int[k];\n        int i=0;\n        for(Pair p: minHeap){\n            ans[i++]=p.second;\n        }\n        return ans;\n    }\n}",
    "title_slug": "top-k-frequent-elements",
    "problem_url": "https://leetcode.com/problems/top-k-frequent-elements/"
  },
  {
    "question_id": 3430,
    "code": "class Solution {\n    public int countDays(int days, int[][] meets) {\n        Arrays.sort(meets,(a,b)->a[0]-b[0]);\n        int n=meets.length;\n        int count=0;\n        int j=0; int i=1;\n        while(i<=days){\n            // System.out.println(i);\n            \n            if(j<meets.length && i>=meets[j][0]){\n                    if(i<=meets[j][1])\n                     i=meets[j][1]+1;\n                j++;\n                continue;\n            }\n            i++;\n            count++;\n        }\n        return count;\n    }\n}",
    "title_slug": "count-days-without-meetings",
    "problem_url": "https://leetcode.com/problems/count-days-without-meetings/"
  },
  {
    "question_id": 3426,
    "code": "class Solution {\n    public int minimumChairs(String s) {\n        \n        int n=s.length();\n        int max=0;\n        int count=0;\n        \n        for(int i=0;i<n;i++){\n            if(s.charAt(i)=='E')\n                count++;\n            else\n                count--;\n\n            max=Math.max(count,max);\n            \n        }\n        return max;\n\n    }\n}",
    "title_slug": "minimum-number-of-chairs-in-a-waiting-room",
    "problem_url": "https://leetcode.com/problems/minimum-number-of-chairs-in-a-waiting-room/"
  },
  {
    "question_id": 54,
    "code": "class Solution {\n    public List<Integer> spiralOrder(int[][] mat) {\n        \n        List<Integer> ans = new ArrayList<>();\n\n        int row=mat[0].length;\n        int col=mat.length;\n\n        int top,bottom, down, up;\n\n        top=0;\n        down=row-1;\n        bottom=col-1;\n        up=0;\n        while(top<=bottom && up<=down){\n\n            for(int i=up;i<=down;i++){\n                ans.add(mat[top][i]);\n                System.out.println(mat[top][i] +\"top \"+ top +\" \"+i);\n            }\n            top++;\n            System.out.println(\"new top \"+top);\n            for(int i=top;i<=bottom;i++){\n                ans.add(mat[i][down]);\n                System.out.println(mat[i][down]+\"down \"+down+\" \"+i);\n            }\n            down--;\n            System.out.println(\"new down \"+down);\n            if(bottom<top)\n                break;\n            for(int i=down;i>=up;i--){\n                ans.add(mat[bottom][i]);\n                System.out.println(mat[bottom][i]+\"bottom \"+bottom+\" \"+i);\n            }\n            bottom--;\n            System.out.println(\"new bottom \"+bottom);\n            if(up>down)\n                break;\n            for(int i=bottom;i>=top;i--){\n                ans.add(mat[i][up]);\n                System.out.println(mat[i][up]+\"up \"+up+\" \"+i);\n            }\n            up++;\n            System.out.println(\"new up \"+up);\n        } \n        \n        return ans;\n    }\n}",
    "title_slug": "spiral-matrix",
    "problem_url": "https://leetcode.com/problems/spiral-matrix/"
  },
  {
    "question_id": 908,
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode middleNode(ListNode head) {\n        \n        if(head.next==null)\n            return head;\n\n        ListNode slow,fast;\n        slow=head;\n        fast=head;\n\n        while(fast!=null && fast.next!=null){\n            slow=slow.next;\n            fast=fast.next.next;\n        }\n\n        return slow;\n    }\n}",
    "title_slug": "middle-of-the-linked-list",
    "problem_url": "https://leetcode.com/problems/middle-of-the-linked-list/"
  },
  {
    "question_id": 15,
    "code": "class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        int n= nums.length;\n        List<List<Integer>> ans = new ArrayList<>();\n        for(int i=0;i<n-2;i++){\n\n            if(i!=0 && nums[i]==nums[i-1]) continue;\n            int start=i+1;\n            int end=n-1;\n            int first=nums[i];\n            while(start<end){\n                int total=first+nums[start]+nums[end];\n\n                if(total==0){\n                    ans.add(new ArrayList<>(\n                        Arrays.asList(first,nums[start],nums[end])\n                        ));\n                    start++;\n                    end--;\n                    while(start<end && nums[start-1]==nums[start]){\n                    start++;\n                    }\n                    while(start<end && nums[end]==nums[end+1]){\n                        end--;\n                    }\n\n                }else if(total<0){\n                    start++;\n                }else {\n                    end--;\n                }\n            }\n        }\n\n        return ans;\n    }\n}",
    "title_slug": "3sum",
    "problem_url": "https://leetcode.com/problems/3sum/"
  },
  {
    "question_id": 31,
    "code": "class Solution {\n\n    void swap(int[] nums,int i, int j){\n        int temp=nums[i];\n        nums[i]=nums[j];\n        nums[j]=temp;\n    }\n    void reverse(int[] nums,int i, int j){\n        while(i<j){\n            swap(nums,i,j);\n            i++; j--;\n        }\n    }\n   \n    public void nextPermutation(int[] nums) {\n        int n=nums.length;\n        int index=-1;\n        for(int i=n-1;i>0;i--){\n            if(nums[i-1]<nums[i]){\n                    index=i-1;\n                break;\n\n            }\n        }\n        \n        if(index==-1){\n            reverse(nums,0,n-1);\n            return;\n        }\n        int minIndex=-1;\n\n        for(int i=n-1;i>index;i--){\n            if(nums[index]<nums[i]){\n                minIndex=i; break;\n            }\n        }\n        \n        swap(nums,index,minIndex);\n        reverse(nums,index+1,n-1);\n\n    }\n}",
    "title_slug": "next-permutation",
    "problem_url": "https://leetcode.com/problems/next-permutation/"
  },
  {
    "question_id": 31,
    "code": "class Solution {\n\n    void swap(int[] nums,int i, int j){\n        int temp=nums[i];\n        nums[i]=nums[j];\n        nums[j]=temp;\n    }\n    void reverse(int[] nums,int i, int j){\n        while(i<j){\n            swap(nums,i,j);\n            i++; j--;\n        }\n    }\n   \n    public void nextPermutation(int[] nums) {\n        int n=nums.length;\n        int index=-1;\n        for(int i=n-1;i>0;i--){\n            if(nums[i-1]<nums[i]){\n                    index=i-1;\n                break;\n\n            }\n        }\n        \n        if(index==-1){\n            reverse(nums,0,n-1);\n            return;\n        }\n        int minIndex=-1;\n\n        for(int i=n-1;i>index;i--){\n            if(nums[index]<nums[i]){\n                minIndex=i; break;\n            }\n        }\n        if(minIndex!=-1)\n            swap(nums,index,minIndex);\n        reverse(nums,index+1,n-1);\n\n    }\n}",
    "title_slug": "next-permutation",
    "problem_url": "https://leetcode.com/problems/next-permutation/"
  },
  {
    "question_id": 31,
    "code": "class Solution {\n   \n    public void nextPermutation(int[] nums) {\n        int n=nums.length;\n        int index=-1;\n        for(int i=n-1;i>0;i--){\n            if(nums[i-1]<nums[i]){\n                    index=i-1;\n                break;\n\n            }\n        }\n        \n        if(index==-1){\n            Arrays.sort(nums);\n            return;\n        }\n        \n        int minIndex=index+1;\n        for(int i=n-1;i>index;i--){\n            if(nums[index]<nums[i] && nums[minIndex]>nums[i]){\n                minIndex=i;\n            }\n        }\n        int temp=nums[index];\n        nums[index]=nums[minIndex];\n        nums[minIndex]=temp;\n        Arrays.sort(nums,index+1,n);\n\n    }\n}",
    "title_slug": "next-permutation",
    "problem_url": "https://leetcode.com/problems/next-permutation/"
  },
  {
    "question_id": 3451,
    "code": "class Solution {\n    public String compressedString(String word) {\n        String comp=\"\";\n        int n=word.length();\n        char prev= word.charAt(0);\n        int t=1; // times\n\n        \n        for(int i=1;i<n;i++){\n            char ch =word.charAt(i);\n            if(ch==prev && t<9)\n                t++;\n            else{\n                comp+= \"\"+t+prev;\n                t=1;\n            }\n            prev=ch;\n        }\n\n        comp+=\"\"+t+prev;\n        return comp;\n    }\n}",
    "title_slug": "string-compression-iii",
    "problem_url": "https://leetcode.com/problems/string-compression-iii/"
  },
  {
    "question_id": 3446,
    "code": "class Solution {\n    public int numberOfPairs(int[] nums1, int[] nums2, int k) {\n        int n=nums1.length;\n        int m=nums2.length;\n\n        int gp=0;\n        for(int i=0;i<n;i++){\n\n            for(int j=0;j<m;j++){\n                if(nums1[i]%(nums2[j]*k)==0) gp++;\n            }\n        }\n\n        return gp;\n    }\n}",
    "title_slug": "find-the-number-of-good-pairs-i",
    "problem_url": "https://leetcode.com/problems/find-the-number-of-good-pairs-i/"
  },
  {
    "question_id": 3434,
    "code": "class Solution {\n    public int[] queryResults(int limit, int[][] que) {\n\n        // HashMap<Integer,Integer> ht = new HashMap<>();\n        // HashMap<Integer,Integer> color = new HashMap<>();\n        // int n= que.length;\n        // int[] result = new int[n];\n        // for(int i=0;i<n;i++){\n        //     if(ht.containsKey(que[i][0])){\n\n        //         if(color.getOrDefault(que[i][1], 0)==1)\n        //             color.remove(que[i][1]);\n        //         else\n        //             color.put(que[i][1],color.get(que[i][1]-1));\n\n        //         System.out.println(\"removed \"+ht.get(que[i][0]));\n        //     }\n        //     color.put(que[i][1],color.getOrDefault(que[i][1], 0)+1);\n        //     ht.put(que[i][0],que[i][1]);\n        //     System.out.println(que[i][1] +\" \"+ color.size());\n        //     result[i]=color.size();\n        // }\n\n        // return result;\n\n        HashMap<Integer, Integer> ht = new HashMap<>();\n        HashMap<Integer, Integer> color = new HashMap<>();\n        int n = que.length;\n        int[] result = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            int key = que[i][0];\n            int value = que[i][1];\n\n            if (ht.containsKey(key)) {\n                int oldColor = ht.get(key);\n                int oldColorCount = color.get(oldColor);\n\n                if (oldColorCount == 1) {\n                    color.remove(oldColor);\n                } else {\n                    color.put(oldColor, oldColorCount - 1);\n                }\n\n                // System.out.println(\"removed \" + oldColor);\n            }\n\n            // Update the color map for the new value\n            color.put(value, color.getOrDefault(value, 0) + 1);\n            ht.put(key, value);\n\n            // System.out.println(value + \" \" + color.size());\n            result[i] = color.size();\n        }\n\n        return result;\n    }\n}",
    "title_slug": "find-the-number-of-distinct-colors-among-the-balls",
    "problem_url": "https://leetcode.com/problems/find-the-number-of-distinct-colors-among-the-balls/"
  },
  {
    "question_id": 3428,
    "code": "class Solution {\n    public int duplicateNumbersXOR(int[] nums) {\n        HashMap<Integer,Integer> ht = new HashMap<>();\n        int n=nums.length;\n        for(int i=0;i<n;i++){\n            if(ht.containsKey(nums[i]))\n                ht.put(nums[i],ht.get(nums[i])+1);\n            else\n                ht.put(nums[i],1);\n        }\n\n        int ans=0; int i=0;\n        for(int x : ht.keySet()){\n            // int a;\n            if(ht.get(x)==2 && i==0){\n                ans=x;\n                i++;\n                System.out.println(\"i1 \"+ x);\n            }else if(ht.get(x)==2){\n                ans^=x;\n                System.out.println(\"i \"+ x);\n            }\n        }\n\n        return ans;\n    }\n}",
    "title_slug": "find-the-xor-of-numbers-which-appear-twice",
    "problem_url": "https://leetcode.com/problems/find-the-xor-of-numbers-which-appear-twice/"
  },
  {
    "question_id": 3420,
    "code": "class Solution {\n    public int[] occurrencesOfElement(int[] nums, int[] que, int x) {\n        int n=nums.length;\n        int j=1;\n        int[] occ = new int[n+1];\n        Arrays.fill(occ,-1);\n        for(int i=0;i<n;i++){\n            if(nums[i]==x){\n                occ[j]=i;\n                j++;\n            }\n        }\n        System.out.println(Arrays.toString(occ));\n        int m=que.length;\n        int[] out = new int[m];\n        for(int q=0;q<m;q++){\n            if(que[q]>n || occ[que[q]]==-1){\n                out[q]=-1;\n            }else{\n                out[q]=occ[que[q]];\n            }\n        }\n        System.out.println(Arrays.toString(out));\n\n        return out;\n    }\n}",
    "title_slug": "find-occurrences-of-an-element-in-an-array",
    "problem_url": "https://leetcode.com/problems/find-occurrences-of-an-element-in-an-array/"
  },
  {
    "question_id": 1966,
    "code": "class Solution {\n    public int maxFrequency(int[] nums, int k) {\n        int n=nums.length;\n        if(n<=1) return n;\n        Arrays.sort(nums);\n        // System.out.println(Arrays.toString(nums));\n        int maxfreq=1;\n        \n        for(int i=n-1;i>0;i--){\n            int inc=k; int freq=1;\n            if(i<maxfreq) break;\n            if (i<n-1 &&nums[i + 1] == nums[i])\n                continue;\n            for(int j=i-1;j>=0;j--){\n                int dif=nums[i]-nums[j];\n                if(dif>inc){\n                    break;\n                }\n                inc-=dif;\n                freq++;\n            }\n            maxfreq=Math.max(freq,maxfreq);\n        }\n\n        return maxfreq;\n    }\n}",
    "title_slug": "frequency-of-the-most-frequent-element",
    "problem_url": "https://leetcode.com/problems/frequency-of-the-most-frequent-element/"
  },
  {
    "question_id": 125,
    "code": "class Solution {\n    public boolean isPalindrome(String s) {\n    \n       int i = 0, j = s.length()-1;\n        while(i < j){\n            char ch1 = s.charAt(i), ch2 = s.charAt(j);\n            if(ch1 >= 'A' && ch1 <= 'Z') ch1 = (char)(ch1+32);\n            if(ch2 >= 'A' && ch2 <= 'Z') ch2 = (char)(ch2+32);\n            boolean c1 = (ch1 >= 'a' && ch1 <= 'z') || (ch1 >= '0' && ch1 <= '9');\n            boolean c2 = (ch2 >= 'a' && ch2 <= 'z') || (ch2 >= '0' && ch2 <= '9');\n            if(!c1){\n                i++;\n                continue;\n            }\n            if(!c2){\n                j--;\n                continue;\n            }\n            if(ch1 != ch2) return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n\n}",
    "title_slug": "valid-palindrome",
    "problem_url": "https://leetcode.com/problems/valid-palindrome/"
  },
  {
    "question_id": 125,
    "code": "\n    class Solution {\n\n    boolean helper(String s,int i,int j){\n        if(i>=j)\n        {\n            return true;\n        }\n\n        if(!Character.isLetterOrDigit(s.charAt(i))){\n            return helper(s,i+1,j);}\n        else if(!Character.isLetterOrDigit(s.charAt(j))){\n            return helper(s,i,j-1);}\n        else if(Character.toLowerCase(s.charAt(i))==Character.toLowerCase(s.charAt(j))){\n            return helper(s,i+1,j-1);}\n        \n        return false;\n\n\n    }\n    public boolean isPalindrome(String s) {\n    \n       return helper(s,0,s.length()-1);\n    }\n\n}",
    "title_slug": "valid-palindrome",
    "problem_url": "https://leetcode.com/problems/valid-palindrome/"
  },
  {
    "question_id": 125,
    "code": "\n    class Solution {\n\n    boolean helper(String s,int i,int j){\n        if(i>=j)\n        {\n            return true;\n        }\n\n        if(!Character.isLetterOrDigit(s.charAt(i))){\n            return helper(s,i+1,j);}\n        else if(!Character.isLetterOrDigit(s.charAt(j))){\n            return helper(s,i,j-1);}\n        else if(s.charAt(i)==s.charAt(j)){\n            return helper(s,i+1,j-1);}\n        \n        return false;\n\n\n    }\n    public boolean isPalindrome(String s) {\n    \n       return helper(s.toLowerCase(),0,s.length()-1);\n    }\n\n}",
    "title_slug": "valid-palindrome",
    "problem_url": "https://leetcode.com/problems/valid-palindrome/"
  },
  {
    "question_id": 344,
    "code": "class Solution {\n    void helper(char[] s,int i, int j){\n        if(i>=j){\n            return;\n        }\n\n        char temp = s[i];\n        s[i]=s[j];\n        s[j]=temp;\n\n        helper(s,i+1,j-1);\n    }\n    public void reverseString(char[] s) {\n        helper(s,0,s.length-1);\n    }\n}",
    "title_slug": "reverse-string",
    "problem_url": "https://leetcode.com/problems/reverse-string/"
  },
  {
    "question_id": 792,
    "code": "class Solution {\n\n    int helper(int[] nums,int target, int high, int low){\n        int mid= (high+low)/2;\n        if(nums[mid]==target){\n            return mid;\n        }\n        if(high<=low){\n            return -1;\n        }\n\n        if(target>nums[mid])\n            return helper(nums,target,high,mid+1);\n        \n        return helper(nums,target,mid,low);\n\n    }\n    public int search(int[] nums, int target) {\n        return helper(nums,target,nums.length-1,0);\n    }\n}",
    "title_slug": "binary-search",
    "problem_url": "https://leetcode.com/problems/binary-search/"
  },
  {
    "question_id": 1444,
    "code": "class Solution {\n    public int numberOfSteps(int num) {\n       if(num==0){\n            return 0;\n       }\n\n       if(num%2==0)\n        return 1 + numberOfSteps(num/2);\n    \n        return 1 + numberOfSteps(num-1);\n    }\n}",
    "title_slug": "number-of-steps-to-reduce-a-number-to-zero",
    "problem_url": "https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/"
  },
  {
    "question_id": 1444,
    "code": "class Solution {\n    public int numberOfSteps(int num) {\n        int steps=0;\n        while(num>0){\n            if(num%2==0){\n                num/=2;\n            }else{\n                num--;\n            }\n\n            steps++;\n        }\n\n        return steps;\n    }\n}",
    "title_slug": "number-of-steps-to-reduce-a-number-to-zero",
    "problem_url": "https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/"
  },
  {
    "question_id": 131,
    "code": "class Solution {\n    boolean ispalindrome(String str,int i,int j){\n        while(i<=j){\n            if(str.charAt(i)!=str.charAt(j))\n                return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n    void helper(List<List<String>> ans,List<String> inner,int start, String s ){\n\n        if(start==s.length()){\n            ans.add(new ArrayList<>(inner));\n        }\n\n        for(int i=start;i<s.length();i++){\n            String substr=s.substring(start,i+1);\n            if(ispalindrome(s,start,i)){\n                inner.add(substr);\n                helper(ans,inner,i+1,s);\n                inner.remove(inner.size()-1);\n            }\n        }\n    }\n\n    public List<List<String>> partition(String s) {\n        \n        List<List<String>> ans= new ArrayList<>();\n        helper(ans,new ArrayList<>(),0,s);\n        return ans;\n    }\n}",
    "title_slug": "palindrome-partitioning",
    "problem_url": "https://leetcode.com/problems/palindrome-partitioning/"
  },
  {
    "question_id": 131,
    "code": "class Solution {\n    boolean ispalindrome(String str,int i,int j){\n        while(i<=j){\n            if(str.charAt(i)!=str.charAt(j))\n                return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n    void helper(List<List<String>> ans,List<String> inner,int start, String s ){\n\n        if(start==s.length()){\n            ans.add(new ArrayList<>(inner));\n        }\n\n        for(int i=start;i<s.length();i++){\n            String substr=s.substring(start,i+1);\n            if(ispalindrome(s,start,i)){\n                inner.add(substr);\n                helper(ans,inner,i+1,s);\n                inner.remove(inner.size()-1);\n            }\n        }\n    }\n\n    public List<List<String>> partition(String s) {\n        \n        List<List<String>> ans= new ArrayList<>();\n        helper(ans,new ArrayList<>(),0,s);\n        return ans;\n    }\n}",
    "title_slug": "palindrome-partitioning",
    "problem_url": "https://leetcode.com/problems/palindrome-partitioning/"
  },
  {
    "question_id": 206,
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        if(head==null || head.next== null) return head;\n        ListNode temp=head;\n        ListNode cur=head;\n        ListNode left=null;\n        while(cur!=null){\n            temp=cur;\n            cur=cur.next;\n            temp.next=left;\n            left=temp;\n        }\n\n        head=temp;\n        return head;\n\n    }\n}",
    "title_slug": "reverse-linked-list",
    "problem_url": "https://leetcode.com/problems/reverse-linked-list/"
  },
  {
    "question_id": 40,
    "code": "class Solution {\n    void helper1(List<List<Integer>> ans, List<Integer> inner, int[] nums, int target, int index) {\n        if (index == nums.length) {\n            if(target==0)\n                ans.add(new ArrayList<>(inner));\n                \n            return;\n        }\n\n        if(nums[index]<=target){\n            // Pick the current element\n            inner.add(nums[index]);\n            helper1(ans, inner, nums, target- nums[index],index + 1);\n            inner.remove(inner.size() - 1); // Backtrack\n        }\n        // Not pick the current *element\n        // Skip all the duplicates\n        while (index + 1 < nums.length && nums[index] == nums[index + 1]) {\n            index++;\n        }\n        helper1(ans, inner, nums, target,index + 1);\n    }\n    \n    void helper(List<List<Integer>> ans, List<Integer> inner, int[] nums, int target, int start) {\n        if(target==0)\n            ans.add(new ArrayList<>(inner));\n        \n        for (int i = start; i < nums.length; i++) {\n            if (i != start && nums[i - 1] == nums[i]) continue;\n            if(nums[i]>target) break;\n            \n            inner.add(nums[i]);\n            helper(ans, inner, nums, target-nums[i],i + 1);\n            inner.remove(inner.size() - 1);\n        }\n    }\n\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n         List<List<Integer>> ans = new ArrayList<>();\n        helper1(ans,new ArrayList<>(),candidates,target,0);\n        return ans;\n    }\n} ",
    "title_slug": "combination-sum-ii",
    "problem_url": "https://leetcode.com/problems/combination-sum-ii/"
  },
  {
    "question_id": 40,
    "code": "class Solution {\n    void helper1(List<List<Integer>> ans, List<Integer> inner, int[] nums, int target, int index) {\n        if (index == nums.length) {\n            if(target==0)\n                ans.add(new ArrayList<>(inner));\n                \n            return;\n        }\n\n        // Pick the current element\n        inner.add(nums[index]);\n        helper1(ans, inner, nums, target- nums[index],index + 1);\n        inner.remove(inner.size() - 1); // Backtrack\n\n        // Not pick the current *element\n        // Skip all the duplicates\n        while (index + 1 < nums.length && nums[index] == nums[index + 1]) {\n            index++;\n        }\n        helper1(ans, inner, nums, target,index + 1);\n    }\n    \n    void helper(List<List<Integer>> ans, List<Integer> inner, int[] nums, int target, int start) {\n        if(target==0)\n            ans.add(new ArrayList<>(inner));\n        \n        for (int i = start; i < nums.length; i++) {\n            if (i != start && nums[i - 1] == nums[i]) continue;\n            if(nums[i]>target) break;\n            \n            inner.add(nums[i]);\n            helper(ans, inner, nums, target-nums[i],i + 1);\n            inner.remove(inner.size() - 1);\n        }\n    }\n\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        Arrays.sort(candidates);\n         List<List<Integer>> ans = new ArrayList<>();\n        helper(ans,new ArrayList<>(),candidates,target,0);\n        return ans;\n    }\n} ",
    "title_slug": "combination-sum-ii",
    "problem_url": "https://leetcode.com/problems/combination-sum-ii/"
  },
  {
    "question_id": 90,
    "code": "class Solution {\n    void helper1(List<List<Integer>> ans, List<Integer> inner, int[] nums, int index) {\n        // Base case: if we have considered all elements\n        if (index == nums.length) {\n            ans.add(new ArrayList<>(inner));\n            return;\n        }\n        \n        // Pick the current element\n        inner.add(nums[index]);\n        helper1(ans, inner, nums, index + 1);\n        inner.remove(inner.size() - 1); // Backtrack\n        \n        // Not pick the current element\n        // Skip all the duplicates\n        while (index + 1 < nums.length && nums[index] == nums[index + 1]) {\n            index++;\n        }\n        helper1(ans, inner, nums, index + 1);\n    }\n    void helper(List<List<Integer>> ans, List<Integer> inner,int[] nums, int start){\n        ans.add(new ArrayList<>(inner));\n\n        for(int i=start;i<nums.length;i++){\n            if(i!=start && nums[i-1]==nums[i]) continue;\n\n            inner.add(nums[i]);\n            helper(ans,inner,nums,i+1);\n            inner.remove(inner.size()-1);\n        }\n    }\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> ans= new ArrayList<>();\n\n        helper1(ans,new ArrayList<>(),nums,0);\n        return ans;\n    }\n}",
    "title_slug": "subsets-ii",
    "problem_url": "https://leetcode.com/problems/subsets-ii/"
  },
  {
    "question_id": 39,
    "code": "class Solution {\n    void helper(List<List<Integer>> ans,List<Integer> inner,int[] cand,int target,int index){\n      \n        if(index==cand.length){\n            if(target==0){\n                ans.add(new ArrayList<>(inner));\n            }\n            return;\n        }\n        \n        if(cand[index]<=target){\n            inner.add(cand[index]);\n            helper(ans,inner,cand,target-cand[index],index);\n            inner.remove(inner.size()-1);\n        }\n        helper(ans,inner,cand,target,index+1);\n        \n    }\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> ans = new ArrayList<>();\n        helper(ans,new ArrayList<>(),candidates,target,0);\n        return ans;\n    }\n\n    \n}",
    "title_slug": "combination-sum",
    "problem_url": "https://leetcode.com/problems/combination-sum/"
  },
  {
    "question_id": 90,
    "code": "class Solution {\n\n    void helper(List<List<Integer>> ans, List<Integer> inner,int[] nums, int start){\n        ans.add(new ArrayList<>(inner));\n\n        for(int i=start;i<nums.length;i++){\n            if(i!=start && nums[i-1]==nums[i]) continue;\n\n            inner.add(nums[i]);\n            helper(ans,inner,nums,i+1);\n            inner.remove(inner.size()-1);\n        }\n    }\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> ans= new ArrayList<>();\n\n        helper(ans,new ArrayList<>(),nums,0);\n        return ans;\n    }\n}",
    "title_slug": "subsets-ii",
    "problem_url": "https://leetcode.com/problems/subsets-ii/"
  },
  {
    "question_id": 90,
    "code": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        List<List<Integer>> outer= new ArrayList<>();\n        Arrays.sort(nums);\n        int n=nums.length;\n        outer.add(new ArrayList<Integer>());\n        int start; int end=0;\n        for(int i=0;i<n;i++){\n            start=0;\n            if(i>0 && nums[i-1]==nums[i])\n                start=end+1;\n            end=outer.size()-1;\n            for(int j=start;j<=end;j++){\n                ArrayList<Integer> inner = new ArrayList<>(outer.get(j));\n                inner.add(nums[i]);\n                outer.add(inner);\n            }\n        }\n        return outer;\n    }\n}",
    "title_slug": "subsets-ii",
    "problem_url": "https://leetcode.com/problems/subsets-ii/"
  },
  {
    "question_id": 3416,
    "code": "class Solution {\n    public long sumDigitDifferences(int[] nums) {\n        int n=nums.length;\n        long sum=0;\n        int m= (int) Math.log10(nums[0]) +1;\n\n        for(int i=0;i<m;i++){\n\n            int[] occu= new int[10];\n            for(int j=0;j<n;j++){\n                int x=nums[j]%10;\n                occu[x]++;\n                nums[j]/=10;\n            }\n\n            for(int j=0;j<10;j++){\n                if(occu[j]>0)\n                sum+= (long)( n - (occu[j]))*occu[j];\n            }\n        }\n\n        return sum/2;\n    }\n}",
    "title_slug": "sum-of-digit-differences-of-all-pairs",
    "problem_url": "https://leetcode.com/problems/sum-of-digit-differences-of-all-pairs/"
  },
  {
    "question_id": 3427,
    "code": "class Solution {\n    public boolean[] isArraySpecial(int[] nums, int[][] queries) {\n        int n= nums.length;\n            \n        int[] inv= new int[n];\n        boolean[] sp= new boolean[n];\n        \n        inv[0]=-1;\n        sp[0]=true;\n        for(int i=1;i<n;i++){\n            if(nums[i]%2!=nums[i-1]%2){\n                sp[i]=sp[i-1];\n                inv[i]=inv[i-1];\n            }else{\n                sp[i]=false;\n                inv[i]=i-1;\n            }\n            \n        }\n        int m=queries.length;\n        boolean[] ans= new boolean[m];\n        for(int i=0;i<m;i++){\n            \n            int s= queries[i][0];\n            int e=queries[i][1];\n            if(s==e){\n                ans[i]=true;\n            }else if(inv[e]<s){\n                ans[i]=true;   \n            }else{\n                ans[i]=false;\n            }\n        }\n        \n        return ans;\n    }\n}",
    "title_slug": "special-array-ii",
    "problem_url": "https://leetcode.com/problems/special-array-ii/"
  },
  {
    "question_id": 3429,
    "code": "class Solution {\n    public boolean isArraySpecial(int[] nums) {\n        int n=nums.length;\n        if (n==1) return true;\n\n        for(int i=1;i<n;i++){\n            if(nums[i-1]%2==0 && nums[i]%2==0)\n                return false;\n            if(nums[i-1]%2==1 && nums[i]%2==1)\n                return false;\n        }\n\n        return true;\n    }\n}",
    "title_slug": "special-array-i",
    "problem_url": "https://leetcode.com/problems/special-array-i/"
  },
  {
    "question_id": 3337,
    "code": "class Solution {\n    public long countSubstrings(String s, char c) {\n         int n = s.length();\n        long a=0;\n        for(int i=0;i<n;i++){\n                if(s.charAt(i)==c)\n                    a++;\n        }\n        return a*(a+1)/2;\n        \n    }\n}",
    "title_slug": "count-substrings-starting-and-ending-with-given-character",
    "problem_url": "https://leetcode.com/problems/count-substrings-starting-and-ending-with-given-character/"
  },
  {
    "question_id": 3353,
    "code": "class Solution {\n    public boolean isSubstringPresent(String s) {\n        int n=s.length();\n        Set<String> hash_set = new HashSet<String>(); \n        \n        for (int i = 0; i < n - 1; i++) {\n            \n            String str=s.charAt(i)+\"\"+s.charAt(i+1);\n            if(hash_set.contains(s.charAt(i+1)+\"\"+s.charAt(i)) || s.charAt(i+1)==s.charAt(i)){\n                return true;\n            }else{\n                hash_set.add(str);\n                \n            }\n        }\n        return false;\n    }\n}",
    "title_slug": "existence-of-a-substring-in-a-string-and-its-reverse",
    "problem_url": "https://leetcode.com/problems/existence-of-a-substring-in-a-string-and-its-reverse/"
  },
  {
    "question_id": 3367,
    "code": "class Solution {\n    public int sumOfEncryptedInt(int[] nums) {\n        int n=nums.length; \n        for(int i=0;i<n;i++){\n            int maxnum=-1; int digitcount=0;\n            while(nums[i]!=0){\n                int rem= nums[i]%10;\n                if(rem>maxnum){\n                    maxnum=rem;\n                }\n                digitcount++;\n                nums[i]/=10;\n            }\n            \n            int x=0;\n            \n            for(int d=0;d<digitcount;d++){\n                x= x*10 + maxnum;\n            }\n            nums[i]=x;\n        }\n        \n        int sum=0;\n        for(int i=0;i<n;i++){\n            sum+=nums[i];\n        }\n        return sum;\n    }\n}",
    "title_slug": "find-the-sum-of-encrypted-integers",
    "problem_url": "https://leetcode.com/problems/find-the-sum-of-encrypted-integers/"
  },
  {
    "question_id": 300,
    "code": "class Solution {\n    int helper(int[] nums, int prev, int cur,int[][] dp){\n\n        if(prev==nums.length || cur==nums.length+1){\n            return 0;\n        }\n\n        if(dp[prev][cur]!=-1)\n            return dp[prev][cur];\n\n        // picking current\n        int pick = Integer.MIN_VALUE;\n        if(prev==0 || nums[prev-1]<nums[cur-1]){\n            pick = 1+ helper(nums,cur,cur+1,dp);\n        }\n        // not picking current\n        int notpick = helper(nums,prev,cur+1,dp);\n\n        return dp[prev][cur]=Math.max(pick,notpick);\n    }\n    public int lengthOfLIS(int[] nums) {\n        int n=nums.length;\n        int[][] dp=new int[n+1][n+1];\n        for(int[] d:dp)\n            Arrays.fill(d,-1);\n        return helper(nums,0,1,dp);\n    }\n}",
    "title_slug": "longest-increasing-subsequence",
    "problem_url": "https://leetcode.com/problems/longest-increasing-subsequence/"
  },
  {
    "question_id": 44,
    "code": "class Solution {\n    boolean helper(String s,String p,int i,int j, int[][] dp){\n        if(i<0){\n            while(j>=0){\n                if(p.charAt(j)!='*')\n                    return false;\n                j--;\n            }\n            return true;\n        }\n\n        if(j<0){\n            if(i>=0) \n            return false;\n            return true;\n        }\n        if(dp[i][j]!=-1)\n            return dp[i][j]==1?true:false;\n        \n        boolean ans=false;\n        if(s.charAt(i)==p.charAt(j) || p.charAt(j)=='?'){\n            ans=helper(s,p,i-1,j-1,dp);\n        }else if(p.charAt(j)=='*'){\n            ans=helper(s,p,i,j-1,dp) || helper(s,p,i-1,j,dp);\n        }\n\n        dp[i][j]=ans?1:0;\n        return ans;\n    } \n    public boolean isMatch(String s, String p) {\n        int m=s.length(); int n=p.length();\n        int[][] dp= new int[m][n];\n        for(int[] d:dp)\n            Arrays.fill(d,-1);\n        return helper(s,p,m-1,n-1,dp);\n    }\n}",
    "title_slug": "wildcard-matching",
    "problem_url": "https://leetcode.com/problems/wildcard-matching/"
  },
  {
    "question_id": 72,
    "code": "class Solution {\n    int helper(String word1,String word2, int s,int t,int[][] dp){\n\n        // string matched only deletion is need for remaining\n        if(t<1){\n            return s;\n        }\n        // string have not matched, insertion is needed for t remaining\n        if(s<1){\n            return t;\n        }\n\n        if(dp[s][t]!=-1)\n            return dp[s][t];\n        if(word1.charAt(s-1)==word2.charAt(t-1)){\n            return dp[s][t]= helper(word1,word2,s-1,t-1,dp);\n        }\n        // delete\n        int delete= 1+ helper(word1,word2,s-1,t,dp); \n        // Insert\n        int insert= 1+ helper(word1,word2,s,t-1,dp); \n        // Replace\n        int replace= 1+ helper(word1,word2,s-1,t-1,dp); \n\n        return dp[s][t]= Math.min(insert,Math.min(delete,replace));\n    }\n    public int minDistance(String word1, String word2) {\n        int s= word1.length();\n        int t=word2.length();\n        int[] prev= new int[t+1];\n        \n        for(int i=0;i<=t;i++) prev[i]= i;\n\n\n        for(int i=1;i<=s;i++){\n            int[] cur= new int[t+1];\n            cur[0]=i;\n            for(int j=1;j<=t;j++){\n                if(word1.charAt(i-1)==word2.charAt(j-1)){\n                    cur[j]= prev[j-1];\n                }\n                else{\n                    // delete\n                    int delete= prev[j]; \n                    // Insert\n                    int insert= cur[j-1]; \n                    // Replace\n                    int replace= prev[j-1]; \n                    cur[j]= Math.min(insert,Math.min(delete,replace))+1;\n                }\n                \n            }\n            prev=cur;\n            \n        }\n        return prev[t];\n    }\n}\n\n",
    "title_slug": "edit-distance",
    "problem_url": "https://leetcode.com/problems/edit-distance/"
  },
  {
    "question_id": 72,
    "code": "class Solution {\n    int helper(String word1,String word2, int s,int t,int[][] dp){\n\n        // string matched only deletion is need for remaining\n        if(t<1){\n            return s;\n        }\n        // string have not matched, insertion is needed for t remaining\n        if(s<1){\n            return t;\n        }\n\n        if(dp[s][t]!=-1)\n            return dp[s][t];\n        if(word1.charAt(s-1)==word2.charAt(t-1)){\n            return dp[s][t]= helper(word1,word2,s-1,t-1,dp);\n        }\n        // delete\n        int delete= 1+ helper(word1,word2,s-1,t,dp); \n        // Insert\n        int insert= 1+ helper(word1,word2,s,t-1,dp); \n        // Replace\n        int replace= 1+ helper(word1,word2,s-1,t-1,dp); \n\n        return dp[s][t]= Math.min(insert,Math.min(delete,replace));\n    }\n    public int minDistance(String word1, String word2) {\n        int s= word1.length();\n        int t=word2.length();\n        int[][] dp= new int[s+1][t+1];\n        \n        for(int i=0;i<=t;i++) dp[0][i]= i;\n        for(int i=0;i<=s;i++) dp[i][0]= i;\n\n\n        for(int i=1;i<=s;i++){\n            for(int j=1;j<=t;j++){\n                if(word1.charAt(i-1)==word2.charAt(j-1)){\n                    dp[i][j]= dp[i-1][j-1];\n                }\n                else{\n                    // delete\n                    int delete= dp[i-1][j]; \n                    // Insert\n                    int insert= dp[i][j-1]; \n                    // Replace\n                    int replace= dp[i-1][j-1]; \n\n                    dp[i][j]= Math.min(insert,Math.min(delete,replace))+1;\n                }\n                \n            }\n        }\n        return dp[s][t];\n    }\n}\n\n",
    "title_slug": "edit-distance",
    "problem_url": "https://leetcode.com/problems/edit-distance/"
  },
  {
    "question_id": 72,
    "code": "class Solution {\n    int helper(String word1,String word2, int s,int t,int[][] dp){\n\n        // string matched only deletion is need for remaining\n        if(t<1 && s>=1){\n            return s;\n        }\n        // string have not matched, insertion is needed for t remaining\n        if(s<1 && t>=1){\n            return t;\n        }\n\n        if(s<1&& t<1){\n            return 0;\n        }\n        if(dp[s][t]!=-1)\n            return dp[s][t];\n        if(word1.charAt(s-1)==word2.charAt(t-1)){\n            return dp[s][t]= helper(word1,word2,s-1,t-1,dp);\n        }\n        // delete\n        int delete= 1+ helper(word1,word2,s-1,t,dp); \n        // Insert\n        int insert= 1+ helper(word1,word2,s,t-1,dp); \n        // Replace\n        int replace= 1+ helper(word1,word2,s-1,t-1,dp); \n\n        return dp[s][t]= Math.min(insert,Math.min(delete,replace));\n    }\n    public int minDistance(String word1, String word2) {\n        int s= word1.length();\n        int t=word2.length();\n        int[][] dp= new int[s+1][t+1];\n        for(int[] d:dp)\n            Arrays.fill(d,-1);\n        \n        return helper(word1,word2,s,t,dp);\n    }\n}\n\n",
    "title_slug": "edit-distance",
    "problem_url": "https://leetcode.com/problems/edit-distance/"
  },
  {
    "question_id": 115,
    "code": "class Solution {\n    // for babgbag\n    // '' b a g\n    //  1 0 0 0\n    //  1 1 0 0\n    //  1 1 1 0\n    //  1 2 1 0\n    //  1 2 1 1\n    //  1 3 1 1\n    //  1 3 4 1\n    //  1 3 4 5\n    public int numDistinct(String s, String t) {\n        int m=s.length(); int n=t.length();\n\n        int[] dp= new int[n+1];\n        dp[0]=1;\n\n        for(int i=1;i<=m;i++){\n            for(int j=n;j>0;j--){\n                if(s.charAt(i-1)==t.charAt(j-1)){\n                    dp[j]+= dp[j-1];\n                } \n            }\n        }\n\n        return dp[n];\n    } \n}",
    "title_slug": "distinct-subsequences",
    "problem_url": "https://leetcode.com/problems/distinct-subsequences/"
  },
  {
    "question_id": 115,
    "code": "class Solution {\n    public int numDistinct(String s, String t) {\n        int m=s.length(); int n=t.length();\n\n        int[] dp= new int[n+1];\n        dp[0]=1;\n\n        for(int i=1;i<=m;i++){\n            for(int j=n;j>0;j--){\n                if(s.charAt(i-1)==t.charAt(j-1)){\n                    dp[j]+= dp[j-1];\n                } \n            }\n        }\n\n        return dp[n];\n    } \n}",
    "title_slug": "distinct-subsequences",
    "problem_url": "https://leetcode.com/problems/distinct-subsequences/"
  },
  {
    "question_id": 115,
    "code": "class Solution {\n    int helper(String s,String t,int m,int n,int[][] dp){\n        if(n<1)\n            return 1;\n        if(m<1)\n            return 0;\n        \n        if(dp[m][n]!=-1)\n            return dp[m][n];\n        \n        if(s.charAt(m-1)==t.charAt(n-1)){\n            return dp[m][n]= helper(s,t,m-1,n-1,dp) + helper(s,t,m-1,n,dp);\n        }\n        return dp[m][n] = helper(s,t,m-1,n,dp);\n\n    }\n    public int numDistinct(String s, String t) {\n        int m=s.length(); int n=t.length();\n\n        int[][] dp= new int[m+1][n+1];\n        for(int i=0;i<=m;i++) dp[i][0]=1;\n\n        for(int i=1;i<=m;i++){\n            for(int j=1;j<=n;j++){\n                if(s.charAt(i-1)==t.charAt(j-1)){\n                    dp[i][j]= dp[i-1][j-1] + dp[i-1][j];\n                } else{\n                    dp[i][j]=dp[i-1][j];\n                }\n            }\n        }\n\n        return dp[m][n];\n    } \n}",
    "title_slug": "distinct-subsequences",
    "problem_url": "https://leetcode.com/problems/distinct-subsequences/"
  },
  {
    "question_id": 115,
    "code": "class Solution {\n    int helper(String s,String t,int m,int n,int[][] dp){\n        if(n<1)\n            return 1;\n        if(m<1)\n            return 0;\n        \n        if(dp[m][n]!=-1)\n            return dp[m][n];\n        \n        if(s.charAt(m-1)==t.charAt(n-1)){\n            return dp[m][n]= helper(s,t,m-1,n-1,dp) + helper(s,t,m-1,n,dp);\n        }\n        return dp[m][n] = helper(s,t,m-1,n,dp);\n\n    }\n    public int numDistinct(String s, String t) {\n        int m=s.length(); int n=t.length();\n\n        int[][] dp= new int[m+1][n+1];\n        for(int[] d:dp)\n            Arrays.fill(d,-1);\n\n        return helper(s,t,m,n,dp); \n    } \n}",
    "title_slug": "distinct-subsequences",
    "problem_url": "https://leetcode.com/problems/distinct-subsequences/"
  },
  {
    "question_id": 1170,
    "code": "class Solution {\n    public String shortestCommonSupersequence(String str1, String str2) {\n        int m=str1.length();\n        int n=str2.length();\n        int[][] dp = new int[m+1][n+1];\n\n        for(int i=0;i<=n;i++) dp[0][i]=0;\n        for(int i=0;i<=m;i++) dp[i][0]=0;\n\n\n\n        for(int i=1;i<=m;i++){\n            for(int j=1;j<=n;j++){\n                if(str1.charAt(i-1)==str2.charAt(j-1)){\n                    dp[i][j] = dp[i-1][j-1] +1;\n                }else{\n                    dp[i][j]= Math.max(dp[i-1][j],dp[i][j-1]);\n                }\n            }\n        }\n\n        StringBuilder str= new StringBuilder();\n        int i=m; int j=n;\n        while(i>0 && j>0){\n            if(str1.charAt(i-1)==str2.charAt(j-1)){\n                str.append(str1.charAt(i-1)+\"\");\n                i--; j--;\n            }else if(dp[i-1][j]>dp[i][j-1]){\n                str.append(str1.charAt(i-1)+\"\");\n                i--;\n            }else{\n                str.append(str2.charAt(j-1)+\"\");\n                j--;\n            }\n        }\n\n\n        while(i>0){\n            str.append(str1.charAt(i-1)); i--;\n        }\n        while(j>0){\n            str.append(str2.charAt(j-1)); j--;\n        }\n\n        return str.reverse().toString();\n    }\n}",
    "title_slug": "shortest-common-supersequence",
    "problem_url": "https://leetcode.com/problems/shortest-common-supersequence/"
  },
  {
    "question_id": 3351,
    "code": "public class Solution {\n//     void decby1(int[] arr){\n//         for(int i = 0; i < arr.length; i++){\n//             if(arr[i] > 0)\n//                 arr[i] -= 1;\n//         }\n//     }\n    \n//     int maxinarr(int[] arr){\n//         int maxi = 0;\n//         for(int i = 1; i < arr.length; i++){\n//             if(arr[i] > arr[maxi])\n//                 maxi = i;\n//         }\n//         return maxi;\n//     }\n\n    public long maximumHappinessSum(int[] h, int k) {\n        if (h == null || h.length == 0 || k <= 0) return 0;\n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a); // Max heap\n\n        for (int happiness : h) {\n            maxHeap.offer(happiness);\n        }\n        long sum = 0; int redby=0;\n        for(int i = 0; i < k; i++){\n            int maxHappiness = maxHeap.poll() -redby;\n            if(maxHappiness>0){\n                sum += maxHappiness;\n                redby++;}\n        }\n        return sum;\n    }\n}\n\n",
    "title_slug": "maximize-happiness-of-selected-children",
    "problem_url": "https://leetcode.com/problems/maximize-happiness-of-selected-children/"
  },
  {
    "question_id": 3334,
    "code": "class Solution {\n    public int minimumBoxes(int[] apple, int[] capacity) {\n        int alen=apple.length;\n        int clen=capacity.length;\n        int suma=0;\n        for(int i=0;i<alen;i++){\n            suma+=apple[i];\n        }\n        int sum=0;  \n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>((a, b) -> b - a); // Max heap\n\n        for (int c : capacity) {\n            maxHeap.offer(c);\n        }\n        \n        int ans=0;\n        for (int i = 0; i < clen; i++) {\n            int maxcap = maxHeap.poll();\n            suma-=maxcap;\n            ans++;\n            if(suma<=0){\n                break;\n            }\n        }\n\n        return ans;\n    }\n}",
    "title_slug": "apple-redistribution-into-boxes",
    "problem_url": "https://leetcode.com/problems/apple-redistribution-into-boxes/"
  },
  {
    "question_id": 583,
    "code": "class Solution {\n    public int minDistance(String word1, String word2) {\n        int m=word1.length();\n        int n=word2.length();\n        int[] prev= new int[n+1];\n        for(int i=1;i<=m;i++){\n            int[] cur= new int[n+1];\n            for(int j=1;j<=n;j++){\n                if(word1.charAt(i-1)==word2.charAt(j-1))\n                    cur[j]=prev[j-1] +1;\n                else \n                    cur[j]=Math.max(prev[j],cur[j-1]);\n\n            }\n            prev=cur;\n        }\n        int x=prev[n];\n        return m-x +n-x;\n    }\n}",
    "title_slug": "delete-operation-for-two-strings",
    "problem_url": "https://leetcode.com/problems/delete-operation-for-two-strings/"
  },
  {
    "question_id": 1437,
    "code": "class Solution {\n    public int minInsertions(String s) {\n        // logic is to subtract longest palindromic subsequence from the length\n\n        int n=s.length();\n        String rev= new StringBuilder(s).reverse().toString();\n        int[] prev= new int[n+1];\n\n        for(int i=1;i<=n;i++){\n            int[] cur= new int[n+1];\n            for(int j=1;j<=n;j++){\n                if(s.charAt(i-1)==rev.charAt(j-1))\n                    cur[j]=prev[j-1] +1;\n                else\n                    cur[j]=Math.max(prev[j],cur[j-1]);\n            }\n            prev=cur;\n        }\n\n        return n-prev[n];\n    }\n}",
    "title_slug": "minimum-insertion-steps-to-make-a-string-palindrome",
    "problem_url": "https://leetcode.com/problems/minimum-insertion-steps-to-make-a-string-palindrome/"
  },
  {
    "question_id": 516,
    "code": "class Solution {\n    public int longestPalindromeSubseq(String s) {\n        String rev= new StringBuilder(s).reverse().toString();\n        int n=s.length();\n        int[] prev= new int[n+1];\n\n        for(int i=1;i<=n;i++){\n            int[] cur= new int[n+1];\n            for(int j=1;j<=n;j++){\n                if(s.charAt(i-1)==rev.charAt(j-1)){\n                    cur[j] = 1 + prev[j-1];\n                }else\n                    cur[j]= Math.max(prev[j],cur[j-1]);\n            }\n            prev=cur;\n        }\n        return prev[n];\n    }\n}",
    "title_slug": "longest-palindromic-subsequence",
    "problem_url": "https://leetcode.com/problems/longest-palindromic-subsequence/"
  },
  {
    "question_id": 1250,
    "code": "class Solution {\n    public int longestCommonSubsequence(String t1, String t2) {\n\n        int n1=t1.length();\n        int n2=t2.length();\n        int[] prev= new int[n2+1];\n        \n        \n        for(int i=1;i<=n1;i++){\n            int[] cur= new int[n2+1];\n            for(int j=1;j<=n2;j++){\n                // If the characters match, \n                // update cur[j] to be one plus the LCS length \n                // found by moving diagonally (i.e., from prev[j - 1]).\n                if(t1.charAt(i-1)==t2.charAt(j-1)){\n                    cur[j]=1+ prev[j-1];\n                }\n                else \n                // If the characters don't match, \n                // you take the maximum LCS length from \n                // either the top (prev[j]) or the left (cur[j - 1]).\n                    cur[j]= Math.max(cur[j-1],prev[j]);\n            }\n            prev=cur;\n        }\n\n        return prev[n2];\n    }\n\n    \n}",
    "title_slug": "longest-common-subsequence",
    "problem_url": "https://leetcode.com/problems/longest-common-subsequence/"
  },
  {
    "question_id": 1250,
    "code": "class Solution {\n    int helper(String t1,int n1,String t2,int n2,int[][] dp){\n        if(n1==0 || n2==0){\n            return 0;\n        }\n        if(dp[n1][n2]!=-1)  \n            return dp[n1][n2];\n        if(t1.charAt(n1-1)==t2.charAt(n2-1)){\n            return dp[n1][n2]=1+ helper(t1,n1-1,t2,n2-1,dp);\n        }\n\n        return dp[n1][n2]=Math.max(\n            helper(t1,n1-1,t2,n2,dp),helper(t1,n1,t2,n2-1,dp)\n        );\n    }\n    public int longestCommonSubsequence(String t1, String t2) {\n\n        int n1=t1.length();\n        int n2=t2.length();\n        int[][] dp= new int[n1+1][n2+1];\n        \n        \n        for(int i=1;i<=n1;i++){\n            for(int j=1;j<=n2;j++){\n                if(t1.charAt(i-1)==t2.charAt(j-1)){\n                    dp[i][j]=1+ dp[i-1][j-1];\n                }\n                else\n                    dp[i][j]= Math.max(dp[i-1][j],dp[i][j-1]);\n            }\n        }\n\n        return dp[n1][n2];\n\n        // for(int[] d:dp)\n        //     Arrays.fill(d,-1);\n        // return helper(text1,n1,text2,n2,dp);\n    \n    }\n\n    // wrong approach (does not work for subsequences)\n    // public int longestCommonSubsequence(String text1, String text2) {\n    //     boolean[] txt1= new boolean[26];\n    //     boolean[] txt2= new boolean[26];\n\n    //     for(int i=0;i<text1.length();i++){\n    //         int index = text1.charAt(i) - 'a';\n    //         txt1[index]=true;\n    //     }\n\n    //     for(int i=0;i<text2.length();i++){\n    //          int index = text2.charAt(i) - 'a';\n    //          txt2[index]=true;\n    //     }\n\n    //     int count=0;\n    //     boolean prev=true;\n    //     for(int i=0;i<text1.length();i++){\n    //         int index = text1.charAt(i) - 'a';\n    //         if(txt1[index] && txt2[index]){\n    //             count++;\n    //         }\n    //     }\n    //     return count;\n    // }\n}",
    "title_slug": "longest-common-subsequence",
    "problem_url": "https://leetcode.com/problems/longest-common-subsequence/"
  },
  {
    "question_id": 1250,
    "code": "class Solution {\n    int helper(String t1,int n1,String t2,int n2,int[][] dp){\n        if(n1<0 || n2<0){\n            return 0;\n        }\n        if(dp[n1][n2]!=-1)  \n            return dp[n1][n2];\n        if(t1.charAt(n1)==t2.charAt(n2)){\n            return dp[n1][n2]=1+ helper(t1,n1-1,t2,n2-1,dp);\n        }\n\n        return dp[n1][n2]=Math.max(\n            helper(t1,n1-1,t2,n2,dp),helper(t1,n1,t2,n2-1,dp)\n        );\n    }\n    public int longestCommonSubsequence(String text1, String text2) {\n\n        int n1=text1.length();\n        int n2=text2.length();\n        int[][] dp= new int[n1][n2];\n        for(int[] d:dp)\n            Arrays.fill(d,-1);\n        return helper(text1,n1-1,text2,n2-1,dp);\n    \n    }\n\n    // wrong approach (does not work for subsequences)\n    // public int longestCommonSubsequence(String text1, String text2) {\n    //     boolean[] txt1= new boolean[26];\n    //     boolean[] txt2= new boolean[26];\n\n    //     for(int i=0;i<text1.length();i++){\n    //         int index = text1.charAt(i) - 'a';\n    //         txt1[index]=true;\n    //     }\n\n    //     for(int i=0;i<text2.length();i++){\n    //          int index = text2.charAt(i) - 'a';\n    //          txt2[index]=true;\n    //     }\n\n    //     int count=0;\n    //     boolean prev=true;\n    //     for(int i=0;i<text1.length();i++){\n    //         int index = text1.charAt(i) - 'a';\n    //         if(txt1[index] && txt2[index]){\n    //             count++;\n    //         }\n    //     }\n    //     return count;\n    // }\n}",
    "title_slug": "longest-common-subsequence",
    "problem_url": "https://leetcode.com/problems/longest-common-subsequence/"
  },
  {
    "question_id": 1402,
    "code": "class Solution {\n    public int countSquares(int[][] mat) {\n       int m = mat.length;\n        int n = mat[0].length;\n        int[][] dp = new int[m][n];\n\n        for (int i = 0; i < n; i++)\n            dp[0][i] = mat[0][i];\n\n        for (int i = 0; i < m; i++)\n            dp[i][0] = mat[i][0];\n\n\n        for(int i=1;i<m;i++){\n            for(int j=1;j<n;j++){\n                if(mat[i][j]==0){\n                    dp[i][j]=0;\n                }else{\n                    dp[i][j]= 1+ Math.min(dp[i-1][j-1],Math.min(dp[i][j-1],dp[i-1][j]));\n                }\n            }\n        }\n\n\n        int sum=0;\n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                sum+= dp[i][j];\n            }\n        }\n\n        return sum;\n    }\n}",
    "title_slug": "count-square-submatrices-with-all-ones",
    "problem_url": "https://leetcode.com/problems/count-square-submatrices-with-all-ones/"
  },
  {
    "question_id": 85,
    "code": "class Solution {\n    int largestarea(int arr[]) {\n        int n=arr.length;\n        int maxArea = 0;\n        for (int i = 0; i < n; i++) {\n            int minHeight = Integer.MAX_VALUE;\n            for (int j = i; j < n; j++) {\n                minHeight = Math.min(minHeight, arr[j]);\n                maxArea = Math.max(maxArea, minHeight * (j - i + 1));\n            }\n        }\n        return maxArea;\n    }\n\n\n    public int maximalRectangle(char[][] mat) {\n        int m=mat[0].length;\n        int n=mat.length;\n        int[] heights= new int[m];\n        int ans=0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<m;j++){\n                if(mat[i][j]=='1')\n                    heights[j]++;\n                else heights[j]=0;\n            }\n\n            int area= largestarea(heights);\n            ans=Math.max(area,ans);\n        }\n        return ans;\n    }\n}",
    "title_slug": "maximal-rectangle",
    "problem_url": "https://leetcode.com/problems/maximal-rectangle/"
  },
  {
    "question_id": 1121,
    "code": "class Solution {\n    int helper(int ind, int[] arr,int k,int[] dp){\n        int n=arr.length;\n        if(ind==n)\n            return 0;\n        if(dp[ind]!=-1)\n            return dp[ind];\n        int maxi= Integer.MIN_VALUE;\n        int maxsum= Integer.MIN_VALUE;\n        int len=0;\n        for(int i=ind;i<Math.min(n,ind+k);i++){\n            len++;\n            maxi=Math.max(maxi,arr[i]);\n            int sum= (len*maxi) + helper(i+1,arr,k,dp);\n            maxsum=Math.max(sum,maxsum);\n        }\n\n        return dp[ind]=maxsum;\n    }\n\n    public int maxSumAfterPartitioning(int[] arr, int k) {\n        int n=arr.length;\n        int[] dp= new int[n];\n        Arrays.fill(dp,-1);\n\n        return helper(0,arr,k,dp);\n    }\n}",
    "title_slug": "partition-array-for-maximum-sum",
    "problem_url": "https://leetcode.com/problems/partition-array-for-maximum-sum/"
  },
  {
    "question_id": 132,
    "code": "class Solution {\n    boolean ispalindrome(int i, int j, String s) {\n        while (i < j) {\n            if (s.charAt(i) != s.charAt(j)) \n                return false;\n            i++;\n            j--;\n        }\n        return true;\n    }\n    public int minCut(String s) {\n\n        int n=s.length();\n        int[] dp = new int[n+1];\n\n        dp[n]=0;\n\n        int result= Integer.MAX_VALUE;\n        for(int i=n-1;i>=0;i--){\n            result = Integer.MAX_VALUE;\n            for(int j=i;j<n;j++){\n                if(ispalindrome(i,j,s)){\n                    int localcuts= 1 + dp[j+1];\n                    result= Math.min(result,localcuts);\n                }\n            }\n            dp[i]=result;\n        } \n\n        return result-1;\n\n    }\n}",
    "title_slug": "palindrome-partitioning-ii",
    "problem_url": "https://leetcode.com/problems/palindrome-partitioning-ii/"
  },
  {
    "question_id": 312,
    "code": "class Solution {\n    int helper(int l,int r,int[] temp,int[][] dp){\n        if(l>r)\n            return 0;\n        if(dp[l][r]!=-1)\n            return dp[l][r];\n        \n        int ans= Integer.MIN_VALUE;\n        for(int i=l;i<=r;i++){\n            int coins = temp[l-1]*temp[i]*temp[r+1] \n            + helper(l,i-1,temp,dp) + helper(i+1,r,temp,dp);\n            ans= Math.max(ans,coins);\n        }\n\n        return dp[l][r]=ans;\n    }\n    public int maxCoins(int[] nums) {\n        int n=nums.length;\n        int[] temp=new int[n+2];\n        temp[0]=1;\n        temp[n+1]=1;\n        for(int i=1;i<n+1;i++)\n            temp[i]=nums[i-1];\n\n        int[][] dp = new int[n+2][n+2];\n        for(int[] d:dp)\n            Arrays.fill(d,-1);\n        return helper(1,n,temp,dp);\n    }\n}",
    "title_slug": "burst-balloons",
    "problem_url": "https://leetcode.com/problems/burst-balloons/"
  },
  {
    "question_id": 1669,
    "code": "class Solution {\n    // interesting one need revist\n    int helper(int left,int right,int[] temp,int[][] dp){\n        if(left>right)\n            return 0;\n        if(dp[left][right]!=-1)\n            return dp[left][right];\n        int result=Integer.MAX_VALUE;\n        for(int i=left;i<=right;i++){\n            int cost = temp[right+1] -temp[left-1] + helper(left,i-1,temp,dp) + helper(i+1,right,temp,dp);\n            result= Math.min(result,cost);\n        }\n        return dp[left][right]=result;\n    }\n    public int minCost(int len, int[] cuts) {\n        int n=cuts.length;\n        int[] temp= new int[n+2];\n        temp[n]=0;\n        temp[n+1]=len;\n        for(int i=0;i<n;i++)\n            temp[i]=cuts[i];\n        // sorted temp with 0 to len elements\n        Arrays.sort(temp);\n\n        int[][] dp = new int[n+2][n+2];\n        for(int[] d:dp)\n            Arrays.fill(d,-1);\n        \n        return helper(1,n,temp,dp);\n\n    }\n} ",
    "title_slug": "minimum-cost-to-cut-a-stick",
    "problem_url": "https://leetcode.com/problems/minimum-cost-to-cut-a-stick/"
  },
  {
    "question_id": 3069,
    "code": "import pandas as pd\n\ndef changeDatatype(students: pd.DataFrame) -> pd.DataFrame:\n    students= students.astype({'grade':int})\n    return students",
    "title_slug": "change-data-type",
    "problem_url": "https://leetcode.com/problems/change-data-type/"
  },
  {
    "question_id": 3068,
    "code": "import pandas as pd\n\ndef renameColumns(students: pd.DataFrame) -> pd.DataFrame:\n    students.rename(\n        columns={\n            'id':'student_id',\n            'first':'first_name',\n            'last':'last_name',\n            'age':'age_in_years'\n        }, inplace= True\n    )\n    return students",
    "title_slug": "rename-columns",
    "problem_url": "https://leetcode.com/problems/rename-columns/"
  },
  {
    "question_id": 3068,
    "code": "import pandas as pd\n\ndef renameColumns(students: pd.DataFrame) -> pd.DataFrame:\n    students=students.rename(\n        columns={\n            'id':'student_id',\n            'first':'first_name',\n            'last':'last_name',\n            'age':'age_in_years'\n        }\n    )\n    return students",
    "title_slug": "rename-columns",
    "problem_url": "https://leetcode.com/problems/rename-columns/"
  },
  {
    "question_id": 3067,
    "code": "import pandas as pd\n\ndef modifySalaryColumn(employees: pd.DataFrame) -> pd.DataFrame:\n    employees['salary']*= 2\n    return employees",
    "title_slug": "modify-columns",
    "problem_url": "https://leetcode.com/problems/modify-columns/"
  },
  {
    "question_id": 518,
    "code": "class Solution {\n    public int change(int amount, int[] coins) { \n\n        int n=coins.length;\n        int[] dp = new int[amount+1];\n        dp[0]=1;\n        for(int i=0;i<n;i++){\n            for(int j=coins[i];j<amount+1;j++){\n                dp[j]+=dp[j-coins[i]];\n            }\n        }\n\n        return dp[amount];\n    }\n}",
    "title_slug": "coin-change-ii",
    "problem_url": "https://leetcode.com/problems/coin-change-ii/"
  },
  {
    "question_id": 518,
    "code": "class Solution {\n\n\n    int helper(int[] coins, int amount, int index,int[][] dp){\n        if(index==0){\n            if(amount%coins[0]==0){\n                return 1;\n            }else return 0;\n        }\n\n        if(dp[index][amount]!=-1)\n            return dp[index][amount];\n        int nottake=  helper(coins,amount,index-1,dp);\n        int take=0;\n        if(coins[index]<=amount){\n            take = helper(coins,amount-coins[index],index,dp);\n        }\n\n        return dp[index][amount]=take + nottake;\n    }\n    public int change(int amount, int[] coins) {\n        int n=coins.length;\n        int[][] dp = new int[n][amount+1];\n        for(int[] d: dp)\n            Arrays.fill(d,-1);\n        return helper(coins,amount,n-1,dp);\n    }\n}",
    "title_slug": "coin-change-ii",
    "problem_url": "https://leetcode.com/problems/coin-change-ii/"
  },
  {
    "question_id": 322,
    "code": "class Solution {\n     \n    public int coinChange(int[] coins, int amount) {\n     int[] dp = new int[amount+1];\n\n     Arrays.fill(dp,amount+1);\n     int n = coins.length;\n     dp[0]=0;\n     for(int i=1;i<amount+1;i++){\n         for(int j=0;j<n;j++){\n             if(coins[j]<=i){\n                 dp[i]= Math.min(dp[i], 1+ dp[i-coins[j]]);\n             }\n         }\n     }\n     if(dp[amount]>amount)\n        return -1;\n     return dp[amount];\n    }\n}",
    "title_slug": "coin-change",
    "problem_url": "https://leetcode.com/problems/coin-change/"
  },
  {
    "question_id": 322,
    "code": "class Solution {\n     int helper(int[] coins, int amount,int index,int[][] dp){\n        if(index==0){\n            if(amount%coins[0]==0){\n                return amount/coins[0];\n            }\n            return (int) Math.pow(10, 9);\n        }\n\n        if(dp[index][amount]!=-1)\n            return dp[index][amount];\n\n\n        int notpick= 0 + helper(coins,amount,index-1,dp);\n        int pick= (int) Math.pow(10, 9);\n        if(coins[index]<=amount){\n            pick= 1 + helper(coins,amount-coins[index],index,dp);\n        }\n\n        return dp[index][amount]=Math.min(pick,notpick);\n       \n    }\n    public int coinChange(int[] coins, int amount) {\n        int n= coins.length;\n        // int[][] dp = new int[n][amount+1];\n        // for(int[] d: dp)\n        //     Arrays.fill(d,-1);\n        // int ans=helper(coins,amount,n-1,dp);\n        // if (ans >=(int) Math.pow(10, 9))\n        //     return -1;\n        // return ans;\n\n        int[] prev= new int[amount+1];\n        for(int i=0;i<amount+1;i++){\n            if(i%coins[0]==0)\n                prev[i]= i/coins[0];\n            else prev[i]=(int) Math.pow(10, 9);\n        }\n            \n        for(int i=1;i<n;i++){\n            int[] cur= new int[amount+1];\n            for(int j=0;j<amount+1;j++){\n                int notpick=0 + prev[j];\n                int pick= (int) Math.pow(10, 9);\n                if(coins[i]<=j){\n                    pick= 1 + cur[j-coins[i]];\n                }\n\n                cur[j]= Math.min(notpick,pick);\n            }\n            prev=cur;\n        }\n        \n        int ans= prev[amount];\n        if (ans >=(int) Math.pow(10, 9))\n            return -1;\n        return ans;\n\n    }\n}",
    "title_slug": "coin-change",
    "problem_url": "https://leetcode.com/problems/coin-change/"
  },
  {
    "question_id": 322,
    "code": "class Solution {\n     int helper(int[] coins, int amount,int index,int[][] dp){\n        if(index==0){\n            if(amount%coins[0]==0){\n                return amount/coins[0];\n            }\n            return (int) Math.pow(10, 9);\n        }\n\n        if(dp[index][amount]!=-1)\n            return dp[index][amount];\n\n\n        int notpick= 0 + helper(coins,amount,index-1,dp);\n        int pick= (int) Math.pow(10, 9);\n        if(coins[index]<=amount){\n            pick= 1 + helper(coins,amount-coins[index],index,dp);\n        }\n\n        return dp[index][amount]=Math.min(pick,notpick);\n       \n    }\n    public int coinChange(int[] coins, int amount) {\n        int n= coins.length;\n        int[][] dp = new int[n][amount+1];\n        for(int[] d: dp)\n            Arrays.fill(d,-1);\n        int ans=helper(coins,amount,n-1,dp);\n        if (ans >=(int) Math.pow(10, 9))\n            return -1;\n        return ans;\n    }\n}",
    "title_slug": "coin-change",
    "problem_url": "https://leetcode.com/problems/coin-change/"
  },
  {
    "question_id": 3308,
    "code": "class Solution {\n    public String lastNonEmptyString(String s) {\n        \n       StringBuilder lastStr = new StringBuilder();\n        char[] carr = s.toCharArray();\n        int n = carr.length;\n        Map<Character, Integer> map = new HashMap<>();\n        \n        for (char c : carr) {\n            map.put(c, map.getOrDefault(c, 0) + 1);\n        }\n        \n        int highest = Integer.MIN_VALUE;\n        for (int count : map.values()) {\n            highest = Math.max(highest, count);\n        }\n        \n        Set<Character> encountered = new HashSet<>();\n        for (int i = n - 1; i >= 0; i--) {\n            char c = carr[i];\n            if (map.get(c) == highest && !encountered.contains(c)) {\n                lastStr.insert(0, c);\n                encountered.add(c);\n            }\n        }\n        \n        return lastStr.toString();\n    }\n}",
    "title_slug": "apply-operations-to-make-string-empty",
    "problem_url": "https://leetcode.com/problems/apply-operations-to-make-string-empty/"
  },
  {
    "question_id": 3320,
    "code": "class Solution {\n    public int maxOperations(int[] nums) {\n        int n=nums.length;\n        if(n==0)\n                return 0;\n        if(n==1)\n            return nums[0];\n        int op=1;\n        int sum=nums[0] + nums[1];\n        if(n%2!=0)\n            n--;\n        for(int i=2;i<n;i+=2){\n                if(sum==nums[i]+nums[i+1])\n                    op++;\n                else \n                    break;\n            \n                \n            \n        }\n        return op;\n    }\n}",
    "title_slug": "maximum-number-of-operations-with-the-same-score-i",
    "problem_url": "https://leetcode.com/problems/maximum-number-of-operations-with-the-same-score-i/"
  },
  {
    "question_id": 188,
    "code": "class Solution {\n     // sell -> 1 you can sell\n    // buy -> 0 you cant sell\n    int helper(int[] prices,int index,int buy,int transactionNum, int[][][] dp){\n        if(transactionNum==0){\n            return 0;\n        }\n        if(index==prices.length){\n            return 0;\n        }\n        if(dp[index][buy][transactionNum]!=-1)\n            return dp[index][buy][transactionNum];\n        int profit=Integer.MIN_VALUE;\n        if(buy==0){\n            profit= Math.max(\n                -prices[index] + helper(prices,index+1,1,transactionNum,dp),\n                0 + helper(prices,index+1,0,transactionNum,dp)\n            );\n        }else{\n            profit= Math.max(\n                prices[index] + helper(prices,index+1,0,transactionNum-1,dp),\n                0 + helper(prices,index+1,1,transactionNum,dp)\n            );\n        }\n\n        return dp[index][buy][transactionNum]=profit;\n\n    }\n    public int maxProfit(int k, int[] prices) {\n        int n= prices.length;\n        // n prices * buy or sell (2) * 0,1,2 transactions rn\n        // these are the combinations that we can have hence the 3d dp.\n        int[][][] dp = new int[n][2][k+1];\n\n        for(int a[][]:dp)\n            for(int b[]:a)\n                Arrays.fill(b,-1);\n\n        return helper(prices,0,0,k,dp);\n    }\n}",
    "title_slug": "best-time-to-buy-and-sell-stock-iv",
    "problem_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/"
  },
  {
    "question_id": 309,
    "code": "class Solution {\n        // 0 -> you can buy\n    // 1-> you can't buy\n\n    int helper(int[] prices,int index,int buy, int[][] dp){\n        if(index>=prices.length){\n            return 0;\n        }\n        if(dp[index][buy]!=-1)\n            return dp[index][buy];\n        int profit=Integer.MIN_VALUE;\n        if(buy==0){\n            profit= Math.max(\n                -prices[index] + helper(prices,index+1,1,dp),\n                0 + helper(prices,index+1,0,dp)\n            );\n        }else{\n            profit= Math.max(\n                prices[index] + helper(prices,index+2,0,dp),\n                0 + helper(prices,index+1,1,dp)\n            );\n        }\n\n        return dp[index][buy]=profit;\n\n    }\n\n    public int maxProfit(int[] prices) {\n       int n= prices.length;\n        int[][] dp= new int[n][2];\n\n        for(int[] d: dp)\n            Arrays.fill(d,-1);\n        \n        return helper(prices,0,0,dp);\n\n    }\n}",
    "title_slug": "best-time-to-buy-and-sell-stock-with-cooldown",
    "problem_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/"
  },
  {
    "question_id": 714,
    "code": "class Solution {\n    public int maxProfit(int[] prices, int fee) {\n        int n= prices.length;\n        // either i've bought the stock or not \n        // btw its future ^-^\n        int[] next= new int[2];\n        //base case for n\n        next[0]=next[1]=0;\n        for(int i=n-1;i>=0;--i){\n            // i can buy or not buy\n            int[] cur = new int[2];\n\n            // i won't buy, sell\n            cur[0]= Math.max(\n                prices[i]+next[1], // if i have bought it then i can sell it\n                0+next[0]);       // otherwise i cant sell it so i cant add it\n            // i will buy\n            cur[1]= Math.max(\n                -prices[i] - fee +next[0], // if i have sold so i can buy hence my profit will detuct\n                0+next[1]);         // if i have bought (in future) i can't buy again so nothing to add\n\n\n            next= cur;\n        }\n        return next[1];\n\n    }\n}",
    "title_slug": "best-time-to-buy-and-sell-stock-with-transaction-fee",
    "problem_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/"
  },
  {
    "question_id": 123,
    "code": "class Solution {\n    // sell -> 1 you can sell\n    // buy -> 0 you cant sell\n    int helper(int[] prices,int index,int buy,int transactionNum, int[][][] dp){\n        if(transactionNum==0){\n            return 0;\n        }\n        if(index==prices.length){\n            return 0;\n        }\n        if(dp[index][buy][transactionNum]!=-1)\n            return dp[index][buy][transactionNum];\n        int profit=Integer.MIN_VALUE;\n        if(buy==0){\n            profit= Math.max(\n                -prices[index] + helper(prices,index+1,1,transactionNum,dp),\n                0 + helper(prices,index+1,0,transactionNum,dp)\n            );\n        }else{\n            profit= Math.max(\n                prices[index] + helper(prices,index+1,0,transactionNum-1,dp),\n                0 + helper(prices,index+1,1,transactionNum,dp)\n            );\n        }\n\n        return dp[index][buy][transactionNum]=profit;\n\n    }\n    public int maxProfit(int[] prices) {\n        int n= prices.length;\n        // n prices * buy or sell (2) * 0,1,2 transactions rn\n        // these are the combinations that we can have hence the 3d dp.\n        int[][][] dp = new int[n][2][3];\n\n        for(int a[][]:dp)\n            for(int b[]:a)\n                Arrays.fill(b,-1);\n\n        return helper(prices,0,0,2,dp);\n    }\n}",
    "title_slug": "best-time-to-buy-and-sell-stock-iii",
    "problem_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/"
  },
  {
    "question_id": 122,
    "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int profit=0;\n        int n=prices.length;\n        for(int i=1;i<n;i++){\n            if(prices[i]>prices[i-1])\n                profit+= prices[i] - prices[i-1];\n        }\n        return profit;\n    }\n}",
    "title_slug": "best-time-to-buy-and-sell-stock-ii",
    "problem_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/"
  },
  {
    "question_id": 122,
    "code": "class Solution {\n    // 1 -> you can buy\n    // 0-> you can't buy\n\n    public int maxProfit(int[] prices) {\n        int n= prices.length;\n        // either i've bought the stock or not \n        // btw its future ^-^\n        int[] next= new int[2];\n        //base case for n\n        next[0]=next[1]=0;\n        for(int i=n-1;i>=0;--i){\n            // i can buy or not buy\n            int[] cur = new int[2];\n\n            // i won't buy, sell\n            cur[0]= Math.max(\n                prices[i]+next[1], // if i have bought it then i can sell it\n                0+next[0]);       // otherwise i cant sell it so i cant add it\n            // i will buy\n            cur[1]= Math.max(\n                -prices[i]+next[0], // if i have sold so i can buy hence my profit will detuct\n                0+next[1]);         // if i have bought (in future) i can't buy again so nothing to add\n\n\n            next= cur;\n        }\n        return next[1];\n    }\n}",
    "title_slug": "best-time-to-buy-and-sell-stock-ii",
    "problem_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/"
  },
  {
    "question_id": 122,
    "code": "class Solution {\n    // 0 -> you can buy\n    // 1-> you can't buy\n\n    int helper(int[] prices,int index,int buy, int[][] dp){\n        if(index==prices.length){\n            return 0;\n        }\n        if(dp[index][buy]!=-1)\n            return dp[index][buy];\n        int profit=Integer.MIN_VALUE;\n        if(buy==0){\n            profit= Math.max(\n                -prices[index] + helper(prices,index+1,1,dp),\n                0 + helper(prices,index+1,0,dp)\n            );\n        }else{\n            profit= Math.max(\n                prices[index] + helper(prices,index+1,0,dp),\n                0 + helper(prices,index+1,1,dp)\n            );\n        }\n\n        return dp[index][buy]=profit;\n\n    }\n\n    public int maxProfit(int[] prices) {\n        int n= prices.length;\n        // either i've bought the stock or not \n        // btw its future ^-^\n        int[] next= new int[2];\n        //base case for n\n        next[0]=next[1]=0;\n        for(int i=n-1;i>=0;--i){\n            // i can buy or not buy\n            int[] cur = new int[2];\n\n            // i won't buy, sell\n            cur[0]= Math.max(\n                prices[i]+next[1],\n                0+next[0]);\n            // i will buy\n            cur[1]= Math.max(\n                -prices[i]+next[0],\n                0+next[1]);\n\n\n            next= cur;\n        }\n        return next[1];\n\n\n        // for(int[] d: dp)\n        //     Arrays.fill(d,-1);\n        \n        // return helper(prices,0,0,dp);\n    }\n}",
    "title_slug": "best-time-to-buy-and-sell-stock-ii",
    "problem_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/"
  },
  {
    "question_id": 122,
    "code": "class Solution {\n    // 0 -> you can buy\n    // 1-> you can't buy\n\n    int helper(int[] prices,int index,int buy, int[][] dp){\n        if(index==prices.length){\n            return 0;\n        }\n        if(dp[index][buy]!=-1)\n            return dp[index][buy];\n        int profit=Integer.MIN_VALUE;\n        if(buy==0){\n            profit= Math.max(\n                -prices[index] + helper(prices,index+1,1,dp),\n                0 + helper(prices,index+1,0,dp)\n            );\n        }else{\n            profit= Math.max(\n                prices[index] + helper(prices,index+1,0,dp),\n                0 + helper(prices,index+1,1,dp)\n            );\n        }\n\n        return dp[index][buy]=profit;\n\n    }\n\n    public int maxProfit(int[] prices) {\n        int n= prices.length;\n        int[][] dp= new int[n][2];\n\n        for(int[] d: dp)\n            Arrays.fill(d,-1);\n        \n        return helper(prices,0,0,dp);\n    }\n}",
    "title_slug": "best-time-to-buy-and-sell-stock-ii",
    "problem_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/"
  },
  {
    "question_id": 48,
    "code": "class Solution {\n    void swap(int[][] mat,int a,int b,int x,int y){\n\n        int temp=mat[a][b];\n        mat[a][b]=mat[x][y];\n        mat[x][y]=temp;\n    }\n    public void rotate(int[][] mat) {\n        int n=mat.length;\n        for(int i=0;i<n;i++){\n            for(int j=i;j<n;j++){\n                // mat[i][j] <-> mat[j][i]\n                swap(mat,i,j,j,i);\n            }\n        }\n\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n/2;j++){\n                // mat[i][j] <-> mat[i][n-1-j]\n                swap(mat,i,j,i,n-1-j);\n            }\n        }\n\n\n    }\n}",
    "title_slug": "rotate-image",
    "problem_url": "https://leetcode.com/problems/rotate-image/"
  },
  {
    "question_id": 53,
    "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        int maxsum=nums[0];\n        int sum=0;\n        int n= nums.length;\n        for(int i=0;i<n;i++){\n            sum+=nums[i];\n            maxsum=Math.max(maxsum,sum);\n            if(sum<0)\n                sum=0;\n        }\n        return maxsum;\n    }\n}",
    "title_slug": "maximum-subarray",
    "problem_url": "https://leetcode.com/problems/maximum-subarray/"
  },
  {
    "question_id": 121,
    "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        int maxprofit=0;\n        int minprice=prices[0];\n\n        for(int i=1;i<prices.length;i++){\n            minprice= Math.min(minprice,prices[i]);\n            maxprofit= Math.max(maxprofit,prices[i]-minprice);\n        }\n\n        return maxprofit;\n    }\n}",
    "title_slug": "best-time-to-buy-and-sell-stock",
    "problem_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/"
  },
  {
    "question_id": 75,
    "code": "class Solution {\n    void swap(int i,int j, int[] nums){\n        int temp=nums[i];\n        nums[i]=nums[j];\n        nums[j]=temp;\n    }\n    public void sortColors(int[] nums) {\n        int low=0;\n        int mid=0;\n        int high=nums.length-1;\n\n        while(mid<=high){\n            if(nums[mid]==0){\n                swap(mid,low,nums);\n                low++;\n                mid++;\n            }else if(nums[mid]==2){\n                swap(mid,high,nums);\n                high--;\n            }else{\n                mid++;\n            }\n        }\n    }\n}",
    "title_slug": "sort-colors",
    "problem_url": "https://leetcode.com/problems/sort-colors/"
  },
  {
    "question_id": 31,
    "code": "class Solution {\n    public void nextPermutation(int[] nums) {\n        \n        int index=-1;\n        int n=nums.length;\n        for(int i=n-2;i>=0;i--){\n            if(nums[i]<nums[i+1]){\n                index=i;\n                break;\n            }\n        }\n\n        if(index==-1){\n            for(int i=0;i<n/2;i++){\n                int temp =nums[i];\n                nums[i]=nums[n-i-1];\n                nums[n-i-1]=temp;\n            }\n            return;\n        }\n\n        \n        for(int i=n-1;i>index;i--){\n            if(nums[i]>nums[index]){\n                int temp =nums[i];\n                nums[i]=nums[index];\n                nums[index]=temp;\n                break;\n            }\n            \n        }\n        \n        for(int i=index+1,j=n-1;i<j;i++,j--){\n                int temp =nums[i];\n                nums[i]=nums[j];\n                nums[j]=temp;\n        }\n    }\n\n}",
    "title_slug": "next-permutation",
    "problem_url": "https://leetcode.com/problems/next-permutation/"
  },
  {
    "question_id": 2324,
    "code": "class Solution {\n    public int triangularSum(int[] nums) {\n\n        int n = nums.length;\n        for (int i = n; i >= 0; --i) {\n            for (int j = 0; j < i - 1; ++j) {\n                nums[j] = (nums[j] + nums[j + 1]) % 10;\n            }\n        }\n        return nums[0];\n    }\n}",
    "title_slug": "find-triangular-sum-of-an-array",
    "problem_url": "https://leetcode.com/problems/find-triangular-sum-of-an-array/"
  },
  {
    "question_id": 2324,
    "code": "class Solution {\n    public int triangularSum(int[] nums) {\n\n        int n= nums.length;\n        // base case\n        List<Integer> temp = new ArrayList<>();\n        for(int i: nums)\n            temp.add(i);\n\n\n        for(int i=1;i<n;i++){\n            \n            List<Integer> next = new ArrayList<>();\n            for(int j=0;j<n-i;j++)\n            {\n                int summ = (temp.get(j) + temp.get(j+1))%10;\n                next.add(summ);\n            }\n            temp=next;\n        }\n        return temp.get(0);\n    }\n}",
    "title_slug": "find-triangular-sum-of-an-array",
    "problem_url": "https://leetcode.com/problems/find-triangular-sum-of-an-array/"
  },
  {
    "question_id": 119,
    "code": "class Solution {\n    public List<Integer> getRow(int rowIndex) {\n        rowIndex++;\n        List<Integer> ans= new ArrayList<Integer>();\n        long res=1;\n        ans.add((int)res);\n        for(int i=1;i<rowIndex;i++){\n            res*= rowIndex-i;\n            res/= i;\n            ans.add((int)res);\n        }\n        \n        return ans;\n    }\n}",
    "title_slug": "pascals-triangle-ii",
    "problem_url": "https://leetcode.com/problems/pascals-triangle-ii/"
  },
  {
    "question_id": 118,
    "code": "class Solution {\n    public List<List<Integer>> generate(int n) {\n        List<List<Integer>> ans= new ArrayList<>();\n\n        for(int i=0;i<n;i++){\n            List<Integer> row= new ArrayList<>();\n            if(i==0)\n                row.add(1);\n            else\n                for(int j=0;j<i+1;j++){\n                    \n                    if(j==0 || j==i )\n                        row.add(1);\n                    else{\n                        int side= ans.get(i-1).get(j-1);\n                        int up= ans.get(i-1).get(j);\n                        row.add(side+up);\n                    }\n                }\n\n            ans.add(row);\n        }\n\n        return ans;\n    }\n}",
    "title_slug": "pascals-triangle",
    "problem_url": "https://leetcode.com/problems/pascals-triangle/"
  },
  {
    "question_id": 73,
    "code": "class Solution {\n    public void setZeroes(int[][] mat) {\n        int firstrow=-1;\n        int r= mat.length;\n        int c=mat[0].length;\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                if(mat[i][j]==0){\n                    mat[i][0]=0;\n                    if(j==0)\n                        firstrow=0;\n                    else\n                        mat[0][j]=0;\n                }\n            }\n        }\n\n        for(int i=1;i<r;i++){\n            for(int j=1;j<c;j++){\n                if(mat[0][j]==0 || mat[i][0]==0){\n                    mat[i][j]=0;\n                }\n            }\n        }\n\n        if(mat[0][0]==0)\n        for(int i=0;i<c;i++)\n            mat[0][i]=0;\n        \n\n        if(firstrow==0)\n        for(int j=0;j<r;j++)\n            mat[j][0]=0;\n\n    }\n}",
    "title_slug": "set-matrix-zeroes",
    "problem_url": "https://leetcode.com/problems/set-matrix-zeroes/"
  },
  {
    "question_id": 73,
    "code": "class Solution {\n    public void setZeroes(int[][] mat) {\n        int r= mat.length;\n        int c=mat[0].length;\n        boolean[] row= new boolean[r];\n        boolean[] col= new boolean[c];\n\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                if(mat[i][j]==0){\n                    row[i]=true;\n                    col[j]=true;\n                }\n            }\n        }\n\n        for(int i=0;i<r;i++){\n            for(int j=0;j<c;j++){\n                if(row[i]==true || col[j]==true){\n                   mat[i][j]=0;\n                }\n            }\n        }\n    }\n}",
    "title_slug": "set-matrix-zeroes",
    "problem_url": "https://leetcode.com/problems/set-matrix-zeroes/"
  },
  {
    "question_id": 416,
    "code": "class Solution {\n    //revist needed\n    public boolean canPartition(int[] nums) {\n        int sum=0;\n        int n= nums.length;\n        for(int i=0;i<nums.length;i++){\n            sum+=nums[i];\n        }\n        int target=sum/2;\n        if(sum%2!=0)\n            return false;\n        boolean[] prev= new boolean[target+1];\n        \n        prev[0]=true;\n        if(nums[0]<=target)\n            prev[nums[0]]=true;\n\n        for(int i=1;i<n;i++){\n            boolean[] cur= new boolean[target+1];\n            cur[0]=true;\n            for(int j=1;j<=target;j++){\n                boolean notpick= prev[j];\n                boolean pick=false;\n                if(nums[i]<=j)\n                   pick= prev[j-nums[i]];\n\n                cur[j]= pick || notpick;\n          \n            }\n\n            prev=cur;\n        }\n\n        return prev[target];\n    }\n}",
    "title_slug": "partition-equal-subset-sum",
    "problem_url": "https://leetcode.com/problems/partition-equal-subset-sum/"
  },
  {
    "question_id": 967,
    "code": "class Solution {\n    public int minFallingPathSum(int[][] matrix) {\n        int row= matrix.length;\n        int col= matrix[0].length;\n        int[] prev= new int[row];\n        for(int i=0;i<row;i++)\n            prev[i]=matrix[0][i];\n        \n        for(int m=1;m<row;m++){\n            int[] cur= new int[row];\n            for(int n=0;n<col;n++){\n                int val=Integer.MAX_VALUE;\n                for(int j=-1;j<=1;j++){\n                    if(n+j>=0 && n+j<col)\n                        val= Math.min(\n                            matrix[m][n]+prev[n+j], val);\n                }\n                cur[n]=val;\n            }\n            prev=cur;\n        }\n        int minval=Integer.MAX_VALUE;\n        for(int i=0;i<col;i++){\n            minval=Math.min(prev[i],minval);\n        }\n        return minval;\n    }\n}",
    "title_slug": "minimum-falling-path-sum",
    "problem_url": "https://leetcode.com/problems/minimum-falling-path-sum/"
  },
  {
    "question_id": 967,
    "code": "class Solution {\n    int helper(int[][] mat, int m,int n,int[][] dp){\n        if(m<0 || m>= mat.length || n<0 || n>= mat[0].length){\n            return Integer.MAX_VALUE;\n        }\n        if(m==0){\n            return mat[m][n];\n        }\n        if(dp[m][n]!=-1)\n            return dp[m][n];\n\n        int ans=Integer.MAX_VALUE;\n        \n        for(int j=-1;j<=1;j++){\n                if(m-1>=0 && n+j>=0 && n+j<mat[0].length)\n                    ans= Math.min(\n                        mat[m][n]+helper(mat,m-1,n+j,dp), ans\n                    );\n        }\n\n        return dp[m][n]=ans;\n    }\n    public int minFallingPathSum(int[][] matrix) {\n        int row= matrix.length;\n        int col= matrix[0].length;\n        int[][] dp = new int[row][col];\n        for(int i=0;i<row;i++)\n            dp[0][i]=matrix[0][i];\n\n        for(int m=1;m<row;m++){\n            for(int n=0;n<col;n++){\n                int val=Integer.MAX_VALUE;\n                for(int j=-1;j<=1;j++){\n                    if(n+j>=0 && n+j<col)\n                        val= Math.min(\n                            matrix[m][n]+dp[m-1][n+j], val);\n                }\n                dp[m][n]=val;\n            }\n        }\n        int minval=Integer.MAX_VALUE;\n        for(int i=0;i<col;i++){\n            minval=Math.min(dp[row-1][i],minval);\n        }\n        return minval;\n    }\n}",
    "title_slug": "minimum-falling-path-sum",
    "problem_url": "https://leetcode.com/problems/minimum-falling-path-sum/"
  },
  {
    "question_id": 967,
    "code": "class Solution {\n    int helper(int[][] mat, int m,int n,int[][] dp){\n        if(m<0 || m>= mat.length || n<0 || n>= mat[0].length){\n            return Integer.MAX_VALUE;\n        }\n        if(m==0){\n            return mat[m][n];\n        }\n        if(dp[m][n]!=-1)\n            return dp[m][n];\n\n        int ans=Integer.MAX_VALUE;\n        \n        for(int j=-1;j<=1;j++){\n                if(m-1>=0 && n+j>=0 && n+j<mat[0].length)\n                    ans= Math.min(\n                        mat[m][n]+helper(mat,m-1,n+j,dp), ans\n                    );\n        }\n\n        return dp[m][n]=ans;\n    }\n    public int minFallingPathSum(int[][] matrix) {\n        int row= matrix.length;\n        int col= matrix[0].length;\n        int[][] dp = new int[row][col];\n        // for(int[] d:dp)\n        //     Arrays.fill(d,-1);\n\n        for(int i=0;i<row;i++)\n            dp[0][i]=matrix[0][i];\n        \n        // for(int i=0;i<matrix[0].length;i++){\n        // int val=helper(matrix,matrix.length-1,i,dp);\n        //  for(int j=-1;j<=1;j++){\n        //         if(m-1>=0 && n+j>=0 && n+j<mat[0].length)\n        //             ans= Math.min(\n        //                 mat[m][n]+helper(mat,m-1,n+j,dp), ans\n        //             );\n        // }\n        // minval=Math.min(minval,val);\n        // }\n\n\n        for(int m=1;m<row;m++){\n            for(int n=0;n<col;n++){\n                int val=Integer.MAX_VALUE;\n                for(int j=-1;j<=1;j++){\n                    if(n+j>=0 && n+j<col)\n                        val= Math.min(\n                            matrix[m][n]+dp[m-1][n+j], val);\n                }\n                dp[m][n]=val;\n            }\n        }\n        int minval=Integer.MAX_VALUE;\n        for(int i=0;i<col;i++){\n            minval=Math.min(dp[row-1][i],minval);\n        }\n        return minval;\n    }\n}",
    "title_slug": "minimum-falling-path-sum",
    "problem_url": "https://leetcode.com/problems/minimum-falling-path-sum/"
  },
  {
    "question_id": 3075,
    "code": "import pandas as pd\n\ndef dropMissingData(students: pd.DataFrame) -> pd.DataFrame:\n    students.dropna(axis=0,how='any',inplace=True,subset=['name'])\n    return students",
    "title_slug": "drop-missing-data",
    "problem_url": "https://leetcode.com/problems/drop-missing-data/"
  },
  {
    "question_id": 416,
    "code": "class Solution {\n    //revist needed\n    public boolean canPartition(int[] nums) {\n        int sum=0;\n        int n= nums.length;\n        for(int i=0;i<nums.length;i++){\n            sum+=nums[i];\n        }\n        int target=sum/2;\n        if(sum%2!=0)\n            return false;\n        boolean[] prev= new boolean[target+1];\n        \n        prev[0]=true;\n        if(nums[0]<=target)\n            prev[nums[0]]=true;\n\n        for(int i=1;i<n;i++){\n            boolean[] cur= new boolean[target+1];\n            cur[0]=true;\n            for(int j=1;j<=target;j++){\n                boolean notpick= prev[j];\n                boolean pick=false;\n                if(nums[i]<=j)\n                   pick= prev[j-nums[i]];\n\n                cur[j]= pick || notpick;\n          \n            }\n\n            prev=cur;\n        }\n\n        return prev[target];\n    }\n}",
    "title_slug": "partition-equal-subset-sum",
    "problem_url": "https://leetcode.com/problems/partition-equal-subset-sum/"
  },
  {
    "question_id": 416,
    "code": "class Solution {\n    public boolean canPartition(int[] nums) {\n        int sum=0;\n        int n= nums.length;\n        for(int i=0;i<nums.length;i++){\n            sum+=nums[i];\n        }\n        int target=sum/2;\n        if(sum%2!=0)\n            return false;\n        boolean[][] dp = new boolean[n][target+1];\n        \n        for(int i=0;i<n;i++){\n            dp[i][0]=true;\n        }\n        \n        if(nums[0]<=target)\n            dp[0][nums[0]]=true;\n\n        for(int i=1;i<n;i++){\n            for(int j=0;j<=target;j++){\n                boolean notpick= dp[i-1][j];\n                boolean pick=false;\n                if(nums[i]<=j)\n                   pick= dp[i-1][j-nums[i]];\n\n                dp[i][j]= pick || notpick;\n          \n            }\n        }\n\n        return dp[n-1][target];\n    }\n}",
    "title_slug": "partition-equal-subset-sum",
    "problem_url": "https://leetcode.com/problems/partition-equal-subset-sum/"
  },
  {
    "question_id": 416,
    "code": "class Solution {\n    public boolean canPartition(int[] nums) {\n        int sum=0;\n        int n= nums.length;\n        for(int i=0;i<nums.length;i++){\n            sum+=nums[i];\n        }\n        int target=sum/2;\n        if(sum%2!=0)\n            return false;\n        boolean[][] dp = new boolean[n][target+1];\n        \n        for(int i=0;i<n;i++){\n            dp[i][0]=true;\n        }\n        \n        if(nums[0]<=target)\n            dp[0][nums[0]]=true;\n\n        for(int i=1;i<n;i++){\n            for(int j=0;j<=target;j++){\n                boolean notpick= dp[i-1][j];\n                boolean pick=false;\n                if(nums[i]<=j)\n                   pick= dp[i-1][j-nums[i]];\n\n                dp[i][j]= pick || notpick;\n          \n            }\n        }\n\n        return dp[n-1][target];\n    }\n}",
    "title_slug": "partition-equal-subset-sum",
    "problem_url": "https://leetcode.com/problems/partition-equal-subset-sum/"
  },
  {
    "question_id": 416,
    "code": "class Solution {\n    boolean helper(int[] arr,int i,int target,int[][] dp){\n        if(target==0)\n            return true;\n        if(i==0)\n            return arr[0]==target;\n        if(dp[i][target]!=-1)\n            return dp[i][target]==0?false:true;\n        \n        boolean notpick = helper(arr,i-1,target,dp);\n        boolean pick = false;\n        if(arr[i]<=target)\n            pick=helper(arr,i-1,target-arr[i],dp);\n        \n        dp[i][target] = notpick || pick ? 1 : 0;\n\n        return notpick || pick;\n    }\n    public boolean canPartition(int[] nums) {\n        int sum=0;\n        int n= nums.length;\n        for(int i=0;i<nums.length;i++){\n            sum+=nums[i];\n        }\n        int target=sum/2;\n        if(sum%2!=0)\n            return false;\n        int[][] dp = new int[n][target+1];\n        for(int[] a:dp)\n            Arrays.fill(a,-1);\n        return helper(nums,n-1,target,dp);\n        // boolean[][] dp = new boolean[n][target+1];\n        \n        // for(int i=0;i<target+1;i++){\n        //     dp[0][i]=true;\n        // }\n        \n        // for(int i=1;i<n;i++){\n        //     for(int j=0;j<=target;j++){\n        //         boolean notpick= dp[i-1][j];\n        //         boolean pick=false;\n        //         if(nums[i]<=j)\n        //            pick= dp[i-1][j-nums[i]];\n\n        //         dp[i][j]= pick | notpick;            \n        //     }\n        // }\n\n        // return dp[n-1][target];\n    }\n}",
    "title_slug": "partition-equal-subset-sum",
    "problem_url": "https://leetcode.com/problems/partition-equal-subset-sum/"
  },
  {
    "question_id": 64,
    "code": "class Solution {\n    int helper(int[][] grid,int m,int n,int cursum,int[][] dp){\n\n        \n        if(m==0 && n==0){\n            return grid[m][n];\n        }\n\n        if(m<0 || n< 0){\n            // return any large number to negelect it\n            return Integer.MAX_VALUE;\n        }\n\n        if(dp[m][n]!=-1)\n            return dp[m][n];\n\n        int up= helper(grid,m-1,n,cursum,dp);\n        int right= helper(grid,m,n-1,cursum,dp);\n        return dp[m][n]=Math.min(up,right)+ grid[m][n];\n    }\n    public int minPathSum(int[][] grid) {\n        int m= grid.length;\n        int n= grid[0].length;\n\n        int[][] dp= new int[m][n];\n        for(int[] d : dp)\n            Arrays.fill(d,-1);\n        return helper(grid,m-1,n-1,0,dp);\n        \n    }\n}",
    "title_slug": "minimum-path-sum",
    "problem_url": "https://leetcode.com/problems/minimum-path-sum/"
  },
  {
    "question_id": 120,
    "code": "class Solution {\n    \n    public int minimumTotal(List<List<Integer>> triangle) {\n        int n = triangle.size();\n        if(n==0)\n            return 0;\n        int[][] dp= new int[n][];\n        for(int i=0;i<n;i++){\n            dp[i]= new int[i+1];\n            // Arrays.fill(dp[i],-1);\n        }\n        dp[0][0]= triangle.get(0).get(0);\n\n        for(int i=1;i<n;i++){\n\n            for(int j=0;j<i+1;j++){\n                if(j==0){\n                    //up add.\n                    dp[i][j]= triangle.get(i).get(j) + dp[i-1][j];\n                }else{\n                    int side=dp[i-1][j-1];\n                    int up=Integer.MAX_VALUE;\n                    if(dp[i-1].length>j)\n                        up=dp[i-1][j];\n\n                    dp[i][j]= triangle.get(i).get(j) + Math.min(up,side);\n                }\n            }\n        }\n        \n        int sum= Integer.MAX_VALUE;\n        for(int i=0;i<dp[n-1].length;i++){\n            sum= Math.min(sum,dp[n-1][i]);\n        }\n        return sum;\n    }\n}",
    "title_slug": "triangle",
    "problem_url": "https://leetcode.com/problems/triangle/"
  },
  {
    "question_id": 120,
    "code": "class Solution {\n    \n    public int minimumTotal(List<List<Integer>> triangle) {\n        int n = triangle.size();\n        if(n==0)\n            return 0;\n        int[][] dp= new int[n][];\n        for(int i=0;i<n;i++){\n            dp[i]= new int[i+1];\n            // Arrays.fill(dp[i],-1);\n        }\n        dp[0][0]= triangle.get(0).get(0);\n\n        for(int i=1;i<n;i++){\n\n            for(int j=0;j<i+1;j++){\n                if(j==0){\n                    //up add.\n                    dp[i][j]= triangle.get(i).get(j) + dp[i-1][j];\n                }else{\n                    int side=dp[i-1][j-1];\n                    int up=Integer.MAX_VALUE;\n                    if(dp[i-1].length>j)\n                        up=dp[i-1][j];\n\n                    dp[i][j]= triangle.get(i).get(j) + Math.min(up,side);\n                }\n            }\n        }\n        \n        int sum= Integer.MAX_VALUE;\n        for(int i=0;i<dp[n-1].length;i++){\n            sum= Math.min(sum,dp[n-1][i]);\n        }\n        return sum;\n    }\n}",
    "title_slug": "triangle",
    "problem_url": "https://leetcode.com/problems/triangle/"
  },
  {
    "question_id": 64,
    "code": "class Solution {\n    int helper(int[][] grid,int m,int n,int cursum,int[][] dp){\n\n        \n        if(m==0 && n==0){\n            return grid[m][n];\n        }\n\n        if(m<0 || n< 0){\n            // return any large number to negelect it\n            return Integer.MAX_VALUE;\n        }\n\n        if(dp[m][n]!=-1)\n            return dp[m][n];\n\n        int up= helper(grid,m-1,n,cursum,dp);\n        int right= helper(grid,m,n-1,cursum,dp);\n        return dp[m][n]=Math.min(up,right)+ grid[m][n];\n    }\n    public int minPathSum(int[][] grid) {\n        int m= grid.length;\n        int n= grid[0].length;\n\n        int[][] dp= new int[m][n];\n        for(int[] d : dp)\n            Arrays.fill(d,-1);\n        return helper(grid,m-1,n-1,0,dp);\n        \n    }\n}",
    "title_slug": "minimum-path-sum",
    "problem_url": "https://leetcode.com/problems/minimum-path-sum/"
  },
  {
    "question_id": 63,
    "code": "class Solution {\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int m = obstacleGrid.length;\n        int n =obstacleGrid[0].length;\n         int[][] dp = new int[m][n];\n\n        for(int[] d: dp){\n            Arrays.fill(d,-1);\n        }\n         \n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(obstacleGrid[i][j]==1)\n                    dp[i][j]=0;\n                else if(i==0 && j==0)\n                    dp[0][0]=1;\n                else{\n                    int up=0,right=0;\n                    if(i>0) up=dp[i-1][j];\n                    if(j>0) right=dp[i][j-1];\n                    dp[i][j]= up + right;\n                }\n            }\n        }\n\n        return dp[m-1][n-1];\n    }\n}",
    "title_slug": "unique-paths-ii",
    "problem_url": "https://leetcode.com/problems/unique-paths-ii/"
  },
  {
    "question_id": 62,
    "code": "class Solution {\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n\n        for(int[] d: dp){\n            Arrays.fill(d,-1);\n        }\n        \n        for(int i=0;i<m;i++){\n            for(int j=0;j<n;j++){\n                if(i==0 && j==0)\n                    dp[0][0]=1;\n                else{\n                    int up=0,right=0;\n                    if(i>0) up=dp[i-1][j];\n                    if(j>0) right=dp[i][j-1];\n                    dp[i][j]= up + right;\n                }\n            }\n        }\n\n        return dp[m-1][n-1];\n    }\n}",
    "title_slug": "unique-paths",
    "problem_url": "https://leetcode.com/problems/unique-paths/"
  },
  {
    "question_id": 62,
    "code": "class Solution {\n    int helper(int[][] dp,int m,int n){\n        if(m==0 && n==0)\n            return 1;\n        if(m<0 || n<0)\n            return 0;\n        \n        if(dp[m][n]!=-1)\n            return dp[m][n];\n        \n        int up = helper(dp,m,n-1);\n        int right= helper(dp,m-1,n);\n\n        return dp[m][n]= up+right;\n    }\n    public int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n\n        for(int[] d: dp){\n            Arrays.fill(d,-1);\n        }\n        \n        \n        return helper(dp,m-1,n-1);\n    }\n}",
    "title_slug": "unique-paths",
    "problem_url": "https://leetcode.com/problems/unique-paths/"
  },
  {
    "question_id": 3071,
    "code": "import pandas as pd\n\ndef dropDuplicateEmails(customers: pd.DataFrame) -> pd.DataFrame:\n    customers.drop_duplicates(subset='email',keep='first',inplace=True)\n    return customers",
    "title_slug": "drop-duplicate-rows",
    "problem_url": "https://leetcode.com/problems/drop-duplicate-rows/"
  },
  {
    "question_id": 3066,
    "code": "import pandas as pd\n\ndef createBonusColumn(employees: pd.DataFrame) -> pd.DataFrame:\n    employees['bonus'] = employees['salary'] * 2\n    return employees",
    "title_slug": "create-a-new-column",
    "problem_url": "https://leetcode.com/problems/create-a-new-column/"
  },
  {
    "question_id": 3074,
    "code": "import pandas as pd\n\ndef selectData(students: pd.DataFrame) -> pd.DataFrame:\n    return students[students['student_id']==101][['name','age']]",
    "title_slug": "select-data",
    "problem_url": "https://leetcode.com/problems/select-data/"
  },
  {
    "question_id": 213,
    "code": "class Solution {\n    int helper(int[] nums,int start,int end){\n          int prev2=0; // i-2\n        int prev1=nums[start]; //i-1\n        for(int i=start+1;i<=end;i++){\n            int pick= nums[i] + prev2;\n            int notpick= prev1;\n            int max=Math.max(pick,notpick);\n            prev2=prev1;\n            prev1=max;\n        }\n        return prev1;\n    }\n    public int rob(int[] nums) {\n        int n=nums.length;\n        if(n==1)\n            return nums[0];\n       return Math.max(\n           helper(nums,0,n-2),helper(nums,1,n-1)\n        );\n    }\n}",
    "title_slug": "house-robber-ii",
    "problem_url": "https://leetcode.com/problems/house-robber-ii/"
  },
  {
    "question_id": 198,
    "code": "class Solution {\n    public int rob(int[] nums) {\n        int prev2=0; // i-2\n        int prev1=nums[0]; //i-1\n        for(int i=1;i<nums.length;i++){\n            int pick= nums[i] + prev2;\n            int notpick= prev1;\n\n            int max=Math.max(pick,notpick);\n            prev2=prev1;\n            prev1=max;\n        }\n        return prev1;\n    }\n}",
    "title_slug": "house-robber",
    "problem_url": "https://leetcode.com/problems/house-robber/"
  },
  {
    "question_id": 1029,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    static void helper(TreeNode temp,int level, int vertical,\n        TreeMap < Integer, TreeMap < Integer, PriorityQueue < Integer >>> map){\n        if(temp==null){\n            return;\n        }\n\n        // if vertical does not exist create one\n        if(!map.containsKey(vertical))\n            map.put(vertical,new TreeMap<>());\n        // check if the current level exist in the map\n        if(!map.get(vertical).containsKey(level)){\n            map.get(vertical).put(level,new PriorityQueue<>());\n        }\n\n        map.get(vertical).get(level).offer(temp.val);\n\n        helper(temp.left,level+1,vertical-1,map);\n        helper(temp.right,level+1,vertical+1,map);\n    }\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        \n        // using tree map to store values in ascending order of the verticals\n        // using priority queue to poll elements in ascending order of the level and if its same then ascending order of val\n        TreeMap < Integer, TreeMap < Integer, PriorityQueue < Integer >>> map = new TreeMap < > ();\n        helper(root,0,0,map);\n        List < List < Integer >> list = new ArrayList < > ();\n        for (TreeMap < Integer, PriorityQueue < Integer >> outerVal: map.values()) {\n            list.add(new ArrayList < > ());\n            for (PriorityQueue < Integer > innerVal: outerVal.values()) {\n                while (!innerVal.isEmpty()) {\n                    // add elements in the last 'list' of list\n                    list.get(list.size() - 1).add(innerVal.poll());\n                }\n            }\n        }\n        return list;\n    }\n}\n\n// ArrayList<Integer> valueList=hm.get(level);\n        // if(valueList==null)\n        //     valueList= new ArrayList<>();\n        // valueList.add(temp.val);\n        // hm.put(level,valueList);",
    "title_slug": "vertical-order-traversal-of-a-binary-tree",
    "problem_url": "https://leetcode.com/problems/vertical-order-traversal-of-a-binary-tree/"
  },
  {
    "question_id": 103,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    // dfs method and not so obvious but interesting\n  public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n     List<List<Integer>> result = new ArrayList<>();\n        helper(result,0,root);\n        return result;\n    }\n    // for better understanding create a recursion tree. \n    void helper(List<List<Integer>> result, int level,TreeNode temp){\n        if(temp==null){\n            return;\n        }\n\n        // for first call of every level add the list\n        // this statement will be excuted first and is capabale to \n        // create list in the correct sequence thanks to recursion\n        if(level==result.size()){\n            result.add(new ArrayList<Integer>());\n        }\n\n        // add the value to result at the current level.\n        // if odd then add at the start (to inverse)\n        if(level%2==0)\n            result.get(level).add(temp.val);\n        else\n            result.get(level).add(0,temp.val);\n\n\n        helper(result,level+1,temp.left);\n        helper(result,level+1,temp.right);\n    }\n}",
    "title_slug": "binary-tree-zigzag-level-order-traversal",
    "problem_url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/"
  },
  {
    "question_id": 102,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        helper(result,0,root);\n        return result;\n    }\n    // for better understanding create a recursion tree. (kinda love the intuition)\n    void helper(List<List<Integer>> result, int level,TreeNode temp){\n        if(temp==null){\n            return;\n        }\n\n        // for first call of every level add the list\n        // this statement will be excuted first and is capabale to \n        // create list in the correct sequence thanks to recursion\n        if(level==result.size()){\n            result.add(new ArrayList<Integer>());\n        }\n\n        // add the value to result at the current level.\n        result.get(level).add(temp.val);\n\n        helper(result,level+1,temp.left);\n        helper(result,level+1,temp.right);\n    }\n}",
    "title_slug": "binary-tree-level-order-traversal",
    "problem_url": "https://leetcode.com/problems/binary-tree-level-order-traversal/"
  },
  {
    "question_id": 103,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    // simpler method and obvious one\n  public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n    Queue<TreeNode> q = new LinkedList<>();\n    List<List<Integer>> f = new ArrayList<>();\n    if (root == null) {\n      return f;\n    }\n    TreeNode curr = root;\n    q.add(root);\n    int c = 0, sz = 0;\n    while (!q.isEmpty()) \n    {\n      \n      sz = q.size();\n      List<Integer> ans = new ArrayList<>();\n      for (int i = 0; i < sz; i++) \n      {\n        q.poll();\n        ans.add(curr.val);\n        \n          if (curr.left != null)\n            q.add(curr.left);\n          if (curr.right != null)\n            q.add(curr.right);\n          curr=q.peek();\n      }\n        if(c%2!=0)\n        {\n          Collections.reverse(ans);\n        }\n      f.add(ans);\n      c++;\n    }\n    return f;\n  }\n}",
    "title_slug": "binary-tree-zigzag-level-order-traversal",
    "problem_url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/"
  },
  {
    "question_id": 103,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        Stack<TreeNode>  leftFirstStack = new Stack<TreeNode>();\n        Stack<TreeNode>  rightFirstStack = new Stack<TreeNode>();\n        boolean direction=true; // true for left first insertion\n        if(root!=null)\n            rightFirstStack.push(root);\n        \n        while(!rightFirstStack.isEmpty() || !leftFirstStack.isEmpty()){\n            if(direction){\n                List<Integer> ls = new ArrayList<>();\n                while(!rightFirstStack.isEmpty()){\n                    TreeNode node = rightFirstStack.pop();\n                    ls.add(node.val);\n                    if(node.left!=null)\n                        leftFirstStack.push(node.left);\n                    if(node.right!=null)\n                        leftFirstStack.push(node.right);\n                }\n                result.add(ls);\n            }else{\n                List<Integer> ls = new ArrayList<>();\n                while(!leftFirstStack.isEmpty()){\n                    TreeNode node = leftFirstStack.pop();\n                    ls.add(node.val);\n                    if(node.right!=null)\n                        rightFirstStack.push(node.right);\n                    if(node.left!=null)\n                        rightFirstStack.push(node.left);\n                }\n                result.add(ls);\n            }\n\n            direction = !direction;\n        }\n\n        return result;\n    }\n}",
    "title_slug": "binary-tree-zigzag-level-order-traversal",
    "problem_url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/"
  },
  {
    "question_id": 124,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int maxsum;\n    int helper(TreeNode temp) {\n        if(temp==null){\n            return 0;\n        }\n\n        int left = Math.max(0,helper(temp.left));\n        int right = Math.max(0,helper(temp.right));\n        int sum= left+right+temp.val;\n        maxsum= Math.max(sum,maxsum);\n        \n       return Math.max(left,right)+temp.val;\n    }\n    public int maxPathSum(TreeNode root) {\n        maxsum=root.val;\n        helper(root);\n        return maxsum;\n    }\n}",
    "title_slug": "binary-tree-maximum-path-sum",
    "problem_url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/"
  },
  {
    "question_id": 543,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int maxdia=0;\n    int helper(TreeNode root){\n        if(root==null)\n            return 0;\n\n\n        int left = helper(root.left);\n        int right = helper(root.right);\n        int dia = left +right;\n        maxdia= Math.max(dia,maxdia);\n        return Math.max(left,right)+1;\n    }\n    public int diameterOfBinaryTree(TreeNode root) {\n        helper(root);\n        return maxdia;\n    }\n}",
    "title_slug": "diameter-of-binary-tree",
    "problem_url": "https://leetcode.com/problems/diameter-of-binary-tree/"
  },
  {
    "question_id": 3065,
    "code": "import pandas as pd\n\ndef selectFirstRows(employees: pd.DataFrame) -> pd.DataFrame:\n    return employees.head(3)",
    "title_slug": "display-the-first-three-rows",
    "problem_url": "https://leetcode.com/problems/display-the-first-three-rows/"
  },
  {
    "question_id": 3076,
    "code": "import pandas as pd\n\ndef getDataframeSize(players: pd.DataFrame) -> List[int]:\n    return list(players.shape)",
    "title_slug": "get-the-size-of-a-dataframe",
    "problem_url": "https://leetcode.com/problems/get-the-size-of-a-dataframe/"
  },
  {
    "question_id": 100,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if(p==null && q==null){\n            return true;\n        }\n\n        if(p==null || q==null){\n            return false;\n        }\n\n        if(p.val!= q.val){\n            return false;\n        }\n\n        return isSameTree(p.left,q.left) && isSameTree(p.right,q.right);\n    }\n}",
    "title_slug": "same-tree",
    "problem_url": "https://leetcode.com/problems/same-tree/"
  },
  {
    "question_id": 169,
    "code": "class Solution {\n    public int majorityElement(int[] nums) {\n       int num=nums[0];\n       int count=1;\n       for(int i=1;i<nums.length;i++){\n           if(num==nums[i]){\n               count++;\n           }\n           else count--;\n\n           if(count==0){\n               num=nums[i];\n               count=1;\n           }\n       }\n       return num;\n    }\n}",
    "title_slug": "majority-element",
    "problem_url": "https://leetcode.com/problems/majority-element/"
  },
  {
    "question_id": 1360,
    "code": "class Solution {\n    //? first solution\n    int helper(String str, List<String> arr,int index){\n        if(arr.size()==index){\n            return str.length(); \n        }\n        boolean possibleConcat=true;\n        for(int i=0;i<arr.get(index).length();i++){\n            if(str.contains(arr.get(index).charAt(i) +\"\"))\n                possibleConcat=false;\n            \n        }\n\n        if(!possibleConcat){\n            return helper(str,arr,index+1);\n        }\n        int with=helper(str+arr.get(index),arr,index+1);\n        int without=helper(str,arr,index+1);\n        return Math.max(with,without);\n        \n    }\n    public int maxLength(List<String> arr) {\n        \n        Iterator<String> iterator = arr.iterator();\n\n        while (iterator.hasNext()) {\n        String str = iterator.next();\n        boolean[] alpha = new boolean[26];\n        \n            for (int i = 0; i < str.length(); i++) {\n                int index = str.charAt(i) - 'a';\n                if (alpha[index]) {\n                    iterator.remove();\n                    break; \n                } else {\n                    alpha[index] = true;\n                }\n            }\n        }\n        if(arr.size()==0)\n            return 0;\n        return helper(\"\",arr,0);\n\n    }\n}",
    "title_slug": "maximum-length-of-a-concatenated-string-with-unique-characters",
    "problem_url": "https://leetcode.com/problems/maximum-length-of-a-concatenated-string-with-unique-characters/"
  },
  {
    "question_id": 169,
    "code": "class Solution {\n    public int majorityElement(int[] nums) {\n       Arrays.sort(nums);\n       int num=nums[0];\n       int maxNumInd=0;\n        int maxNum=nums[0];\n       int numInd=1;\n    \n        for(int i=1;i<nums.length;i++){\n            if(nums[i]==num){\n                numInd++;\n            }else{\n               numInd=1;\n                num=nums[i];\n            }\n\n            if(numInd>maxNumInd){\n                    maxNumInd=numInd;\n                    maxNum=num;\n            }\n        }\n        return maxNum;\n    }\n}",
    "title_slug": "majority-element",
    "problem_url": "https://leetcode.com/problems/majority-element/"
  },
  {
    "question_id": 75,
    "code": "class Solution {\n    public void sortColors(int[] nums) {\n        \n        int start=0;\n        int end= nums.length-1;\n        while(start<end){\n            if(nums[start]!=2){\n                start++;\n                continue;\n            }\n            if(nums[end]==2){\n                end--; continue;\n            }\n            int temp= nums[start];\n            nums[start]=nums[end];\n            nums[end]=temp;\n            start++; end--;\n        }\n\n        start=0;\n        while(start<=end){\n            if(nums[end]!=0){\n                end--;\n                continue;\n            }\n            if(nums[start]==0){\n                start++; continue;\n            }\n            int temp= nums[start];\n            nums[start]=nums[end];\n            nums[end]=temp;\n            start++; end--;\n        }\n    }\n}",
    "title_slug": "sort-colors",
    "problem_url": "https://leetcode.com/problems/sort-colors/"
  },
  {
    "question_id": 3062,
    "code": "import pandas as pd\n\ndef createDataframe(student_data: List[List[int]]) -> pd.DataFrame:\n    column_name= ['student_id','age']\n\n    result= pd.DataFrame(student_data,columns=column_name)\n    return result",
    "title_slug": "create-a-dataframe-from-list",
    "problem_url": "https://leetcode.com/problems/create-a-dataframe-from-list/"
  },
  {
    "question_id": 102,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n         if (root == null) \n            return new LinkedList<List<Integer>>(); \n        \n        Queue<TreeNode> q= new LinkedList<TreeNode>();\n        q.offer(root);\n\n        List<List<Integer>> outer= new LinkedList<List<Integer>>();\n        while(!q.isEmpty()){\n            int n= q.size();\n            List<Integer> inner = new LinkedList<Integer>();\n\n            for(int i=0;i<n;i++){\n                TreeNode node = q.peek();\n                inner.add(q.poll().val);\n                if(node.left!=null)\n                    q.offer(node.left);\n                if(node.right!=null)\n                    q.offer(node.right);\n            }\n            outer.add(inner);\n        }\n        return outer;\n    }\n}",
    "title_slug": "binary-tree-level-order-traversal",
    "problem_url": "https://leetcode.com/problems/binary-tree-level-order-traversal/"
  },
  {
    "question_id": 206,
    "code": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    ListNode helper(ListNode prev,ListNode temp){\n        if(temp.next==null){\n            temp.next=prev;\n            return temp;\n        }\n        ListNode nextNode=temp.next;\n        temp.next=prev;\n        return helper(temp,nextNode);\n    }\n    public ListNode reverseList(ListNode head) {\n        if(head==null) return head;\n        return helper(null,head);\n    }\n}",
    "title_slug": "reverse-linked-list",
    "problem_url": "https://leetcode.com/problems/reverse-linked-list/"
  },
  {
    "question_id": 98,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    \n    private boolean helper(TreeNode temp,long left_range, long right_range) {\n         if(temp==null)\n            return true;\n        \n        if(temp.val<=left_range || temp.val>=right_range)\n            return false;\n        \n        return helper(temp.left,left_range,temp.val) && \n        helper(temp.right,temp.val,right_range);\n    }\n    public boolean isValidBST(TreeNode root) {\n       return helper(root,Long.MIN_VALUE,Long.MAX_VALUE);\n    }\n}",
    "title_slug": "validate-binary-search-tree",
    "problem_url": "https://leetcode.com/problems/validate-binary-search-tree/"
  },
  {
    "question_id": 784,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void helper(TreeNode temp, int val) {\n         if(temp==null)\n            return;\n        \n        if(temp.val>val){\n            if(temp.left==null){\n                TreeNode newNode = new TreeNode(val);\n                temp.left=newNode;\n            }else\n                helper(temp.left,val);\n            \n        }else if(temp.val<val){\n            if(temp.right==null){\n                TreeNode newNode = new TreeNode(val);\n                temp.right=newNode;\n            }else\n                helper(temp.right,val);\n        }\n    }\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if(root==null)\n            root = new TreeNode(val);\n        else\n            helper(root,val);\n       return root;\n    }\n}",
    "title_slug": "insert-into-a-binary-search-tree",
    "problem_url": "https://leetcode.com/problems/insert-into-a-binary-search-tree/"
  },
  {
    "question_id": 110,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    // height belong to {-1,0,1}\n    public int helper(TreeNode node,int height) {\n        if(node==null){\n            return height;\n        }\n        int left_height=helper(node.left,height+1);\n        int right_height=helper(node.right,height+1);\n        if(left_height-right_height>=-1 && left_height-right_height<=1) \n            return Math.max(left_height,right_height);\n        return -1 ;\n    }\n    public boolean isBalanced(TreeNode root) {\n        return helper(root,0)==-1?false:true;\n    }\n}",
    "title_slug": "balanced-binary-tree",
    "problem_url": "https://leetcode.com/problems/balanced-binary-tree/"
  },
  {
    "question_id": 78,
    "code": "class Solution {\n    // This uses backtracking\n    \n    void helper(List<Integer> list,int[] nums,int index,List<List<Integer>> result){\n        if(nums.length==index){\n            result.add(new ArrayList<>(list));\n            return;\n        }\n        \n        helper(list,nums,index+1,result);\n        list.add(nums[index]);\n        helper(list,nums,index+1,result);\n        list.remove(list.size()-1);\n       \n    }\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result= new ArrayList<List<Integer>>();\n        helper(new ArrayList<Integer>(){},nums,0,result);\n        return result;\n    }\n}",
    "title_slug": "subsets",
    "problem_url": "https://leetcode.com/problems/subsets/"
  },
  {
    "question_id": 78,
    "code": "class Solution {\n    // This uses backtracking\n    List<List<Integer>> result;\n    void helper(List<Integer> list,int[] nums,int index){\n        if(nums.length==index){\n            result.add(new ArrayList<>(list));\n            return;\n        }\n        \n        helper(list,nums,index+1);\n        list.add(nums[index]);\n        helper(list,nums,index+1);\n        list.remove(list.size()-1);\n       \n    }\n    public List<List<Integer>> subsets(int[] nums) {\n        result= new ArrayList<List<Integer>>();\n        helper(new ArrayList<Integer>(){},nums,0);\n        return result;\n    }\n}",
    "title_slug": "subsets",
    "problem_url": "https://leetcode.com/problems/subsets/"
  },
  {
    "question_id": 78,
    "code": "class Solution {\n    List<List<Integer>> result;\n    void helper(List<Integer> list,int[] nums){\n        if(nums.length==0){\n            result.add(list);\n            return;\n        }\n        \n        helper(list, Arrays.copyOfRange(nums,1,nums.length));\n        List<Integer> newList= new ArrayList<>(list);\n        newList.add(nums[0]);\n        helper(newList, Arrays.copyOfRange(nums,1,nums.length));\n        \n       \n    }\n    public List<List<Integer>> subsets(int[] nums) {\n        result= new ArrayList<List<Integer>>();\n        helper(new ArrayList<Integer>(){},nums);\n        return result;\n    }\n}",
    "title_slug": "subsets",
    "problem_url": "https://leetcode.com/problems/subsets/"
  },
  {
    "question_id": 88,
    "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n    int[] mix=new int[m+n];\n\n        int i = 0;\n        int j = 0;\n        int k = 0;\n        \n        while(i<m && j<n){\n            if(nums1[i] < nums2[j]){\n                mix[k]=nums1[i];\n                i++;\n            }else{\n                mix[k]=nums2[j];\n                j++;\n            }\n            k++;\n        }\n        while(i < m){\n            mix[k]=nums1[i];\n            i++;\n            k++;\n        }\n        while(j< n){\n            mix[k]=nums2[j];\n            j++;\n            k++;\n        }\n        for(int l=0;l<mix.length;l++){\n            nums1[l]=mix[l];\n        }\n    }\n}",
    "title_slug": "merge-sorted-array",
    "problem_url": "https://leetcode.com/problems/merge-sorted-array/"
  },
  {
    "question_id": 26,
    "code": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int index=1;\n        for(int i=1;i<nums.length;i++){\n            if(nums[i]!=nums[i-1]){\n                nums[index++]= nums[i];\n            }\n        }\n        return index;\n    }\n}",
    "title_slug": "remove-duplicates-from-sorted-array",
    "problem_url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/"
  },
  {
    "question_id": 27,
    "code": "class Solution {                        \n    public int removeElement(int[] nums, int val) {\n        int index=0;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]!=val){\n                nums[index]= nums[i];\n                index++;\n            }\n        }\n        \n        return index;\n    }\n}",
    "title_slug": "remove-element",
    "problem_url": "https://leetcode.com/problems/remove-element/"
  },
  {
    "question_id": 27,
    "code": "class Solution {\n    // brute force\n    public int removeElement(int[] nums, int val) {\n        int counter=0;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==val){\n                nums[i]= -1;\n                counter++;\n            }\n        }\n\n        for(int i=0;i<nums.length;i++){\n            for(int j=0;j<nums.length-1-i;j++){\n                if(nums[j]==-1){\n                    int temp=nums[j];\n                    nums[j]=nums[j+1];\n                    nums[j+1]=temp;\n                }\n            }\n        }\n        return nums.length-counter;\n    }\n}",
    "title_slug": "remove-element",
    "problem_url": "https://leetcode.com/problems/remove-element/"
  },
  {
    "question_id": 2864,
    "code": "/**\n * @param {Object|Array} obj\n * @return {boolean}\n */\nvar isEmpty = function(obj) {\n    return (Object.keys(obj).length === 0)\n};",
    "title_slug": "is-object-empty",
    "problem_url": "https://leetcode.com/problems/is-object-empty/"
  },
  {
    "question_id": 2863,
    "code": "class Calculator {\n    \n    /** \n     * @param {number} value\n     */\n    constructor(value) {\n        this.result=value\n    }\n    \n    /** \n     * @param {number} value\n     * @return {Calculator}\n     */\n    add(value){\n        this.result+=value;\n        return this;\n    }\n    \n    /** \n     * @param {number} value\n     * @return {Calculator}\n     */\n    subtract(value){\n        this.result-=value;\n        return this;\n    }\n    \n    /** \n     * @param {number} value\n     * @return {Calculator}\n     */  \n    multiply(value) {\n        this.result*=value;\n        return this;\n    }\n    \n    /** \n     * @param {number} value\n     * @return {Calculator}\n     */\n    divide(value) {\n        if(value===0)\n            throw new Error(\"Division by zero is not allowed\");\n        \n        this.result/=value;\n        return this;\n    }\n    \n    /** \n     * @param {number} value\n     * @return {Calculator}\n     */\n    power(value) {\n       this.result**=value;\n       return this;\n    }\n    \n    /** \n     * @return {number}\n     */\n    getResult() {\n        return this.result;\n    }\n}",
    "title_slug": "calculator-with-method-chaining",
    "problem_url": "https://leetcode.com/problems/calculator-with-method-chaining/"
  },
  {
    "question_id": 2805,
    "code": "/**\n * @param {number[]} nums\n * @return {void}\n */\nvar ArrayWrapper = function(nums) {\n    this.nums=nums;\n};\n\n/**\n * @return {number}\n */\nArrayWrapper.prototype.valueOf = function() {\n    return this.nums.reduce((sum,num)=> sum+num,0);\n}\n\n/**\n * @return {string}\n */\nArrayWrapper.prototype.toString = function() {\n    return `[${this.nums.join(',')}]`;\n}\n\n/**\n * const obj1 = new ArrayWrapper([1,2]);\n * const obj2 = new ArrayWrapper([3,4]);\n * obj1 + obj2; // 10\n * String(obj1); // \"[1,2]\"\n * String(obj2); // \"[3,4]\"\n */",
    "title_slug": "array-wrapper",
    "problem_url": "https://leetcode.com/problems/array-wrapper/"
  },
  {
    "question_id": 2807,
    "code": "/**\n * @param {Array<Function>} functions\n * @return {Promise<any>}\n */\nvar promiseAll = async function(functions) {\n    return await new Promise((resolve,reject)=>{\n\n        let response_arr=Array(functions.length);\n        let waiting_count=functions.length;\n\n        for(let i=0;i<functions.length;++i){\n            functions[i]()\n            .then((function_result)=>{\n                response_arr[i]=function_result;\n                if(--waiting_count===0) resolve(response_arr);\n            })\n            .catch(reject);\n        }\n    });\n};\n\n/**\n * const promise = promiseAll([() => new Promise(res => res(42))])\n * promise.then(console.log); // [42]\n */",
    "title_slug": "execute-asynchronous-functions-in-parallel",
    "problem_url": "https://leetcode.com/problems/execute-asynchronous-functions-in-parallel/"
  },
  {
    "question_id": 2807,
    "code": "/**\n * @param {Array<Function>} functions\n * @return {Promise<any>}\n */\nvar promiseAll = async function(functions) {\n    return await new Promise((resolve,reject)=>{\n\n        let response_arr=Array(functions.length);\n        let waiting_count=functions.length;\n\n        for(let i=0;i<functions.length;++i){\n            functions[i]()\n            .then((function_result)=>{\n                response_arr[i]=function_result;\n                if(--waiting_count===0) resolve(response_arr);\n            })\n            .catch(reject);\n        }\n    });\n};\n\n/**\n * const promise = promiseAll([() => new Promise(res => res(42))])\n * promise.then(console.log); // [42]\n */",
    "title_slug": "execute-asynchronous-functions-in-parallel",
    "problem_url": "https://leetcode.com/problems/execute-asynchronous-functions-in-parallel/"
  },
  {
    "question_id": 2743,
    "code": "/**\n * @param {Function} fn\n * @param {number} t milliseconds\n * @return {Function}\n */\nvar debounce = function(fn, t) {\n    let id;\n    return function(...args) {\n        clearTimeout(id);\n        id=setTimeout(()=>fn(...args),t);\n    }\n};\n\n/**\n * const log = debounce(console.log, 100);\n * log('Hello'); // cancelled\n * log('Hello'); // cancelled\n * log('Hello'); // Logged at t=100ms\n */",
    "title_slug": "debounce",
    "problem_url": "https://leetcode.com/problems/debounce/"
  },
  {
    "question_id": 585,
    "code": "# Write your MySQL query statement below\nselect ROUND(SUM(tiv_2016), 2) AS tiv_2016\n\nfrom (\n    select \n        tiv_2016,\n        count(*) over(partition by tiv_2015) as tiv_2015_count,\n        count(*) over(partition by lat,lon ) as lat_lon_count\n    from insurance\n) as subquery\nwhere tiv_2015_count>1 and lat_lon_count=1 ;",
    "title_slug": "investments-in-2016",
    "problem_url": "https://leetcode.com/problems/investments-in-2016/"
  },
  {
    "question_id": 585,
    "code": "# Write your MySQL query statement below\nselect ROUND(SUM(tiv_2016), 2) AS tiv_2016\n\nfrom (\n    select \n        tiv_2016,\n        count(*) over(partition by tiv_2015) as tiv_2015_count,\n        count(*) over(partition by lat,lon ) as lat_lon_count\n    from insurance\n) as subquery\nwhere tiv_2015_count>1 and lat_lon_count=1 ;",
    "title_slug": "investments-in-2016",
    "problem_url": "https://leetcode.com/problems/investments-in-2016/"
  },
  {
    "question_id": 185,
    "code": "/* Write your PL/SQL query statement below */\nwith joined_table as (\n    select\n    e.name as employee,\n    e.salary,\n    d.name as department,\n    dense_rank() over(partition by d.name order by e.salary desc) as salary_rank\n\n    from \n    employee e join department d\n    on e.departmentId=d.id\n)\n\nselect department, employee, salary \nfrom joined_table\n where salary_rank <= 3;\n",
    "title_slug": "department-top-three-salaries",
    "problem_url": "https://leetcode.com/problems/department-top-three-salaries/"
  },
  {
    "question_id": 602,
    "code": "# Write your MySQL query statement below\n\nselect id, count(id) num from \n(   select requester_id as id\n    from RequestAccepted \n    union all\n    ( select accepter_id id\n    from RequestAccepted \n    )\n) r\ngroup by id\norder by num desc \nlimit 1",
    "title_slug": "friend-requests-ii-who-has-the-most-friends",
    "problem_url": "https://leetcode.com/problems/friend-requests-ii-who-has-the-most-friends/"
  },
  {
    "question_id": 602,
    "code": "# Write your MySQL query statement below\n\nselect id, sum(num) num from \n(   select requester_id as id, count(requester_id) num\n    from RequestAccepted \n    group by requester_id\n    union all\n    ( select accepter_id id, count(accepter_id) num\n    from RequestAccepted \n    group by accepter_id\n    )\n) r\ngroup by r.id\norder by num desc \nlimit 1",
    "title_slug": "friend-requests-ii-who-has-the-most-friends",
    "problem_url": "https://leetcode.com/problems/friend-requests-ii-who-has-the-most-friends/"
  },
  {
    "question_id": 1452,
    "code": "# Write your MySQL query statement below\nSELECT \n    DISTINCT visited_on,\n    amount,\n    ROUND(amount/7, 2) AS average_amount\nFROM \n    (SELECT\n        visited_on,\n        SUM(amount) OVER (\n            ORDER BY visited_on \n            RANGE BETWEEN INTERVAL 6 DAY PRECEDING AND CURRENT ROW\n        ) AS amount,\n\n        MIN(visited_on) OVER() as firstDay\n    FROM Customer\n    ) AS c\nWHERE\n    visited_on >= firstDay + INTERVAL 6 DAY;\n",
    "title_slug": "restaurant-growth",
    "problem_url": "https://leetcode.com/problems/restaurant-growth/"
  },
  {
    "question_id": 1452,
    "code": "# Write your MySQL query statement below\nSELECT \n    DISTINCT visited_on,\n    amount,\n    ROUND(amount/7, 2) AS average_amount\nFROM \n    (SELECT\n        visited_on,\n        SUM(amount) OVER (\n            ORDER BY visited_on \n            RANGE BETWEEN INTERVAL 6 DAY PRECEDING AND CURRENT ROW\n        ) AS amount,\n\n        MIN(visited_on) OVER() as firstDay\n    FROM Customer\n    ) AS c\nWHERE\n    visited_on >= firstDay + INTERVAL 6 DAY;\n\n    \n# select\n# visited_on,\n# sum(\n#     case when amount is null \n#     then 0 \n#     else amount end\n# ) over(order by visited_on ROWS BETWEEN cte(visited_on) PRECEDING AND CURRENT ROW) as amount\n# from customer\n# where visited_on >= (visited_on-6)\n# ,\n# round(avg(\n#     case when amount is null \n#     then 0 \n#     else amount end\n# ) over(order by visited_on),2) as average_amount\n\n# group by visited_on",
    "title_slug": "restaurant-growth",
    "problem_url": "https://leetcode.com/problems/restaurant-growth/"
  },
  {
    "question_id": 2762,
    "code": "var TimeLimitedCache = function() {\n    this.cache={};\n};\n\n/** \n * @param {number} key\n * @param {number} value\n * @param {number} duration time until expiration in ms\n * @return {boolean} if un-expired key already existed\n */\nTimeLimitedCache.prototype.set = function(key, value, duration) {\n    if(this.cache[key] && this.cache[key].timer){\n        clearTimeout(this.cache[key].timer);\n        this.cache[key].value=value;\n        this.cache[key].timer= setTimeout(() =>{\n            this.remove(key);\n        },duration);\n        return true;\n    }\n    this.cache[key]={\n        value:value,\n        timer: setTimeout( ()=>{\n            this.remove(key);\n        },duration)\n    };\n    return false;\n    \n\n};\n\n/** \n * @param {number} key\n * @return {number} value associated with key\n */\nTimeLimitedCache.prototype.get = function(key) {\n    if (this.cache[key] && this.cache[key].timer) \n        return this.cache[key].value;\n\n    return -1;\n};\n\n/** \n * @return {number} count of non-expired keys\n */\nTimeLimitedCache.prototype.count = function() {\n    let count = 0;\n   for (const key in this.cache) {\n        if (this.cache[key].timer) {\n        count++;\n        }\n    }\n  return count;\n};\n\nTimeLimitedCache.prototype.remove = function(key) {\n  delete this.cache[key];\n};\n\n/**\n * const timeLimitedCache = new TimeLimitedCache()\n * timeLimitedCache.set(1, 42, 1000); // false\n * timeLimitedCache.get(1) // 42\n * timeLimitedCache.count() // 1\n */",
    "title_slug": "cache-with-time-limit",
    "problem_url": "https://leetcode.com/problems/cache-with-time-limit/"
  },
  {
    "question_id": 1480,
    "code": "# Write your MySQL query statement below\n(select name as results from users \ninner join movieRating using(user_id)\ngroup by user_id\norder by count(rating) desc, name asc\nlimit 1)\n\nunion all\n\n(select title from movies \ninner join movieRating  using(movie_id)\nwhere created_at between '2020-02-01' and '2020-02-29'\ngroup by movie_id\norder by avg(rating) desc, title asc\nlimit 1)\n",
    "title_slug": "movie-rating",
    "problem_url": "https://leetcode.com/problems/movie-rating/"
  },
  {
    "question_id": 1664,
    "code": "# Write your MySQL query statement below\nSELECT *\nFROM users\nWHERE lower(mail) REGEXP '^[a-z][a-z0-9_.-]*@leetcode[.]com$'",
    "title_slug": "find-users-with-valid-e-mails",
    "problem_url": "https://leetcode.com/problems/find-users-with-valid-e-mails/"
  },
  {
    "question_id": 1664,
    "code": "# Write your MySQL query statement below\nSELECT user_id, name, mail\nFROM users\nWHERE lower(mail) REGEXP '^[a-z][a-z0-9_.-]*@leetcode[.]com$'",
    "title_slug": "find-users-with-valid-e-mails",
    "problem_url": "https://leetcode.com/problems/find-users-with-valid-e-mails/"
  },
  {
    "question_id": 1462,
    "code": "# Write your MySQL query statement below\nwith cte as\n(select product_id, sum(unit) unit from orders\nwhere order_date between '2020-02-01' and '2020-02-29'\ngroup by product_id\nhaving sum(unit)>=100)\n\nselect product_name, unit from products, cte\nwhere products.product_id=cte.product_id",
    "title_slug": "list-the-products-ordered-in-a-period",
    "problem_url": "https://leetcode.com/problems/list-the-products-ordered-in-a-period/"
  },
  {
    "question_id": 1625,
    "code": "# Write your MySQL query statement below\nselect\nsell_date,\ncount(distinct product) num_sold,\ngroup_concat( distinct product ) as products\nfrom activities \ngroup by sell_date",
    "title_slug": "group-sold-products-by-the-date",
    "problem_url": "https://leetcode.com/problems/group-sold-products-by-the-date/"
  },
  {
    "question_id": 1625,
    "code": "# Write your MySQL query statement below\nselect\nsell_date,\ncount(distinct product) num_sold,\ngroup_concat( distinct product order by product) as products\nfrom activities \ngroup by sell_date",
    "title_slug": "group-sold-products-by-the-date",
    "problem_url": "https://leetcode.com/problems/group-sold-products-by-the-date/"
  },
  {
    "question_id": 196,
    "code": "# Write your MySQL query statement below\ndelete p1 from person p1,person p2 \nwhere p1.email=p2.email and p1.id>p2.id;",
    "title_slug": "delete-duplicate-emails",
    "problem_url": "https://leetcode.com/problems/delete-duplicate-emails/"
  },
  {
    "question_id": 176,
    "code": "/* Write your PL/SQL query statement below */\nselect \nmax(salary) as SecondHighestSalary\nfrom employee\nwhere salary<(select max(salary) from employee)",
    "title_slug": "second-highest-salary",
    "problem_url": "https://leetcode.com/problems/second-highest-salary/"
  },
  {
    "question_id": 1670,
    "code": "# Write your MySQL query statement below\nselect * from patients\nwhere\nconditions LIKE '% DIAB1%' or conditions LIKE 'DIAB1%';",
    "title_slug": "patients-with-a-condition",
    "problem_url": "https://leetcode.com/problems/patients-with-a-condition/"
  },
  {
    "question_id": 1811,
    "code": "# Write your MySQL query statement below\nselect\nuser_id,\nconcat(upper(substring(name,1,1)),lower(substring(name,2))) as name\nfrom users\norder by user_id;",
    "title_slug": "fix-names-in-a-table",
    "problem_url": "https://leetcode.com/problems/fix-names-in-a-table/"
  },
  {
    "question_id": 626,
    "code": "# Write your MySQL query statement below\nSELECT id, IF(MOD(id,2)=1 , LEAD(student, 1, student) OVER(), LAG(student) OVER()) AS student \nFROM Seat",
    "title_slug": "exchange-seats",
    "problem_url": "https://leetcode.com/problems/exchange-seats/"
  },
  {
    "question_id": 626,
    "code": "# Write your MySQL query statement below\nSELECT \n    CASE \n        WHEN id = (SELECT MAX(id) FROM seat) AND id % 2 = 1\n            THEN id \n        WHEN id % 2 = 1\n            THEN id + 1\n        ELSE id - 1\n    END AS id,\n    student\nFROM seat\nORDER BY id",
    "title_slug": "exchange-seats",
    "problem_url": "https://leetcode.com/problems/exchange-seats/"
  },
  {
    "question_id": 2057,
    "code": "# Write your MySQL query statement below\n(SELECT \"Low Salary\" AS category, COUNT(*) AS accounts_count FROM Accounts WHERE income < 20000)\nUNION\n(SELECT \"Average Salary\" AS category, COUNT(*) AS accounts_count FROM Accounts WHERE income >= 20000 AND income <= 50000)\nUNION\n(SELECT \"High Salary\" AS category, COUNT(*) AS accounts_count FROM Accounts WHERE income > 50000);",
    "title_slug": "count-salary-categories",
    "problem_url": "https://leetcode.com/problems/count-salary-categories/"
  },
  {
    "question_id": 2057,
    "code": "# Write your MySQL query statement below\nselect t.cat category, (count(*) - 1) accounts_count\nfrom \n(\nselect if(income < 20000, 'Low Salary', if(income > 50000, 'High Salary', 'Average Salary')) cat\nfrom accounts\nunion all (select 'Low Salary')\nunion all (select 'High Salary')\nunion all (select 'Average Salary')\n) as t\ngroup by t.cat",
    "title_slug": "count-salary-categories",
    "problem_url": "https://leetcode.com/problems/count-salary-categories/"
  },
  {
    "question_id": 1327,
    "code": "# Write your MySQL query statement below\nwith cte as (\n    select \n    person_name,\n    turn,\n    sum(weight) over (order by turn) as wt\n    from queue\n)\n\nselect person_name \nfrom cte where wt<=1000 \norder by wt desc limit 1;",
    "title_slug": "last-person-to-fit-in-the-bus",
    "problem_url": "https://leetcode.com/problems/last-person-to-fit-in-the-bus/"
  },
  {
    "question_id": 1327,
    "code": "# Write your MySQL query statement below\nwith cte as (\n    select \n    person_name,\n    turn,\n    sum(weight) over (order by turn) as sum_val\n    from queue\n)\n\nselect person_name \nfrom cte where sum_val<=1000 \norder by turn desc limit 1;",
    "title_slug": "last-person-to-fit-in-the-bus",
    "problem_url": "https://leetcode.com/problems/last-person-to-fit-in-the-bus/"
  },
  {
    "question_id": 2749,
    "code": "/**\n * @param {Function} fn\n * @param {number} t\n * @return {Function}\n */\nvar timeLimit = function(fn, t) {\n    \n    return async function(...args) {\n        const timeoutPromise = new Promise((resolve,reject)=>{\n            setTimeout(()=>{reject(\"Time Limit Exceeded\")},t)\n        })\n\n        return Promise.race([fn(...args),timeoutPromise])\n    }\n};\n\n/**\n * const limited = timeLimit((t) => new Promise(res => setTimeout(res, t)), 100);\n * limited(150).catch(console.log) // \"Time Limit Exceeded\" at t=100ms\n */",
    "title_slug": "promise-time-limit",
    "problem_url": "https://leetcode.com/problems/promise-time-limit/"
  },
  {
    "question_id": 70,
    "code": "class Solution {\n    public int climbStairs(int n) {\n        if(n<=2) return n;\n        int a=1; //ways for 1\n        int b=2; //ways for 2\n        int sum_next=a+b;\n        for(int i=3;i<=n;i++){\n            sum_next=a+b;\n            a=b;\n            b=sum_next;\n        }\n\n        return sum_next;\n    }\n}",
    "title_slug": "climbing-stairs",
    "problem_url": "https://leetcode.com/problems/climbing-stairs/"
  },
  {
    "question_id": 230,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n\n    int count=0;\n    public TreeNode helper(TreeNode temp, int k) {\n\n\n        if(temp==null){\n            return null;\n        }\n\n        TreeNode left_right = helper(temp.left,k);\n        if(left_right!=null)\n            return left_right;\n        \n        count++;\n        if(k==count)\n            return temp;\n\n        return helper(temp.right,k);  \n    }\n\n    public int kthSmallest(TreeNode root, int k) {\n\n        TreeNode node = helper(root,k);\n        return node.val;\n\n    }\n}",
    "title_slug": "kth-smallest-element-in-a-bst",
    "problem_url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/"
  },
  {
    "question_id": 784,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public void helper(TreeNode temp, int val) {\n         if(temp==null)\n            return;\n        \n        if(temp.val>val){\n            if(temp.left==null){\n                TreeNode newNode = new TreeNode(val);\n                temp.left=newNode;\n            }else\n                helper(temp.left,val);\n            \n        }else if(temp.val<val){\n            if(temp.right==null){\n                TreeNode newNode = new TreeNode(val);\n                temp.right=newNode;\n            }else\n                helper(temp.right,val);\n        }\n    }\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if(root==null)\n            root = new TreeNode(val);\n        else\n            helper(root,val);\n       return root;\n    }\n}",
    "title_slug": "insert-into-a-binary-search-tree",
    "problem_url": "https://leetcode.com/problems/insert-into-a-binary-search-tree/"
  },
  {
    "question_id": 783,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if(root==null)\n            return null;\n        \n\n        if(root.val==val)\n            return root;\n        else if(root.val>val)\n            return searchBST(root.left,val);\n        \n        return searchBST(root.right,val);\n    }\n}",
    "title_slug": "search-in-a-binary-search-tree",
    "problem_url": "https://leetcode.com/problems/search-in-a-binary-search-tree/"
  },
  {
    "question_id": 104,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int helper(TreeNode node){\n        if(node==null){\n            return 0;\n        }\n        return Math.max(helper(node.left)+1, helper(node.right)+1);\n    }\n    public int maxDepth(TreeNode root) {\n        return helper(root);\n    }\n}",
    "title_slug": "maximum-depth-of-binary-tree",
    "problem_url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/"
  },
  {
    "question_id": 104,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int helper(TreeNode node){\n        if(node==null){\n            return 0;\n        }\n        return Math.max(node.left!=null? helper(node.left)+1:0, \n        node.right!=null? helper(node.right)+1:0 );\n    }\n    public int maxDepth(TreeNode root) {\n        if(root==null) return 0;\n        return helper(root)+1;\n    }\n}",
    "title_slug": "maximum-depth-of-binary-tree",
    "problem_url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/"
  },
  {
    "question_id": 105,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    int index = 0;\n    public TreeNode buildTree(int[] preOrder, int[] inOrder) {\n    HashMap<Integer, Integer> map = new HashMap<>();\n\n    for(int i=0; i < inOrder.length; i++) {\n      map.put(inOrder[i], i);\n    }\n\n    \n    return helper(preOrder, inOrder, 0, preOrder.length-1, map);\n  }\n\n  public TreeNode helper(int[] preOrder, int[] inOrder, int left, int right, HashMap<Integer, Integer> map) {\n    if (left > right) {\n      return null;\n    }\n\n    int current = preOrder[index];\n    index++;\n\n    TreeNode node = new TreeNode(current);\n\n    if (left == right) {\n      return node;\n    }\n    int currentIndex= map.get(current);\n    node.left = helper(preOrder, inOrder, left, currentIndex - 1, map);\n    node.right = helper(preOrder, inOrder, currentIndex + 1, right, map);\n\n    return node;\n  }\n}",
    "title_slug": "construct-binary-tree-from-preorder-and-inorder-traversal",
    "problem_url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/"
  },
  {
    "question_id": 2862,
    "code": "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function (fn, args, t) {\n    fn(...args);\n    let intervalId = setInterval(() => {\n        fn(...args);\n    }, t);\n\n    return () => {\n        clearInterval(intervalId);\n    };\n};\n/**\n *  const result = [];\n *\n *  const fn = (x) => x * 2;\n *  const args = [4], t = 35, cancelTimeMs = 190;\n *\n *  const start = performance.now();\n *\n *  const log = (...argsArr) => {\n *      const diff = Math.floor(performance.now() - start);\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)});\n *  }\n *       \n *  const cancel = cancellable(log, args, t);\n *\n *  setTimeout(cancel, cancelTimeMs);\n *   \n *  setTimeout(() => {\n *      console.log(result); // [\n *                           //     {\"time\":0,\"returned\":8},\n *                           //     {\"time\":35,\"returned\":8},\n *                           //     {\"time\":70,\"returned\":8},\n *                           //     {\"time\":105,\"returned\":8},\n *                           //     {\"time\":140,\"returned\":8},\n *                           //     {\"time\":175,\"returned\":8}\n *                           // ]\n *  }, cancelTimeMs + t + 15)    \n */",
    "title_slug": "interval-cancellation",
    "problem_url": "https://leetcode.com/problems/interval-cancellation/"
  },
  {
    "question_id": 2862,
    "code": "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n    let shouldRepeat= true;\n\n    const repeat= function(){\n        fn(...args);\n        setTimeout(()=>{ shouldRepeat && repeat()},t);\n    };\n    repeat();\n    return ()=>{ shouldRepeat=false};\n};\n\n/**\n *  const result = [];\n *\n *  const fn = (x) => x * 2;\n *  const args = [4], t = 35, cancelTimeMs = 190;\n *\n *  const start = performance.now();\n *\n *  const log = (...argsArr) => {\n *      const diff = Math.floor(performance.now() - start);\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)});\n *  }\n *       \n *  const cancel = cancellable(log, args, t);\n *\n *  setTimeout(cancel, cancelTimeMs);\n *   \n *  setTimeout(() => {\n *      console.log(result); // [\n *                           //     {\"time\":0,\"returned\":8},\n *                           //     {\"time\":35,\"returned\":8},\n *                           //     {\"time\":70,\"returned\":8},\n *                           //     {\"time\":105,\"returned\":8},\n *                           //     {\"time\":140,\"returned\":8},\n *                           //     {\"time\":175,\"returned\":8}\n *                           // ]\n *  }, cancelTimeMs + t + 15)    \n */",
    "title_slug": "interval-cancellation",
    "problem_url": "https://leetcode.com/problems/interval-cancellation/"
  },
  {
    "question_id": 2821,
    "code": "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n    const timer=setTimeout(()=> {fn(...args)},t);\n   return function(){ clearTimeout(timer)};\n};\n\n/**\n *  const result = [];\n *\n *  const fn = (x) => x * 5;\n *  const args = [2], t = 20, cancelTimeMs = 50;\n *\n *  const start = performance.now();\n *\n *  const log = (...argsArr) => {\n *      const diff = Math.floor(performance.now() - start);\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)});\n *  }\n *       \n *  const cancel = cancellable(log, args, t);\n *\n *  const maxT = Math.max(t, cancelTimeMs);\n *           \n *  setTimeout(cancel, cancelTimeMs);\n *\n *  setTimeout(() => {\n *      console.log(result); // [{\"time\":20,\"returned\":10}]\n *  }, maxT + 15)\n */",
    "title_slug": "timeout-cancellation",
    "problem_url": "https://leetcode.com/problems/timeout-cancellation/"
  },
  {
    "question_id": 2821,
    "code": "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n    const timer=setTimeout(()=> {fn(...args)},t);\n    const cancelFn = function(){ clearTimeout(timer)};\n    return cancelFn;\n};\n\n/**\n *  const result = [];\n *\n *  const fn = (x) => x * 5;\n *  const args = [2], t = 20, cancelTimeMs = 50;\n *\n *  const start = performance.now();\n *\n *  const log = (...argsArr) => {\n *      const diff = Math.floor(performance.now() - start);\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)});\n *  }\n *       \n *  const cancel = cancellable(log, args, t);\n *\n *  const maxT = Math.max(t, cancelTimeMs);\n *           \n *  setTimeout(cancel, cancelTimeMs);\n *\n *  setTimeout(() => {\n *      console.log(result); // [{\"time\":20,\"returned\":10}]\n *  }, maxT + 15)\n */",
    "title_slug": "timeout-cancellation",
    "problem_url": "https://leetcode.com/problems/timeout-cancellation/"
  },
  {
    "question_id": 2821,
    "code": "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n    const timer=setTimeout(()=> fn(...args),t);\n    const cancelFn = ()=>clearTimeout(timer);\n    return cancelFn;\n};\n\n/**\n *  const result = [];\n *\n *  const fn = (x) => x * 5;\n *  const args = [2], t = 20, cancelTimeMs = 50;\n *\n *  const start = performance.now();\n *\n *  const log = (...argsArr) => {\n *      const diff = Math.floor(performance.now() - start);\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)});\n *  }\n *       \n *  const cancel = cancellable(log, args, t);\n *\n *  const maxT = Math.max(t, cancelTimeMs);\n *           \n *  setTimeout(cancel, cancelTimeMs);\n *\n *  setTimeout(() => {\n *      console.log(result); // [{\"time\":20,\"returned\":10}]\n *  }, maxT + 15)\n */",
    "title_slug": "timeout-cancellation",
    "problem_url": "https://leetcode.com/problems/timeout-cancellation/"
  },
  {
    "question_id": 2821,
    "code": "/**\n * @param {Function} fn\n * @param {Array} args\n * @param {number} t\n * @return {Function}\n */\nvar cancellable = function(fn, args, t) {\n    const timer=setTimeout(()=> fn(...args),t);\n    const cancelFn = function(){ clearTimeout(timer)};\n    return cancelFn;\n};\n\n/**\n *  const result = [];\n *\n *  const fn = (x) => x * 5;\n *  const args = [2], t = 20, cancelTimeMs = 50;\n *\n *  const start = performance.now();\n *\n *  const log = (...argsArr) => {\n *      const diff = Math.floor(performance.now() - start);\n *      result.push({\"time\": diff, \"returned\": fn(...argsArr)});\n *  }\n *       \n *  const cancel = cancellable(log, args, t);\n *\n *  const maxT = Math.max(t, cancelTimeMs);\n *           \n *  setTimeout(cancel, cancelTimeMs);\n *\n *  setTimeout(() => {\n *      console.log(result); // [{\"time\":20,\"returned\":10}]\n *  }, maxT + 15)\n */",
    "title_slug": "timeout-cancellation",
    "problem_url": "https://leetcode.com/problems/timeout-cancellation/"
  },
  {
    "question_id": 145,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n      List<Integer> postorder = new ArrayList<Integer>();\n        postorderHelper(root, postorder);\n        return postorder;\n    }\n\n\n    void postorderHelper(TreeNode node, List<Integer> postorder){\n\n        if(node==null){\n            return;\n        }\n\n        postorderHelper(node.left,postorder);\n        postorderHelper(node.right,postorder);\n        postorder.add(node.val);\n    }\n}",
    "title_slug": "binary-tree-postorder-traversal",
    "problem_url": "https://leetcode.com/problems/binary-tree-postorder-traversal/"
  },
  {
    "question_id": 94,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n      List<Integer> inorder = new ArrayList<Integer>();\n        inorderHelper(root, inorder);\n        return inorder;\n    }\n\n\n    void inorderHelper(TreeNode node, List<Integer> inorder){\n\n        if(node==null){\n            return;\n        }\n\n        inorderHelper(node.left,inorder);\n        inorder.add(node.val);\n        inorderHelper(node.right,inorder);\n    }\n}",
    "title_slug": "binary-tree-inorder-traversal",
    "problem_url": "https://leetcode.com/problems/binary-tree-inorder-traversal/"
  },
  {
    "question_id": 144,
    "code": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> preorder = new ArrayList<Integer>();\n        preorderHelper(root, preorder);\n        return preorder;\n    }\n\n\n    void preorderHelper(TreeNode node, List<Integer> preorder){\n\n        if(node==null){\n            return;\n        }\n\n        preorder.add(node.val);\n        preorderHelper(node.left,preorder);\n        preorderHelper(node.right,preorder);\n    }\n}",
    "title_slug": "binary-tree-preorder-traversal",
    "problem_url": "https://leetcode.com/problems/binary-tree-preorder-traversal/"
  },
  {
    "question_id": 1278,
    "code": "/* Write your PL/SQL query statement below */\nwith cte as(\n    select a.product_id, b.new_price, b.change_date,\n    max(b.change_date) over(partition by a.product_id) as change_date_max\n    from\n     products a left join products b \n            on a.change_date=b.change_date and a.product_id=b.product_id \n            and  b.change_date<= TO_DATE('2019-08-16','YYYY-MM-DD')\n\n)\n\nselect distinct\nproduct_id, \ncase when new_price is null then 10 else new_price end  as price \nfrom \ncte\nwhere (change_date= change_date_max or change_date_max is null )",
    "title_slug": "product-price-at-a-given-date",
    "problem_url": "https://leetcode.com/problems/product-price-at-a-given-date/"
  },
  {
    "question_id": 338,
    "code": "class Solution {\n    public int[] countBits(int n) {\n        int[] ans= new int[n+1];\n        ans[0]=0;\n        for(int i=1;i<=n;i++){\n            ans[i]= ans[i>>1] + (i&1);\n        }\n        return ans;\n    }\n}",
    "title_slug": "counting-bits",
    "problem_url": "https://leetcode.com/problems/counting-bits/"
  },
  {
    "question_id": 180,
    "code": "# Write your MySQL query statement below\nselect distinct a.num as consecutivenums \nfrom logs a,\nlogs b,\nlogs c\nwhere a.id = b.id-1\nand b.id = c.id - 1\nand a.num = b.num\nand c.num = b.num ",
    "title_slug": "consecutive-numbers",
    "problem_url": "https://leetcode.com/problems/consecutive-numbers/"
  },
  {
    "question_id": 180,
    "code": "# Write your MySQL query statement below\nwith cte as(\n    select \n        num,\n        lead(num) over() as next,\n        lead(num,2) over() as next2next\n\n    from \n        logs\n)\n\nselect distinct num  as ConsecutiveNums from cte where\nnum=next and next=next2next;",
    "title_slug": "consecutive-numbers",
    "problem_url": "https://leetcode.com/problems/consecutive-numbers/"
  },
  {
    "question_id": 39,
    "code": "import java.util.*;\n\nclass Solution {\n    private HashSet<List<Integer>> helper(int[] original, List<Integer> combo, int sum, int target) {\n        HashSet<List<Integer>> ans = new HashSet<>();\n\n        if (sum == target) {\n            // Sort the combo before adding it to the HashSet\n            Collections.sort(combo);\n            ans.add(new ArrayList<>(combo));\n        } else if (sum < target) {\n            for (int i = 0; i < original.length; i++) {\n                List<Integer> newCombo = new ArrayList<>(combo);\n                newCombo.add(original[i]);\n                HashSet<List<Integer>> recursiveResult = helper(original, newCombo, sum + original[i], target);\n\n                if (recursiveResult != null) {\n                    ans.addAll(recursiveResult);\n                }\n            }\n        }\n\n        return ans.isEmpty() ? null : ans;\n    }\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        HashSet<List<Integer>> ans = helper(candidates, new ArrayList<>(), 0, target);\n         if(ans==null) return new ArrayList<>();\n        return new ArrayList<>(ans);\n    }\n}\n\n  ",
    "title_slug": "combination-sum",
    "problem_url": "https://leetcode.com/problems/combination-sum/"
  },
  {
    "question_id": 610,
    "code": "/* Write your PL/SQL query statement below */\nselect x,y,z,\n\ncase when (x+y>z and y+z>x and z+x>y) then 'Yes' else 'No' end as triangle \n\nfrom triangle;",
    "title_slug": "triangle-judgement",
    "problem_url": "https://leetcode.com/problems/triangle-judgement/"
  },
  {
    "question_id": 1942,
    "code": "/* Write your PL/SQL query statement below */\nwith cte as(\n    select \n    employee_id,\n    department_id,\n    primary_flag,\n    count(*) over ( partition by employee_id) as emp_count\n    from employee \n    \n)\nselect employee_id,\ndepartment_id\n\nfrom cte\n\nwhere emp_count=1 or ( emp_count>1 and primary_flag='Y');",
    "title_slug": "primary-department-for-each-employee",
    "problem_url": "https://leetcode.com/problems/primary-department-for-each-employee/"
  },
  {
    "question_id": 1942,
    "code": "/* Write your PL/SQL query statement below */\nwith cte as(\n    select \n    count(department_id) as departmentCount,\n    employee_id\n    from employee \n    group by employee_id\n)\nselect employee_id,\ndepartment_id\n\nfrom employee\n\nwhere employee_id in(select employee_id from cte where departmentCount=1) or primary_flag='Y';",
    "title_slug": "primary-department-for-each-employee",
    "problem_url": "https://leetcode.com/problems/primary-department-for-each-employee/"
  },
  {
    "question_id": 2733,
    "code": "/**\n * @param {number} millis\n * @return {Promise}\n */\nasync function sleep(millis) {\n    return new Promise(resolve => setTimeout(resolve, millis));\n}\n\n/** \n * let t = Date.now()\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\n */",
    "title_slug": "sleep",
    "problem_url": "https://leetcode.com/problems/sleep/"
  },
  {
    "question_id": 2733,
    "code": "/**\n * @param {number} millis\n * @return {Promise}\n */\nasync function sleep(millis) {\n    await new Promise(resolve=> setTimeout(resolve,millis));\n}\n\n/** \n * let t = Date.now()\n * sleep(100).then(() => console.log(Date.now() - t)) // 100\n */",
    "title_slug": "sleep",
    "problem_url": "https://leetcode.com/problems/sleep/"
  },
  {
    "question_id": 2859,
    "code": "/**\n * @param {Promise} promise1\n * @param {Promise} promise2\n * @return {Promise}\n */\nvar addTwoPromises = async function(promise1, promise2) {\n    const a = await promise1;\n    const b = await promise2;\n    return a + b;\n};\n\n/**\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\n *   .then(console.log); // 4\n */",
    "title_slug": "add-two-promises",
    "problem_url": "https://leetcode.com/problems/add-two-promises/"
  },
  {
    "question_id": 2859,
    "code": "/**\n * @param {Promise} promise1\n * @param {Promise} promise2\n * @return {Promise}\n */\nvar addTwoPromises = async function(promise1, promise2) {\n    const [a,b]= await Promise.all([promise1,promise2]);\n    return a+b;\n};\n\n/**\n * addTwoPromises(Promise.resolve(2), Promise.resolve(2))\n *   .then(console.log); // 4\n */",
    "title_slug": "add-two-promises",
    "problem_url": "https://leetcode.com/problems/add-two-promises/"
  },
  {
    "question_id": 2731,
    "code": "/**\n * @param {Function} fn\n * @return {Function}\n */\nfunction memoize(fn) {\n    const cache={}\n    return function(...args) {\n        const key= JSON.stringify(args);\n\n        if(key in cache){\n            return cache[key];\n        }\n\n        const result= fn.apply(this,args);\n        cache[key]=result;\n        return result;    \n    }\n}\n\n\n/** \n * let callCount = 0;\n * const memoizedFn = memoize(function (a, b) {\n *\t callCount += 1;\n *   return a + b;\n * })\n * memoizedFn(2, 3) // 5\n * memoizedFn(2, 3) // 5\n * console.log(callCount) // 1 \n */",
    "title_slug": "memoize",
    "problem_url": "https://leetcode.com/problems/memoize/"
  },
  {
    "question_id": 1882,
    "code": "/* Write your PL/SQL query statement below */\n\nselect \ndistinct m.employee_id,\nm.name,\ncount(e.employee_id) over(partition by m.employee_id) as reports_count,\nround(avg(e.age) over(partition by m.employee_id)) as average_age\nfrom employees m join employees e\non m.employee_id=e.reports_to\norder by m.employee_id;",
    "title_slug": "the-number-of-employees-which-report-to-each-employee",
    "problem_url": "https://leetcode.com/problems/the-number-of-employees-which-report-to-each-employee/"
  },
  {
    "question_id": 1882,
    "code": "/* Write your PL/SQL query statement below */\nwith manager as (\n    select\n    m.employee_id,\n    m.name,\n    e.employee_id as junior_id,\n    e.age as junior_age\n    from employees e join employees m \n     on e.reports_to=m.employee_id;\n)\n\nselect employee_id,\nname,\ncount(junior_id) as reports_count,\nround(avg(junior_age)) as average_age\nfrom manager\ngroup by employee_id,name \norder by employee_id;",
    "title_slug": "the-number-of-employees-which-report-to-each-employee",
    "problem_url": "https://leetcode.com/problems/the-number-of-employees-which-report-to-each-employee/"
  },
  {
    "question_id": 2796,
    "code": "/**\n * @param {Function} fn\n * @return {Function}\n */\nvar once = function(fn) {\n    let notcalled=true;\n\treturn function(...args){\n        if(notcalled) {\n        notcalled=false;\n        return fn(...args);\n        // return fn.apply(this,args);\n        }\n        return undefined;\n    }\n};\n\n/**\n * let fn = (a,b,c) => (a + b + c)\n * let onceFn = once(fn)\n *\n * onceFn(1,2,3); // 6\n * onceFn(2,3,6); // returns undefined without calling fn\n */\n",
    "title_slug": "allow-one-function-call",
    "problem_url": "https://leetcode.com/problems/allow-one-function-call/"
  },
  {
    "question_id": 2796,
    "code": "/**\n * @param {Function} fn\n * @return {Function}\n */\nvar once = function(fn) {\n    let called=false;\n\treturn function(...args){\n        if(called) return undefined;\n        called=true;\n        return fn.apply(this,args);\n        // return fn(...args);\n    }\n};\n\n/**\n * let fn = (a,b,c) => (a + b + c)\n * let onceFn = once(fn)\n *\n * onceFn(1,2,3); // 6\n * onceFn(2,3,6); // returns undefined without calling fn\n */\n",
    "title_slug": "allow-one-function-call",
    "problem_url": "https://leetcode.com/problems/allow-one-function-call/"
  },
  {
    "question_id": 2796,
    "code": "/**\n * @param {Function} fn\n * @return {Function}\n */\nvar once = function(fn) {\n    let called=false;\n\treturn function(...args){\n        if(called) return undefined;\n        called=true;\n        // return fn.apply(this,args);\n        return fn(...args);\n    }\n};\n\n/**\n * let fn = (a,b,c) => (a + b + c)\n * let onceFn = once(fn)\n *\n * onceFn(1,2,3); // 6\n * onceFn(2,3,6); // returns undefined without calling fn\n */\n",
    "title_slug": "allow-one-function-call",
    "problem_url": "https://leetcode.com/problems/allow-one-function-call/"
  },
  {
    "question_id": 2820,
    "code": "/**\n * @param {...(null|boolean|number|string|Array|Object)} args\n * @return {number}\n */\nvar argumentsLength = function(...args) {\n\treturn args.length;\n};\n\n/**\n * argumentsLength(1, 2, 3); // 3\n */",
    "title_slug": "return-length-of-arguments-passed",
    "problem_url": "https://leetcode.com/problems/return-length-of-arguments-passed/"
  },
  {
    "question_id": 2741,
    "code": "/**\n * @param {Function[]} functions\n * @return {Function}\n */\nvar compose = function(functions) {\n    \n\n\treturn function(x) {\n        // for(const fn of functions.reverse()){\n        //     x=fn(x)\n        // }\n        for(let i=functions.length-1;i>=0;i--){\n            x=functions[i](x);\n        }\n        return x;\n    }\n};\n\n/**\n * const fn = compose([x => x + 1, x => 2 * x])\n * fn(4) // 9\n */",
    "title_slug": "function-composition",
    "problem_url": "https://leetcode.com/problems/function-composition/"
  },
  {
    "question_id": 2741,
    "code": "/**\n * @param {Function[]} functions\n * @return {Function}\n */\nvar compose = function(functions) {\n    \n\n\treturn function(x) {\n        for(const fn of functions.reverse()){\n            x=fn(x)\n        }\n        return x;\n    }\n};\n\n/**\n * const fn = compose([x => x + 1, x => 2 * x])\n * fn(4) // 9\n */",
    "title_slug": "function-composition",
    "problem_url": "https://leetcode.com/problems/function-composition/"
  },
  {
    "question_id": 2127,
    "code": "/* Write your PL/SQL query statement below */\nselect employee_id from employees e where\nsalary<30000 and manager_id not in\n(select employee_id from employees) \norder by employee_id;",
    "title_slug": "employees-whose-manager-left-the-company",
    "problem_url": "https://leetcode.com/problems/employees-whose-manager-left-the-company/"
  },
  {
    "question_id": 2127,
    "code": "/* Write your PL/SQL query statement below */\nselect employee_id from employees e where\nsalary<30000 and manager_id is not null and \n(select m.employee_id from employees  m where m.employee_id = e.manager_id) is null\norder by employee_id;",
    "title_slug": "employees-whose-manager-left-the-company",
    "problem_url": "https://leetcode.com/problems/employees-whose-manager-left-the-company/"
  },
  {
    "question_id": 1135,
    "code": "/* Write your PL/SQL query statement below */\nselect customer_id\nfrom customer group by customer_id \nhaving count(distinct product_key)=(select count(product_key) from product)",
    "title_slug": "customers-who-bought-all-products",
    "problem_url": "https://leetcode.com/problems/customers-who-bought-all-products/"
  },
  {
    "question_id": 619,
    "code": "/* Write your PL/SQL query statement below */\nwith cte as (\n    select num,\n    count(num) total\n    from mynumbers \n    group by num\n    -- having count(num)=1\n)\nselect max(num) as num from cte where total=1;",
    "title_slug": "biggest-single-number",
    "problem_url": "https://leetcode.com/problems/biggest-single-number/"
  },
  {
    "question_id": 619,
    "code": "/* Write your PL/SQL query statement below */\nwith cte as (\n    select num,\n    count(num)\n    from mynumbers \n    group by num\n    having count(num)=1\n)\nselect max(num) as num from cte;",
    "title_slug": "biggest-single-number",
    "problem_url": "https://leetcode.com/problems/biggest-single-number/"
  },
  {
    "question_id": 1877,
    "code": "/* Write your PL/SQL query statement below */\nselect user_id, count(follower_id)  as followers_count from followers\ngroup by user_id\norder by user_id;",
    "title_slug": "find-followers-count",
    "problem_url": "https://leetcode.com/problems/find-followers-count/"
  },
  {
    "question_id": 1155,
    "code": "/* Write your PL/SQL query statement below */\n/* Write your PL/SQL query statement below */\n\nselect p.product_id, s.year as first_year, s.quantity, s.price\nfrom product p join sales s\non p.product_id = s.product_id and s.year = (\n    select min(year) from sales\n    where product_id = p.product_id\n)\n-- with cte as(\n--     select distinct product_id, min(year) as first_year from sales group by product_id;\n-- )\n\n-- select p.product_id, q.first_year, p.quantity, p.price\n-- from sales p join cte q on p.product_id=q.product_id and p.year =q.first_year;\n\n\n-- with cte as(\n--     select product_id, year as first_year, quantity,price,\n--     rank() over(partition by product_id order by year) year_rank from sales\n-- )\n\n-- select product_id, first_year, quantity,price from cte where year_rank=1;",
    "title_slug": "product-sales-analysis-iii",
    "problem_url": "https://leetcode.com/problems/product-sales-analysis-iii/"
  },
  {
    "question_id": 1155,
    "code": "/* Write your PL/SQL query statement below */\n-- with cte as(\n--     select distinct product_id, min(year) as first_year from sales group by product_id;\n-- )\n\n-- select p.product_id, q.first_year, p.quantity, p.price\n-- from sales p join cte q on p.product_id=q.product_id and p.year =q.first_year;\n\n\nwith cte as(\n    select product_id, year as first_year, quantity,price,\n    rank() over(partition by product_id order by year) year_rank from sales\n)\n\nselect product_id, first_year, quantity,price from cte where year_rank=1;",
    "title_slug": "product-sales-analysis-iii",
    "problem_url": "https://leetcode.com/problems/product-sales-analysis-iii/"
  },
  {
    "question_id": 1155,
    "code": "/* Write your PL/SQL query statement below */\nwith cte as(\n    select distinct product_id, min(year) as first_year from sales group by product_id;\n)\n\nselect p.product_id, q.first_year, p.quantity, p.price\nfrom sales p join cte q on p.product_id=q.product_id and p.year =q.first_year;",
    "title_slug": "product-sales-analysis-iii",
    "problem_url": "https://leetcode.com/problems/product-sales-analysis-iii/"
  },
  {
    "question_id": 596,
    "code": "/* Write your PL/SQL query statement below */\nselect class from courses group by class having count(1)>=5;",
    "title_slug": "classes-more-than-5-students",
    "problem_url": "https://leetcode.com/problems/classes-more-than-5-students/"
  },
  {
    "question_id": 596,
    "code": "/* Write your PL/SQL query statement below */\nwith cte as(\n    select class, count(student) as studentCount from courses group by class\n)\nselect class from cte where studentCount>=5;",
    "title_slug": "classes-more-than-5-students",
    "problem_url": "https://leetcode.com/problems/classes-more-than-5-students/"
  },
  {
    "question_id": 1245,
    "code": "/* Write your PL/SQL query statement below */\nSELECT TO_CHAR(TRUNC(activity_date), 'YYYY-MM-DD') as \"day\", COUNT(DISTINCT user_id) as \"active_users\"\nFROM Activity\nWHERE TRUNC(activity_date) BETWEEN DATE '2019-06-28' AND DATE '2019-07-27'\nGROUP BY activity_date\nORDER BY activity_date;\n",
    "title_slug": "user-activity-for-the-past-30-days-i",
    "problem_url": "https://leetcode.com/problems/user-activity-for-the-past-30-days-i/"
  },
  {
    "question_id": 1245,
    "code": "/* Write your PL/SQL query statement below */\nselect to_char(activity_date) as day , count(distinct user_id) as active_users\nfrom activity\nwhere activity_date<=to_date('2019-07-27') and activity_date > to_date('2019-06-27')\ngroup by activity_date\norder by activity_date;",
    "title_slug": "user-activity-for-the-past-30-days-i",
    "problem_url": "https://leetcode.com/problems/user-activity-for-the-past-30-days-i/"
  },
  {
    "question_id": 2761,
    "code": "/**\n * @param {number[]} nums\n * @param {Function} fn\n * @param {number} init\n * @return {number}\n */\nvar reduce = function(nums, fn, init) {\n    let num=init;\n    for(let i=0;i<nums.length;i++){\n        num=fn(num,nums[i]);\n    }\n    return num;\n};",
    "title_slug": "array-reduce-transformation",
    "problem_url": "https://leetcode.com/problems/array-reduce-transformation/"
  },
  {
    "question_id": 2746,
    "code": "/**\n * @param {number[]} arr\n * @param {Function} fn\n * @return {number[]}\n */\n\n //? space complexity O(n)\n// var filter = function(arr, fn) {\n//     let a=[];\n//     for(let i=0;i<arr.length;i++){\n//         if(fn(arr[i],i)){\n//             a.push(arr[i]);\n//         }\n//     }\n//     return a;\n// };\n\n\n//? space complexity O(1)\nvar filter= function(arr,fn){\n    let fIndex=0;\n    for(let i=0;i<arr.length;i++){\n        if(fn(arr[i],i)){\n            if(fIndex!=i){\n                let temp= arr[i];\n                arr[i]=arr[fIndex];\n                arr[fIndex]=temp;\n            }\n            fIndex++;\n        }\n    }\n    arr.length=fIndex;\n    return arr;\n}",
    "title_slug": "filter-elements-from-array",
    "problem_url": "https://leetcode.com/problems/filter-elements-from-array/"
  },
  {
    "question_id": 1894,
    "code": "class Solution {\n    public String mergeAlternately(String word1, String word2) {\n        int m=word1.length();\n        int n=word2.length();\n        StringBuilder sb=new StringBuilder(word2);\n        int i=0; int j=0;\n        while(i<m){   \n            if(i>n){\n                sb.append(word1.substring(i));\n                break;\n            }else\n                sb.insert(j,word1.charAt(i));\n            i++; j+=2;\n        }\n        return sb.toString();\n    }\n}",
    "title_slug": "merge-strings-alternately",
    "problem_url": "https://leetcode.com/problems/merge-strings-alternately/"
  },
  {
    "question_id": 2747,
    "code": "/**\n * @param {number[]} arr\n * @param {Function} fn\n * @return {number[]}\n */\nvar map = function(arr, fn) {\n    let num=arr;\n    for(let i=0;i<arr.length;i++){\n        num[i]=fn(arr[i],i);\n    }\n\n    return num;\n};",
    "title_slug": "apply-transform-over-each-element-in-array",
    "problem_url": "https://leetcode.com/problems/apply-transform-over-each-element-in-array/"
  },
  {
    "question_id": 2747,
    "code": "/**\n * @param {number[]} arr\n * @param {Function} fn\n * @return {number[]}\n */\nvar map = function(arr, fn) {\n    for(let i=0;i<arr.length;i++){\n        arr[i]=fn(arr[i],i);\n    }\n\n    return arr;\n};",
    "title_slug": "apply-transform-over-each-element-in-array",
    "problem_url": "https://leetcode.com/problems/apply-transform-over-each-element-in-array/"
  },
  {
    "question_id": 2495,
    "code": "/* Write your PL/SQL query statement below */\nselect teacher_id,count(distinct subject_id) as cnt from teacher group by teacher_id;",
    "title_slug": "number-of-unique-subjects-taught-by-each-teacher",
    "problem_url": "https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/"
  },
  {
    "question_id": 2495,
    "code": "/* Write your PL/SQL query statement below */\nselect teacher_id,count(distinct subject_id) as cnt from teacher group by teacher_id;",
    "title_slug": "number-of-unique-subjects-taught-by-each-teacher",
    "problem_url": "https://leetcode.com/problems/number-of-unique-subjects-taught-by-each-teacher/"
  },
  {
    "question_id": 1182,
    "code": "/* Write your PL/SQL query statement below */\n/* Write your PL/SQL query statement below */\nselect\nround ( \n    SUM(case when \n    a.event_date - 1 = (select min(event_date) from activity b where b.player_id=a.player_id) \n    then 1\n    else 0\n    end) / COUNT(distinct(player_id))\n    ,2) as fraction \nfrom activity a",
    "title_slug": "game-play-analysis-iv",
    "problem_url": "https://leetcode.com/problems/game-play-analysis-iv/"
  },
  {
    "question_id": 1182,
    "code": "/* Write your PL/SQL query statement below */\n/* Write your PL/SQL query statement below */\nselect\nround ( \n    SUM(case when \n    a.event_date - 1 = (select min(event_date) from activity b where b.player_id=a.player_id) \n    then 1\n    else 0\n    end) / COUNT(distinct(player_id))\n    ,2) as fraction \nfrom activity a",
    "title_slug": "game-play-analysis-iv",
    "problem_url": "https://leetcode.com/problems/game-play-analysis-iv/"
  },
  {
    "question_id": 1182,
    "code": "/* Write your PL/SQL query statement below */\n-- with cte as (\n--     select\n--     player_id,\n--     event_date,\n--     lead(event_date) over(partition by player_id order by event_date) as next_login,\n--     from activity\n-- )\n-- select round(\n--     count(distinct player_id)/(select count(distinct player_id) from activity)\n--     ,2) as fraction \n-- from cte\n-- where next_login=event_date+1;\n\nselect round(\n    count(distinct b.player_id)/count(distinct a.player_id)\n    ,2) as fraction\nfrom \n    (select player_id, min(event_date) as event_date from activity group by player_id) a left join activity b \n    on a.player_id=b.player_id and a.event_date+1=b.event_date;",
    "title_slug": "game-play-analysis-iv",
    "problem_url": "https://leetcode.com/problems/game-play-analysis-iv/"
  },
  {
    "question_id": 2789,
    "code": "/**\n * @param {integer} init\n * @return { increment: Function, decrement: Function, reset: Function }\n */\nvar createCounter = function(init) {\n    let i = 0;\n    return {\n    increment: () => init + ++i,\n    decrement: () => init + --i,\n    reset: () =>{ \n    i=0;\n    return init}}\n};\n\n/**\n * const counter = createCounter(5)\n * counter.increment(); // 6\n * counter.reset(); // 5\n * counter.decrement(); // 4\n */",
    "title_slug": "counter-ii",
    "problem_url": "https://leetcode.com/problems/counter-ii/"
  },
  {
    "question_id": 2789,
    "code": "/**\n * @param {integer} init\n * @return { increment: Function, decrement: Function, reset: Function }\n */\nvar createCounter = function(init) {\n    let currentValue = init;\n\n    return {\n        increment: () => ++currentValue,\n        decrement: () => --currentValue,\n        reset: () => {currentValue = init; return init;}\n    };\n};\n\n/**\n * const counter = createCounter(5)\n * counter.increment(); // 6\n * counter.reset(); // 5\n * counter.decrement(); // 4\n */",
    "title_slug": "counter-ii",
    "problem_url": "https://leetcode.com/problems/counter-ii/"
  },
  {
    "question_id": 2789,
    "code": "/**\n * @param {integer} init\n * @return { increment: Function, decrement: Function, reset: Function }\n */\nvar createCounter = function(init) {\n    let val=init;\n    var increment= ()=>{\n            return ++val;\n        };\n    var decrement= ()=> {return --val;};\n    var reset=()=>{\n            val=init;\n            return val;\n        }\n    return {\n        // val:init,\n        increment: increment,\n        decrement:decrement,\n        reset:reset\n\n    }\n};\n\n/**\n * const counter = createCounter(5)\n * counter.increment(); // 6\n * counter.reset(); // 5\n * counter.decrement(); // 4\n */",
    "title_slug": "counter-ii",
    "problem_url": "https://leetcode.com/problems/counter-ii/"
  },
  {
    "question_id": 2813,
    "code": "/**\n * @param {string} val\n * @return {Object}\n */\nvar expect = function(val) {\n    var toBe =(val2)=>{\n        if(val!==val2) \n            throw \"Not Equal\";\n        else \n            return true;\n    }\n    var notToBe = (val2)=>{\n        if(val===val2) \n            throw \"Equal\";\n        else \n            return true;\n    }\n    return{\n        toBe: toBe,\n        notToBe: notToBe\n    }\n};\n\n/**\n * expect(5).toBe(5); // true\n * expect(5).notToBe(5); // throws \"Equal\"\n */",
    "title_slug": "to-be-or-not-to-be",
    "problem_url": "https://leetcode.com/problems/to-be-or-not-to-be/"
  },
  {
    "question_id": 2813,
    "code": "/**\n * @param {string} val\n * @return {Object}\n */\nvar expect = function(val) {\n    var toBe =(val2)=>{\n        if(val===val2) return true;\n        else throw \"Not Equal\";\n    }\n    var notToBe = (val2)=>{\n        if(val===val2) \n        throw \"Equal\";\n        else \n        return !(val===val2);\n    }\n    return{\n        toBe: toBe,\n        notToBe: notToBe\n    }\n};\n\n/**\n * expect(5).toBe(5); // true\n * expect(5).notToBe(5); // throws \"Equal\"\n */",
    "title_slug": "to-be-or-not-to-be",
    "problem_url": "https://leetcode.com/problems/to-be-or-not-to-be/"
  },
  {
    "question_id": 2732,
    "code": "/**\n * @param {number} n\n * @return {Function} counter\n */\nvar createCounter = function(n) {\n    return ()=>n++;\n    \n};\n\n/** \n * const counter = createCounter(10)\n * counter() // 10\n * counter() // 11\n * counter() // 12\n */",
    "title_slug": "counter",
    "problem_url": "https://leetcode.com/problems/counter/"
  },
  {
    "question_id": 2732,
    "code": "/**\n * @param {number} n\n * @return {Function} counter\n */\nvar createCounter = function(n) {\n    let i=n-1;\n    return function() {\n        i++;\n        return i;\n    };\n    \n};\n\n/** \n * const counter = createCounter(10)\n * counter() // 10\n * counter() // 11\n * counter() // 12\n */",
    "title_slug": "counter",
    "problem_url": "https://leetcode.com/problems/counter/"
  },
  {
    "question_id": 2732,
    "code": "/**\n * @param {number} n\n * @return {Function} counter\n */\nvar createCounter = function(n) {\n    \n    return function() {\n        return n++;\n    };\n    \n};\n\n/** \n * const counter = createCounter(10)\n * counter() // 10\n * counter() // 11\n * counter() // 12\n */",
    "title_slug": "counter",
    "problem_url": "https://leetcode.com/problems/counter/"
  },
  {
    "question_id": 1292,
    "code": "/* Write your PL/SQL query statement below */\nwith cte as (\n    select customer_id,\n    order_date,\n    customer_pref_delivery_date,\n    row_number()over(partition by customer_id order by order_date) as orders_rank\n    from delivery\n)\n\nselect round(avg(\n    case when customer_pref_delivery_date=order_date then 1 else 0 end\n    )*100,2) as immediate_percentage\n    from cte where orders_rank=1;",
    "title_slug": "immediate-food-delivery-ii",
    "problem_url": "https://leetcode.com/problems/immediate-food-delivery-ii/"
  },
  {
    "question_id": 1292,
    "code": "/* Write your PL/SQL query statement below */\nselect round(\n    count(\n        case when customer_pref_delivery_date = order_date then 1 end\n    ) *100 /\n    count(customer_pref_delivery_date) \n    ,2)\nas immediate_percentage\nfrom delivery\nwhere \n(customer_id, order_date) in (Select customer_id, min(order_date) from delivery group by customer_id); \n",
    "title_slug": "immediate-food-delivery-ii",
    "problem_url": "https://leetcode.com/problems/immediate-food-delivery-ii/"
  },
  {
    "question_id": 2809,
    "code": "function createHelloWorld() {\n    \n\treturn function(...args): string {\n        return \"Hello World\"\n    };\n};\n\n/**\n * const f = createHelloWorld();\n * f(); // \"Hello World\"\n */",
    "title_slug": "create-hello-world-function",
    "problem_url": "https://leetcode.com/problems/create-hello-world-function/"
  },
  {
    "question_id": 2809,
    "code": "function createHelloWorld() {\n    \n\treturn () => \"Hello World\";\n};\n\n/**\n * const f = createHelloWorld();\n * f(); // \"Hello World\"\n */",
    "title_slug": "create-hello-world-function",
    "problem_url": "https://leetcode.com/problems/create-hello-world-function/"
  },
  {
    "question_id": 2809,
    "code": "/**\n * @return {Function}\n */\nvar createHelloWorld = function() {\n    \n    return ()=> \"Hello World\"\n};\n\n/**\n * const f = createHelloWorld();\n * f(); // \"Hello World\"\n */",
    "title_slug": "create-hello-world-function",
    "problem_url": "https://leetcode.com/problems/create-hello-world-function/"
  },
  {
    "question_id": 2809,
    "code": "/**\n * @return {Function}\n */\nvar createHelloWorld = function() {\n    \n    return function(...args) {\n        return \"Hello World\"\n    }\n};\n\n/**\n * const f = createHelloWorld();\n * f(); // \"Hello World\"\n */",
    "title_slug": "create-hello-world-function",
    "problem_url": "https://leetcode.com/problems/create-hello-world-function/"
  },
  {
    "question_id": 1205,
    "code": "class Solution {\n    public String defangIPaddr(String address) {\n        StringBuilder s= new StringBuilder(address);\n\n        for(int i=0;i<s.length();i++){\n            if(s.charAt(i)=='.'){\n                s.insert(i,\"[\"); \n                i=i+2;\n                s.insert(i,\"]\"); \n            }\n        }\n\n        return s.toString();\n    }\n}",
    "title_slug": "defanging-an-ip-address",
    "problem_url": "https://leetcode.com/problems/defanging-an-ip-address/"
  },
  {
    "question_id": 1317,
    "code": "/* Write your PL/SQL query statement below */\nselect to_char(trans_date, 'yyyy-mm') month, country, count(1) as trans_count, \n      sum(case when state = 'approved' then 1 else 0 end) as approved_count,\n      sum(amount) as trans_total_amount, \n      sum(case when state = 'approved' then amount else 0 end) as approved_total_amount\nfrom\n   transactions\ngroup by\n   to_char(trans_date, 'yyyy-mm'), country",
    "title_slug": "monthly-transactions-i",
    "problem_url": "https://leetcode.com/problems/monthly-transactions-i/"
  },
  {
    "question_id": 1317,
    "code": "select\nto_char(trans_date,'yyyy-mm') as month,\ncountry,\ncount(1) as trans_count,\nsum(case when state='approved' then 1 else 0 end) as approved_count,\nsum(amount) as trans_total_amount,\nsum(case when state='approved' then amount else 0 end) as approved_total_amount\nfrom transactions\ngroup by to_char(trans_date,'yyyy-mm'), country;",
    "title_slug": "monthly-transactions-i",
    "problem_url": "https://leetcode.com/problems/monthly-transactions-i/"
  },
  {
    "question_id": 1317,
    "code": "select\nTO_CHAR(trans_date,'yyyy-mm') as month,\ncountry,\ncount(1) as trans_count,\ncount(case when state='approved' then 1 end) as approved_count,\nsum(amount) as trans_total_amount,\nsum(case when state='approved' then amount else 0 end) as approved_total_amount\nfrom transactions\nGROUP BY   TO_CHAR(trans_date,'yyyy-mm'), country;\n;\n",
    "title_slug": "monthly-transactions-i",
    "problem_url": "https://leetcode.com/problems/monthly-transactions-i/"
  },
  {
    "question_id": 1317,
    "code": "select\n-- EXTRACT(YEAR FROM trans_date) || '-' || EXTRACT(MONTH FROM trans_date) as month,\n TO_CHAR(trans_date,'yyyy-mm') as month,\ncountry,\ncount(id) as trans_count,\ncount(case when state='approved' then 1 end) as approved_count,\nsum(amount) as trans_total_amount,\nsum(case when state='approved' then amount else 0 end) as approved_total_amount\nfrom transactions\nGROUP BY   TO_CHAR(trans_date,'yyyy-mm'), country;\n;\n",
    "title_slug": "monthly-transactions-i",
    "problem_url": "https://leetcode.com/problems/monthly-transactions-i/"
  },
  {
    "question_id": 2048,
    "code": "class Solution {\n    public int[] buildArray(int[] nums) {\n        for(int i=0;i<nums.length;i++){\n           int a= nums[i] + (1001)*(nums[nums[i]]%1001);\n           nums[i]=a;\n        }\n        for(int i=0;i<nums.length;i++){\n            nums[i]/=1001;\n        }\n\n        return nums;\n    }\n}",
    "title_slug": "build-array-from-permutation",
    "problem_url": "https://leetcode.com/problems/build-array-from-permutation/"
  },
  {
    "question_id": 1338,
    "code": "/* Write your PL/SQL query statement below */\n\nselect distinct query_name, \nround(avg(rating/position),2) as quality,\nround(sum(case when rating <3 then 1 else 0 end)*100 /count(query_name),2) as poor_query_percentage\nfrom queries\ngroup by query_name;",
    "title_slug": "queries-quality-and-percentage",
    "problem_url": "https://leetcode.com/problems/queries-quality-and-percentage/"
  },
  {
    "question_id": 1338,
    "code": "/* Write your PL/SQL query statement below */\n\nselect distinct query_name, \nround(avg(rating/position),2) as quality,\nround(count(case when rating <3 then 1  end)*100 /count(query_name),2) as poor_query_percentage\nfrom queries\ngroup by query_name;",
    "title_slug": "queries-quality-and-percentage",
    "problem_url": "https://leetcode.com/problems/queries-quality-and-percentage/"
  },
  {
    "question_id": 1773,
    "code": "/* Write your PL/SQL query statement below */\nselect contest_id, round(count(r.user_id)*100/(select count(user_id) from users),2) as percentage\nfrom users u join register r on u.user_id=r.user_id\ngroup by contest_id\norder by percentage desc, contest_id;",
    "title_slug": "percentage-of-users-attended-a-contest",
    "problem_url": "https://leetcode.com/problems/percentage-of-users-attended-a-contest/"
  },
  {
    "question_id": 1773,
    "code": "/* Write your PL/SQL query statement below */\nselect contest_id, round(count(r.user_id)*100/(select count(user_id) from users),2) as percentage\nfrom users u join register r on u.user_id=r.user_id\ngroup by contest_id\norder by percentage desc, contest_id;",
    "title_slug": "percentage-of-users-attended-a-contest",
    "problem_url": "https://leetcode.com/problems/percentage-of-users-attended-a-contest/"
  },
  {
    "question_id": 1773,
    "code": "/* Write your PL/SQL query statement below */\nselect contest_id, round(count(user_id)*100/(select count(user_id) from users),2) as percentage\nfrom register \ngroup by contest_id\norder by percentage desc, contest_id;",
    "title_slug": "percentage-of-users-attended-a-contest",
    "problem_url": "https://leetcode.com/problems/percentage-of-users-attended-a-contest/"
  },
  {
    "question_id": 1773,
    "code": "/* Write your PL/SQL query statement below */\nselect contest_id, round(count(user_id)*100/(select count(user_id) from users),2) as percentage\nfrom register \ngroup by contest_id\norder by percentage desc, contest_id;",
    "title_slug": "percentage-of-users-attended-a-contest",
    "problem_url": "https://leetcode.com/problems/percentage-of-users-attended-a-contest/"
  },
  {
    "question_id": 1161,
    "code": "/* Write your PL/SQL query statement below */\nselect p.project_id, round(avg(experience_years),2) as average_years\nfrom project p  join employee e on p.employee_id=e.employee_id\ngroup by p.project_id;",
    "title_slug": "project-employees-i",
    "problem_url": "https://leetcode.com/problems/project-employees-i/"
  },
  {
    "question_id": 1161,
    "code": "/* Write your PL/SQL query statement below */\nselect p.project_id, round(sum(experience_years)/count(e.employee_id),2) as average_years\nfrom project p  join employee e on p.employee_id=e.employee_id\ngroup by p.project_id;",
    "title_slug": "project-employees-i",
    "problem_url": "https://leetcode.com/problems/project-employees-i/"
  },
  {
    "question_id": 1390,
    "code": "/* Write your PL/SQL query statement below */\nwith joinTable as (\n    select p.product_id ,\n    sum(units*price) as totalprice,\n    sum(units) as totalunits\n    from \n    prices p  left join unitsSold u \n    on p.product_id=u.product_id  and purchase_date between start_date And end_date \n    group by p.product_id\n)\n\nselect product_id,round(case when totalunits is null then 0 else totalprice/totalunits end,2) as average_price from joinTable;",
    "title_slug": "average-selling-price",
    "problem_url": "https://leetcode.com/problems/average-selling-price/"
  },
  {
    "question_id": 1390,
    "code": "/* Write your PL/SQL query statement below */\nwith joinTable as (\n    select p.product_id ,\n    sum(case when purchase_date between start_date And end_date \n            then units*price else 0 end) as totalprice,\n    sum(case when purchase_date between start_date And end_date \n            then units else 0 end) as totalunits\n    from \n    prices p  left join unitsSold u on p.product_id=u.product_id \n    group by p.product_id\n)\n\nselect product_id,round(case when totalunits=0 then 0 else totalprice/totalunits end,2) as average_price from joinTable;",
    "title_slug": "average-selling-price",
    "problem_url": "https://leetcode.com/problems/average-selling-price/"
  },
  {
    "question_id": 283,
    "code": "class Solution {\n    public void moveZeroes(int[] nums) {\n        // pointer in array \n        int i=0;\n        // now we will traverse all the elements and if we will find any non zero element \n        // we will set value to nums[i] to num.\n\n        //Eg 1,2,0,0,1,2,0,0,3,4 -> 1,2,1,2,3,4,0,0,3,4\n        for(int num:nums){\n            if(num!=0){\n                nums[i]=num;\n                i++;\n            }\n        }\n\n        // now we will set the remaining elements to zero\n        while(i<nums.length){\n            nums[i]=0;\n            i++;\n        }\n    }\n}",
    "title_slug": "move-zeroes",
    "problem_url": "https://leetcode.com/problems/move-zeroes/"
  },
  {
    "question_id": 283,
    "code": "//* This uses 2 pointer approach */\n// j pointer is at first zero index and i at j+1. \nclass Solution {\n    public static void swap(int[] a, int i, int j){\n            int temp=a[i];\n            a[i]=a[j];\n            a[j]=temp;\n    }\n    public void moveZeroes(int[] nums) {\n\n        //? First we will find the position where j is non zero\n        int j=-1;\n        for(int i=0;i<nums.length;i++){\n            if(nums[i]==0){\n                // we found our first non zero element so break here\n                j=i;\n                break;\n            }\n        }\n\n        // if zero is not presesnt in the array we dont need to perform further steps\n        if(j==-1) return;\n\n\n        // if we found a non zero element the we will it with j and the increament j by one.\n        // This is process all our non zero elements are visited and when j is increament it \n        // this j+1 element contains a zero element \n        for(int i=j+1;i<nums.length;i++){\n\n            if(nums[i]!=0){\n                swap(nums,i,j);\n                j++;\n            }\n        }\n    }\n}",
    "title_slug": "move-zeroes",
    "problem_url": "https://leetcode.com/problems/move-zeroes/"
  },
  {
    "question_id": 2087,
    "code": "/* Write your PL/SQL query statement below */\n\nselect  s.user_id ,round(avg(case when c.action='confirmed' then 1 else 0 end),2) as confirmation_rate from signups s left join confirmations c on s.user_id=c.user_id group by s.user_id;",
    "title_slug": "confirmation-rate",
    "problem_url": "https://leetcode.com/problems/confirmation-rate/"
  },
  {
    "question_id": 2087,
    "code": "/* Write your PL/SQL query statement below */\n-- select  user_id ,count(case when action='confirmed' then 1 end)/ count(*) as confirmation_rate from confirmations group by user_id;\n\nselect  s.user_id ,round(avg(case when c.action='confirmed' then 1 else 0 end),2) as confirmation_rate from signups s left join confirmations c on s.user_id=c.user_id group by s.user_id;\n\n-- with jointest as(\n--     select *\n--      from signups s left join confirmations c on s.user_id=c.user_id; \n-- )\n-- select * from jointest;",
    "title_slug": "confirmation-rate",
    "problem_url": "https://leetcode.com/problems/confirmation-rate/"
  },
  {
    "question_id": 2087,
    "code": "/* Write your PL/SQL query statement below */\n-- select  user_id ,count(case when action='confirmed' then 1 end)/ count(*) as confirmation_rate from confirmations group by user_id;\n\nselect  s.user_id ,round(count(case when c.action='confirmed' then 1 end)/ count(s.user_id),2) as confirmation_rate from signups s left join confirmations c on s.user_id=c.user_id group by s.user_id;\n\n-- with jointest as(\n--     select *\n--      from signups s left join confirmations c on s.user_id=c.user_id; \n-- )\n-- select * from jointest;",
    "title_slug": "confirmation-rate",
    "problem_url": "https://leetcode.com/problems/confirmation-rate/"
  },
  {
    "question_id": 620,
    "code": "/* Write your PL/SQL query statement below */\nselect * from cinema where \ndescription<>'boring' and\nmod(id,2) <>0 \norder by rating desc;",
    "title_slug": "not-boring-movies",
    "problem_url": "https://leetcode.com/problems/not-boring-movies/"
  },
  {
    "question_id": 620,
    "code": "/* Write your PL/SQL query statement below */\nselect * from cinema where \nmod(id,2) <>0 and\ndescription<>'boring' \norder by rating desc;",
    "title_slug": "not-boring-movies",
    "problem_url": "https://leetcode.com/problems/not-boring-movies/"
  },
  {
    "question_id": 570,
    "code": "/* Write your PL/SQL query statement below */\n-- SELECT e1.name from employee e1 self join employee e2 on\n-- e1.managerId=null \n-- having ( count(e2.id)>5 and e1.id=e2.managerId);\n\n\n-- SELECT  name from employee where id in (select distinct e1.id from employee e1 join employee e2 on\n-- e1.id=e2.managerId where \n-- (select count(e2.id) from employee e2 where e2.managerId=e1.id)>=5) ;\n\nselect Employee.name from Employee, (select * from (SELECT managerId, count(managerId) as count FROM Employee GROUP BY managerId) where count >=5) E2 where Employee.id = E2.managerId",
    "title_slug": "managers-with-at-least-5-direct-reports",
    "problem_url": "https://leetcode.com/problems/managers-with-at-least-5-direct-reports/"
  },
  {
    "question_id": 570,
    "code": "/* Write your PL/SQL query statement below */\n-- SELECT e1.name from employee e1 self join employee e2 on\n-- e1.managerId=null \n-- having ( count(e2.id)>5 and e1.id=e2.managerId);\n\n\nSELECT  name from employee where id in (select distinct e1.id from employee e1 join employee e2 on\ne1.id=e2.managerId where \n(select count(e2.id) from employee e2 where e2.managerId=e1.id)>=5) ;\n\n-- select Employee.name from Employee, (select * from (SELECT managerId, count(managerId) as count FROM Employee GROUP BY managerId) where count >=5) E2 where Employee.id = E2.managerId",
    "title_slug": "managers-with-at-least-5-direct-reports",
    "problem_url": "https://leetcode.com/problems/managers-with-at-least-5-direct-reports/"
  },
  {
    "question_id": 570,
    "code": "/* Write your PL/SQL query statement below */\n-- SELECT e1.name from employee e1 self join employee e2 on\n-- e1.managerId=null \n-- having ( count(e2.id)>5 and e1.id=e2.managerId);\n\n\n-- SELECT  name from employee where id in (select distinct e1.id from employee e1 join employee e2 on\n-- e1.id=e2.managerId where \n-- (select count(e2.id) from employee e2 where e2.managerId=e1.id)>=5) ;\n\nselect Employee.name from Employee, (select * from (SELECT managerId, count(managerId) as count FROM Employee GROUP BY managerId) where count >=5) E2 where Employee.id = E2.managerId",
    "title_slug": "managers-with-at-least-5-direct-reports",
    "problem_url": "https://leetcode.com/problems/managers-with-at-least-5-direct-reports/"
  },
  {
    "question_id": 570,
    "code": "/* Write your PL/SQL query statement below */\n-- SELECT e1.name from employee e1 self join employee e2 on\n-- e1.managerId=null \n-- having ( count(e2.id)>5 and e1.id=e2.managerId);\n\n\n-- SELECT  name from employee where id in (select distinct e1.id from employee e1 join employee e2 on\n-- e1.id=e2.managerId where \n-- (select count(e2.id) from employee e2 where e2.managerId=e1.id)>=5) ;\n\nselect Employee.name from Employee, (select * from (SELECT managerId, count(managerId) as count FROM Employee GROUP BY managerId) where count >=5) E2 where Employee.id = E2.managerId",
    "title_slug": "managers-with-at-least-5-direct-reports",
    "problem_url": "https://leetcode.com/problems/managers-with-at-least-5-direct-reports/"
  },
  {
    "question_id": 570,
    "code": "/* Write your PL/SQL query statement below */\n-- SELECT e1.name from employee e1 self join employee e2 on\n-- e1.managerId=null \n-- having ( count(e2.id)>5 and e1.id=e2.managerId);\nSELECT  name from employee where id in (select distinct e1.id from employee e1 join employee e2 on\ne1.id=e2.managerId where \n(select count(e2.id) from employee e2 where e2.managerId=e1.id)>=5) ;",
    "title_slug": "managers-with-at-least-5-direct-reports",
    "problem_url": "https://leetcode.com/problems/managers-with-at-least-5-direct-reports/"
  },
  {
    "question_id": 322,
    "code": "/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\n\n//  function coinChange(coins, amount) {\n//     if (amount < 1)\n//         return 0;\n//     else\n//         return coinChangeSub(coins, amount, Array(amount).fill(0));\n// }\n\nfunction coinChangeSub(coins, amountRemaining, solutions) {\n    if (amountRemaining < 0) return -1;\n    if (amountRemaining === 0) return 0;\n    \n    if (solutions[amountRemaining - 1] !== 0)\n        return solutions[amountRemaining - 1];\n\n    var optimalSolution = Infinity;\n    \n    // Determine the optimal coin\n    for (const coin of coins) {\n        var solutionUsingThisCoin = coinChangeSub(coins, amountRemaining - coin, solutions);\n        if (solutionUsingThisCoin >= 0 && solutionUsingThisCoin < optimalSolution) {\n            optimalSolution = solutionUsingThisCoin + 1;\n        }\n    }\n    \n    if (optimalSolution === Infinity)\n        solutions[amountRemaining - 1] = -1;\n    else\n        solutions[amountRemaining - 1] = optimalSolution;\n\n    return solutions[amountRemaining - 1];\n}\n\nvar coinChange = function(coins, amount) {\n     if (amount < 1)\n        return 0;\n    else\n        return coinChangeSub(coins, amount, Array(amount).fill(0));\n};",
    "title_slug": "coin-change",
    "problem_url": "https://leetcode.com/problems/coin-change/"
  },
  {
    "question_id": 1415,
    "code": "/* Write your PL/SQL query statement below */\nSELECT\n    s.*, sub.*, COALESCE(COUNT(E.subject_name), 0) attended_exams\nFROM\n    students s\nCROSS JOIN\n    subjects sub\nLEFT JOIN\n    examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name\nGROUP BY\n    s.student_id,\n    s.student_name,\n    sub.subject_name\nORDER BY\n    s.student_id,\n    sub.subject_name;\n",
    "title_slug": "students-and-examinations",
    "problem_url": "https://leetcode.com/problems/students-and-examinations/"
  },
  {
    "question_id": 1415,
    "code": "/* Write your PL/SQL query statement below */\n-- SELECT\n--     s.student_id,\n--     s.student_name,\n--     sub.subject_name,\n--     COUNT(e.student_id) as attended_exams\n-- FROM\n--     students s\n-- CROSS JOIN\n--     subjects sub\n-- LEFT JOIN\n--     examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name\n-- GROUP BY\n--     s.student_id,\n--     s.student_name,\n--     sub.subject_name\n-- ORDER BY\n--     s.student_id,\n--     sub.subject_name;\nselect s1.student_id , s1.student_name , s2.subject_name , count(s3.subject_name) as \"attended_exams\" from Students s1 cross join Subjects s2 left outer join Examinations s3\non s1.student_id = s3.student_id and s2.subject_name = s3.subject_name\ngroup by s1.student_id , s1.student_name , s2.subject_name\norder by s1.student_id , s2.subject_name",
    "title_slug": "students-and-examinations",
    "problem_url": "https://leetcode.com/problems/students-and-examinations/"
  },
  {
    "question_id": 1415,
    "code": "/* Write your PL/SQL query statement below */\nSELECT\n    s.student_id,\n    s.student_name,\n    sub.subject_name,\n    COUNT(e.student_id) as attended_exams\nFROM\n    students s\nCROSS JOIN\n    subjects sub\nLEFT JOIN\n    examinations e ON s.student_id = e.student_id AND sub.subject_name = e.subject_name\nGROUP BY\n    s.student_id,\n    s.student_name,\n    sub.subject_name\nORDER BY\n    s.student_id,\n    sub.subject_name;\n",
    "title_slug": "students-and-examinations",
    "problem_url": "https://leetcode.com/problems/students-and-examinations/"
  },
  {
    "question_id": 577,
    "code": "/* Write your PL/SQL query statement below */\nselect e.name,b.bonus from Employee e left join Bonus b on  e.empId=b.empId \nwhere (b.bonus<1000 or b.bonus is null);",
    "title_slug": "employee-bonus",
    "problem_url": "https://leetcode.com/problems/employee-bonus/"
  },
  {
    "question_id": 577,
    "code": "/* Write your PL/SQL query statement below */\nselect e.name,b.bonus from Employee e left join Bonus b on  e.empId=b.empId \nwhere (b.bonus<1000 or b.bonus is null);",
    "title_slug": "employee-bonus",
    "problem_url": "https://leetcode.com/problems/employee-bonus/"
  },
  {
    "question_id": 1801,
    "code": "/* Write your PL/SQL query statement below */\n-- with processing_time(\n    \n-- )\nWITH CTE AS (\n    SELECT\n        a.machine_id,\n        a.timestamp AS end_timestamp,\n        b.timestamp AS start_timestamp\n    FROM\n        activity a\n    JOIN\n        activity b ON a.machine_id = b.machine_id\n    WHERE\n        a.activity_type = 'end'\n        AND b.activity_type = 'start'\n)\n\nSELECT\n    machine_id,\n    ROUND(SUM(end_timestamp - start_timestamp) / COUNT(machine_id), 3) AS processing_time\nFROM\n    CTE\nGROUP BY\n    machine_id;\n",
    "title_slug": "average-time-of-process-per-machine",
    "problem_url": "https://leetcode.com/problems/average-time-of-process-per-machine/"
  },
  {
    "question_id": 1801,
    "code": "/* Write your PL/SQL query statement below */\n-- with processing_time(\n    \n-- )\nselect a.machine_id,\n    round(Sum(a.timestamp - b.timestamp)/count(a.machine_id),3) as processing_time\n    from activity a join activity b on\na.machine_id= b.machine_id \nwhere a.activity_type='end' and b.activity_type='start'\ngroup by a.machine_id;\n",
    "title_slug": "average-time-of-process-per-machine",
    "problem_url": "https://leetcode.com/problems/average-time-of-process-per-machine/"
  },
  {
    "question_id": 197,
    "code": "/* Write your PL/SQL query statement below */\n-- select id from (Weather w1 self join weather w2 using id)  where (w1.id>w2.id and w1.recordDate-w2.recordDate=1 and w1.temperature> w2.temperature);\n\nselect w1.id from Weather w1 inner join Weather w2 on w1.recordDate-1=w2.recordDate and w1.temperature> w2.temperature;",
    "title_slug": "rising-temperature",
    "problem_url": "https://leetcode.com/problems/rising-temperature/"
  },
  {
    "question_id": 125,
    "code": "\n    class Solution {\n    public boolean isPalindrome(String s) {\n        StringBuilder sb = new StringBuilder();\n        for(int i = 0; i < s.length(); i++){\n            if(s.charAt(i) >= 'A' && s.charAt(i) <= 'Z'){\n                sb.append((char)(s.charAt(i)+32));\n            }\n            if(s.charAt(i) >= 'a' && s.charAt(i) <= 'z' || s.charAt(i) >= '0' && s.charAt(i) <= '9'){\n                sb.append(s.charAt(i));\n            }\n        }\n        boolean check = true;\n        int start = 0;\n        int end = sb.length()-1;\n        while(start<end){\n            char char1 = sb.charAt(start);\n            char char2 = sb.charAt(end);\n            if(char1 != char2){\n                check = false;\n                break;\n            }\n            start++;\n            end--;\n        }\n        return check;\n    }\n\n}",
    "title_slug": "valid-palindrome",
    "problem_url": "https://leetcode.com/problems/valid-palindrome/"
  },
  {
    "question_id": 125,
    "code": "class Solution {\n    boolean helper(String str, int i){\n        if(i>=str.length()/2) return true;\n\n        return str.charAt(i)== str.charAt(str.length()-i-1) && helper(str,i+1);\n    }\n    public boolean isPalindrome(String s) {\n        s=s.replaceAll(\"[^a-zA-Z0-9]\", \"\");\n        s=s.replace(\" \",\"\");\n        return helper(s.toLowerCase(),0);\n    }\n}",
    "title_slug": "valid-palindrome",
    "problem_url": "https://leetcode.com/problems/valid-palindrome/"
  },
  {
    "question_id": 1013,
    "code": "class Solution {\n    public int fib(int n) {\n        if (n == 0){\n            return 0;\n        }\n        if (n <= 2){\n            return 1;\n        }\n\n        return fib(n-1)+fib(n-2);\n    }\n}",
    "title_slug": "fibonacci-number",
    "problem_url": "https://leetcode.com/problems/fibonacci-number/"
  },
  {
    "question_id": 1013,
    "code": "class Solution {\n    public int fib(int n) {\n        if(n==0|| n==1)\n            return n;\n\n        return fib(n-1)+fib(n-2);\n    }\n}",
    "title_slug": "fibonacci-number",
    "problem_url": "https://leetcode.com/problems/fibonacci-number/"
  },
  {
    "question_id": 1153,
    "code": "/* Write your PL/SQL query statement below */\nselect product_name, year, price from sales left join product using (product_id);\n-- select product_name, year, price from sales left join product on sales.product_id= product.product_id;",
    "title_slug": "product-sales-analysis-i",
    "problem_url": "https://leetcode.com/problems/product-sales-analysis-i/"
  },
  {
    "question_id": 1509,
    "code": "/* Write your PL/SQL query statement below */\nselect unique_id ,name from Employees E left join EmployeeUNI U on E.id=U.id ;",
    "title_slug": "replace-employee-id-with-the-unique-identifier",
    "problem_url": "https://leetcode.com/problems/replace-employee-id-with-the-unique-identifier/"
  },
  {
    "question_id": 1827,
    "code": "/* Write your PL/SQL query statement below */\nselect tweet_id from tweets where length(content)>15;",
    "title_slug": "invalid-tweets",
    "problem_url": "https://leetcode.com/problems/invalid-tweets/"
  },
  {
    "question_id": 595,
    "code": "/* Write your PL/SQL query statement below */\nselect name , population, area from world where area>=3000000 or population>=25000000;",
    "title_slug": "big-countries",
    "problem_url": "https://leetcode.com/problems/big-countries/"
  },
  {
    "question_id": 595,
    "code": "# Write your MySQL query statement below\nselect name , population, area from world where area>=3000000 or population>=25000000;",
    "title_slug": "big-countries",
    "problem_url": "https://leetcode.com/problems/big-countries/"
  },
  {
    "question_id": 48,
    "code": "class Solution {\n    public void rotate(int[][] mat) {\n       int m=mat.length;\n       \n       int[][] mat2= new int[m][m];\n       for(int i=0;i<m;i++)\n        for(int j=0;j<m;j++)\n            mat2[i][j]=mat[i][j];\n\n        for(int i=0;i<m;i++)\n            for(int j=m-1,k=0;j>=0;j--,k++)\n                mat[i][k]=mat2[j][i];\n    }\n}",
    "title_slug": "rotate-image",
    "problem_url": "https://leetcode.com/problems/rotate-image/"
  },
  {
    "question_id": 1724,
    "code": "/* Write your PL/SQL query statement below */\n--select customer_id, count(visit_id) from visits where (visit_id not in (Select visit_id in transactions));\n\nselect customer_id, count(v.visit_id)  count_no_trans\nfrom visits v left join transactions t \non v.visit_id= t.visit_id \nwhere transaction_id is null\ngroup by customer_id;",
    "title_slug": "customer-who-visited-but-did-not-make-any-transactions",
    "problem_url": "https://leetcode.com/problems/customer-who-visited-but-did-not-make-any-transactions/"
  },
  {
    "question_id": 1258,
    "code": "/* Write your PL/SQL query statement below */\nselect distinct author_id as id from views where author_id=viewer_id order by author_id;",
    "title_slug": "article-views-i",
    "problem_url": "https://leetcode.com/problems/article-views-i/"
  },
  {
    "question_id": 584,
    "code": "/* Write your PL/SQL query statement below */\nselect name from customer where referee_id <> 2 or referee_id is null;",
    "title_slug": "find-customer-referee",
    "problem_url": "https://leetcode.com/problems/find-customer-referee/"
  },
  {
    "question_id": 1908,
    "code": "/* Write your PL/SQL query statement below */\nselect product_id from products where low_fats='Y' and recyclable='Y';",
    "title_slug": "recyclable-and-low-fat-products",
    "problem_url": "https://leetcode.com/problems/recyclable-and-low-fat-products/"
  },
  {
    "question_id": 121,
    "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n        int min = prices[0], max = 0;\n        for(int i = 1;i<prices.length;i++){\n            max = Math.max(max, prices[i]-min);\n            min = Math.min(min, prices[i]);\n        }\n        return max;\n    }\n}",
    "title_slug": "best-time-to-buy-and-sell-stock",
    "problem_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/"
  },
  {
    "question_id": 121,
    "code": "class Solution {\n    public int maxProfit(int[] prices) {\n        \n        //? minimum stock\n        int buyStock= Integer.MAX_VALUE;\n        //? max stock - min stock\n        int profit=0;\n\n        for(int i=0;i<prices.length;i++){\n            if(buyStock>prices[i]){\n                buyStock=prices[i];\n            }else{\n                profit= Math.max(profit,prices[i]-buyStock);\n            }\n        }\n        return profit;\n    }\n}",
    "title_slug": "best-time-to-buy-and-sell-stock",
    "problem_url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/"
  },
  {
    "question_id": 169,
    "code": "class Solution {\n    public int majorityElement(int[] nums) {\n       int count=1;\n       int result=nums[0];\n\n       for(int i=1;i<nums.length;i++){\n           if(count==0) \n               result=nums[i];\n           if(nums[i]==result) count++;\n           else count--;\n       }\n       return result;\n\n    }\n}",
    "title_slug": "majority-element",
    "problem_url": "https://leetcode.com/problems/majority-element/"
  },
  {
    "question_id": 169,
    "code": "import java.util.Arrays;\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        return nums[nums.length/2];\n        // int p1=0,p2=0;\n        // int count=0;\n        // while(p2!=nums.length){\n        //     if(nums[p1]==nums[p2]){\n        //         count++;\n        //         p2++;\n\n        //         if(count>nums.length/2) {\n        //             return nums[p1];\n        //         }\n        //     }\n        //     else{\n        //         p1=p2;\n        //         p2++;\n        //     }\n            \n        // }\n        // return -1;\n\n    }\n}",
    "title_slug": "majority-element",
    "problem_url": "https://leetcode.com/problems/majority-element/"
  },
  {
    "question_id": 169,
    "code": "import java.util.Arrays;\nclass Solution {\n    public int majorityElement(int[] nums) {\n        Arrays.sort(nums);\n        int p1=0,p2=0;\n        int count=0;\n        while(p2!=nums.length){\n            if(nums[p1]==nums[p2]){\n                count++;\n                p2++;\n\n                if(count>nums.length/2) {\n                    return nums[p1];\n                }\n            }\n            else{\n                p1=p2;\n                p2++;\n            }\n            \n        }\n        return -1;\n\n    }\n}",
    "title_slug": "majority-element",
    "problem_url": "https://leetcode.com/problems/majority-element/"
  },
  {
    "question_id": 817,
    "code": "class MyHashMap {\n    int data[1000001];\npublic:\n    MyHashMap() {\n        fill(data,data + 1000000,-1);\n    }\n    \n    void put(int key, int value) {\n        data[key]=value;\n    }\n    \n    int get(int key) {\n        return data[key];\n    }\n    \n    void remove(int key) {\n        data[key]=-1;\n    }\n};\n\n/**\n * Your MyHashMap object will be instantiated and called as such:\n * MyHashMap* obj = new MyHashMap();\n * obj->put(key,value);\n * int param_2 = obj->get(key);\n * obj->remove(key);\n */",
    "title_slug": "design-hashmap",
    "problem_url": "https://leetcode.com/problems/design-hashmap/"
  },
  {
    "question_id": 138,
    "code": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    Node* next;\n    Node* random;\n    \n    Node(int _val) {\n        val = _val;\n        next = NULL;\n        random = NULL;\n    }\n};\n*/\n\nclass Solution {\npublic:\n\n  Node* copyRandomList(Node* head) {\n    if (!head) return nullptr;\n\n    // First pass: create new nodes and link them to the original list\n    Node* temp = head;\n    while (temp) {\n        Node* copy = new Node(temp->val);\n        copy->next = temp->next;\n        temp->next = copy;\n        temp = copy->next;\n    }\n\n    // Second pass: set random pointers for the new nodes\n    temp = head;\n    while (temp) {\n        if (temp->random) {\n            temp->next->random = temp->random->next;\n        }\n        temp = temp->next ? temp->next->next : nullptr;\n    }\n\n    // Third pass: restore the original list and extract the copy list\n    temp = head;\n    Node* copyHead = head->next;\n    Node* copy = copyHead;\n    while (temp) {\n        temp->next = temp->next ? temp->next->next : nullptr;\n        copy->next = copy->next ? copy->next->next : nullptr;\n        temp = temp->next;\n        copy = copy->next;\n    }\n\n    return copyHead;\n}\n\n};",
    "title_slug": "copy-list-with-random-pointer",
    "problem_url": "https://leetcode.com/problems/copy-list-with-random-pointer/"
  },
  {
    "question_id": 61,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    \n    ListNode* rotateRight(ListNode* head, int k) {\n    if(!head || !head->next) return head;\n    ListNode* temp=head;\n    int length=1;  \n     while(temp->next){\n          length++;\n          temp=temp->next;\n     }\n     temp->next=head;\n     k%=length;\n     k=length-k;\n\n     while(k--){\n          temp=temp->next;\n     }\n     head=temp->next;\n     temp->next=nullptr;\n     return head;\n    }\n};",
    "title_slug": "rotate-list",
    "problem_url": "https://leetcode.com/problems/rotate-list/"
  },
  {
    "question_id": 61,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    int getLength(ListNode* head){\n     ListNode* temp=head;\n     int length=0;  \n     while(temp){\n          length++;\n          temp=temp->next;\n     }\n     return length;\n    }\n    ListNode* rotateRight(ListNode* head, int k) {\n    if(!head || !head->next) return head;\n    ListNode* temp;\n    ListNode* start;\n    int length=getLength(head);\n     for(int i=0;i<k%length;i++){\n          temp=head;\n          while(temp->next->next!=nullptr) temp=temp->next;\n          start=temp->next;\n          temp->next=nullptr;\n          start->next=head;\n          head=start;\n     }\n     return head;\n    }\n};",
    "title_slug": "rotate-list",
    "problem_url": "https://leetcode.com/problems/rotate-list/"
  },
  {
    "question_id": 25,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\n// class Solution {\n// public:\n//     //  void reverseGroup(ListNode *head,int k){\n//     //     ListNode* kNode=head;\n//     //     ListNode* previous= head;\n//     //     ListNode* nextNode= head->next;\n//     //     ListNode* temp= head;\n\n//     //     for(int i=0;i<k-1 && kNode->next ;i++) kNode=kNode->next;\n//     //     temp->next=kNode->next;\n\n//     //     for(int i=0;i<k-1;i++){\n//     //         temp=nextNode;\n//     //         nextNode=nextNode->next;\n//     //         temp->next=previous;\n//     //         previous=temp;\n//     //     }\n//     // }\n//     // ListNode* reverseKGroup(ListNode* head, int k) {\n//     //     // reverse the linked list\n//     //     ListNode* kNode=head;\n//     //     ListNode* previous= head;\n//     //     ListNode* nextNode= head->next;\n//     //     ListNode* temp= head;\n\n//     //     for(int i=0;i<k-1 && kNode->next ;i++) kNode=kNode->next;\n//     //     temp->next=kNode->next;\n\n//     //     for(int i=0;i<k-1;i++){\n//     //         temp=nextNode;\n//     //         nextNode=nextNode->next;\n//     //         temp->next=previous;\n//     //         previous=temp;\n//     //     }\n//     //     head=temp;\n//     //     return head;\n//     // }\n// };\n\nclass Solution {\n    \npublic:\nint lengthOfLinkedList(ListNode *head) {\n    ListNode* temp=head;\n    int length=0;\n    while(temp){\n        temp=temp->next;\n        length++;\n    }\n    return length;\n}\n\n ListNode* reverseKGroup(ListNode* head, int k) {\n    if(head == NULL||head->next == NULL) return head;\n    \n    int length = lengthOfLinkedList(head);\n    \n    ListNode* dummyHead = new ListNode(0);\n    dummyHead->next = head;\n    \n    ListNode* pre = dummyHead;\n    ListNode* cur;\n    ListNode* nex;\n    \n    while(length >= k) {\n        cur = pre->next;\n        nex = cur->next;\n        for(int i=1;i<k;i++) {\n            cur->next = nex->next;\n            nex->next = pre->next;\n            pre->next = nex;\n            nex = cur->next;\n        }\n        pre = cur;\n        length -= k;\n    }\n    return dummyHead->next;\n    }\n};",
    "title_slug": "reverse-nodes-in-k-group",
    "problem_url": "https://leetcode.com/problems/reverse-nodes-in-k-group/"
  },
  {
    "question_id": 932,
    "code": "class Solution {\n    public boolean isMonotonic(int[] nums) {\n        if(nums.length==1) return true;\n        if(nums[0]>nums[nums.length-1]){\n            for(int i=0;i<nums.length-1;i++){\n                if(nums[i]<nums[i+1]) return false;\n            }\n        }\n        else if(nums[0]<nums[nums.length-1]){\n            for(int i=0;i<nums.length-1;i++){\n                if(nums[i]>nums[i+1]) return false;\n            }\n        }\n        else {\n            for(int i=0;i<nums.length-1;i++){\n                if(nums[i]!=nums[i+1]) return false;\n            }\n        }\n        \n        return true;\n    }\n}",
    "title_slug": "monotonic-array",
    "problem_url": "https://leetcode.com/problems/monotonic-array/"
  },
  {
    "question_id": 160,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        ListNode* tempA=headA;\n        ListNode* tempB= headB;\n\n        while(tempA!=tempB){\n            tempA=tempA==NULL?headB:tempA->next;\n            tempB=tempB==NULL?headA:tempB->next;\n        }\n\n        return tempA;\n    }\n};",
    "title_slug": "intersection-of-two-linked-lists",
    "problem_url": "https://leetcode.com/problems/intersection-of-two-linked-lists/"
  },
  {
    "question_id": 160,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {\n        int size1=0;\n        int size2=0;\n        ListNode* temp=headA;\n        while(temp){\n            temp=temp->next;\n            size1++;\n        }\n        temp=headB;\n        while(temp){\n            temp=temp->next;\n            size2++;\n        }\n\n        if(size1>size2){\n            temp=headA;\n            for(int i=0;(i<size1-size2) && temp;i++) temp=temp->next;\n            headA=temp;\n        }\n        else if(size2>size1) {\n            temp=headB;\n            for(int i=0;(i<size2-size1) && temp;i++) temp=temp->next;\n            headB=temp;\n        }\n        if(headA==headB) return headA;\n        while(headA && headB){\n            if(headA->next==headB->next) return headA->next;\n            headA=headA->next;\n            headB=headB->next;\n        }\n        return nullptr;\n    }\n};",
    "title_slug": "intersection-of-two-linked-lists",
    "problem_url": "https://leetcode.com/problems/intersection-of-two-linked-lists/"
  },
  {
    "question_id": 148,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* a, ListNode* b) {\n        if(!a)\n            return b;\n        if(!b) \n        return a;\n        ListNode* sorted= new ListNode();\n        ListNode* headNode=sorted;\n        while(a && b){\n            if(a->val<=b->val){\n                sorted->next=a;\n                a=a->next;\n                sorted=sorted->next;\n            }\n            else{\n                sorted->next=b;\n                b=b->next;\n                sorted=sorted->next;\n            }\n        }\n        if(a) sorted->next=a;\n        if(b) sorted->next=b;\n        return headNode->next;\n    }\n\n    ListNode* midList(ListNode* head) {\n        ListNode *slow=head;\n        ListNode *temp=slow;\n        ListNode *fast=head;\n        while(fast && fast->next){\n            temp=slow;\n            slow=slow->next;\n            fast=fast->next->next;\n        }\n        return temp;\n    }\n    ListNode* sortList(ListNode* head) {\n        if(!head || !head->next) return head;\n\n        ListNode* mid= midList(head);\n        ListNode* midNext= mid->next;\n        mid->next=nullptr;\n        ListNode* list1= sortList(head);\n        ListNode* list2= sortList(midNext);\n        return mergeTwoLists(list1,list2);\n\n    }\n\n};",
    "title_slug": "sort-list",
    "problem_url": "https://leetcode.com/problems/sort-list/"
  },
  {
    "question_id": 21,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* mergeTwoLists(ListNode* a, ListNode* b) {\n         if(!a)\n            return b;\n        if(!b) \n        return a;\n        ListNode* sorted= new ListNode();\n        ListNode* headNode=sorted;\n        while(a && b){\n            if(a->val<=b->val){\n                sorted->next=a;\n                a=a->next;\n                sorted=sorted->next;\n            }\n            else{\n                sorted->next=b;\n                b=b->next;\n                sorted=sorted->next;\n            }\n        }\n        if(a) sorted->next=a;\n        if(b) sorted->next=b;\n        return headNode->next;\n    }\n};",
    "title_slug": "merge-two-sorted-lists",
    "problem_url": "https://leetcode.com/problems/merge-two-sorted-lists/"
  },
  {
    "question_id": 941,
    "code": "class Solution {\n    public int[] sortArrayByParity(int[] nums) {\n       int start=0;\n       int end=nums.length-1;\n        if(end==0) return nums;\n       while(start<end){\n           if(nums[start]%2==0) start++;\n            else if(nums[end]%2!=0) end--;\n           else {\n               int temp=nums[end];\n               nums[end]=nums[start];\n               nums[start]=temp;\n               end--;\n               start++;\n           }\n       }\n       return nums;\n\n\n    }\n}",
    "title_slug": "sort-array-by-parity",
    "problem_url": "https://leetcode.com/problems/sort-array-by-parity/"
  },
  {
    "question_id": 941,
    "code": "class Solution {\n    public int[] sortArrayByParity(int[] nums) {\n       int start=0;\n       int end=nums.length-1;\n        if(end==0) return nums;\n       while(start<end){\n           if(nums[start]%2==0) start++;\n            else if(nums[end]%2!=0) end--;\n           else {\n               int temp=nums[end];\n               nums[end]=nums[start];\n               nums[start]=temp;\n               end--;\n           }\n       }\n       return nums;\n\n\n    }\n}",
    "title_slug": "sort-array-by-parity",
    "problem_url": "https://leetcode.com/problems/sort-array-by-parity/"
  },
  {
    "question_id": 941,
    "code": "class Solution {\n    public int[] sortArrayByParity(int[] nums) {\n        boolean swapped=false;\n\n        for(int i=0;i<nums.length;i++){\n            for(int j=0;j<nums.length-i-1;j++){\n                if(nums[j]%2!=0){\n                    int temp= nums[j];\n                    nums[j]=nums[j+1];\n                    nums[j+1]=temp;\n                    swapped=true;\n                }\n            }\n            if(!swapped) return nums;\n        }\n        return nums;\n    }\n}",
    "title_slug": "sort-array-by-parity",
    "problem_url": "https://leetcode.com/problems/sort-array-by-parity/"
  },
  {
    "question_id": 19,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNthFromEnd(ListNode* head, int n) {\n        if(!head || !head->next) return nullptr;\n        ListNode* fast=head;\n        ListNode* slow=head;\n\n        for(int i=0;i<n;i++)\n            fast=fast->next;\n\n        if(!fast){\n            slow=slow->next;\n            return slow;\n        }\n        while(fast->next){\n            slow=slow->next;\n            fast=fast->next;\n        }\n        slow->next= slow->next->next;\n        return head;\n    }\n};",
    "title_slug": "remove-nth-node-from-end-of-list",
    "problem_url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/"
  },
  {
    "question_id": 328,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* oddEvenList(ListNode* head) {\n    if(!head || !head->next) return head;\n    ListNode* even=nullptr;\n    ListNode* odd=nullptr;\n    ListNode* evenHead=nullptr;\n    ListNode* temp=head;\n    int index=1;\n    \n    while(temp){\n        // temp_next=temp->next;\n        if(index%2==0){\n            if(!even){\n            even=temp;\n            evenHead=even;\n            }\n            else{\n                even->next=temp;\n                even=temp;\n            }\n        }else{\n            if(!odd){\n                odd=temp;\n                head=odd;\n            }\n            else{\n                odd->next=temp;\n                odd=temp;\n            }\n        }\n        temp=temp->next;\n        index++;\n    }\n    odd->next=evenHead;\n    even->next=nullptr;\n    return head;\n\n    }\n};",
    "title_slug": "odd-even-linked-list",
    "problem_url": "https://leetcode.com/problems/odd-even-linked-list/"
  },
  {
    "question_id": 206,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n       ListNode *newHead = NULL;\n        while (head != NULL) {\n            ListNode *next = head->next;\n            head->next = newHead;\n            newHead = head;\n            head = next;\n        }\n        return newHead;\n    }\n};",
    "title_slug": "reverse-linked-list",
    "problem_url": "https://leetcode.com/problems/reverse-linked-list/"
  },
  {
    "question_id": 234,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(NULL) {}\n *     ListNode(int x) : val(x), next(NULL) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        ListNode* slow=head;\n        ListNode* fast=head;\n\n        while(fast && fast->next){\n            slow=slow->next;\n            fast=fast->next->next;\n        }\n\n        if(fast && fast->next)\n            slow=slow->next;\n\n        ListNode* temp=NULL;\n        ListNode* previous=NULL;\n\n        while(slow!=NULL && slow->next!=NULL){\n            temp=slow->next;\n            slow->next=previous;\n            previous=slow;\n            slow=temp;\n        }\n\n        if(slow!=NULL) slow->next=previous;\n        fast=head;\n        while(slow!=NULL){\n            if(slow->val!=fast->val) return false;\n            slow=slow->next;\n            fast=fast->next;    \n        }\n        return true;\n    }\n};",
    "title_slug": "palindrome-linked-list",
    "problem_url": "https://leetcode.com/problems/palindrome-linked-list/"
  },
  {
    "question_id": 234,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    bool isPalindrome(ListNode* head) {\n        ListNode* slow=head;\n        ListNode* fast=head;\n\n        while(fast && fast->next){\n            slow=slow->next;\n            fast=fast->next->next;\n        }\n\n        if(fast && fast->next)\n            slow=slow->next;\n\n        ListNode* temp=nullptr;\n        ListNode* previous=nullptr;\n\n        while(slow!=nullptr && slow->next!=nullptr){\n            temp=slow->next;\n            slow->next=previous;\n            previous=slow;\n            slow=temp;\n        }\n\n        if(slow!=nullptr) slow->next=previous;\n        fast=head;\n        while(slow!=nullptr){\n            if(slow->val!=fast->val) return false;\n            slow=slow->next;\n            fast=fast->next;    \n        }\n        return true;\n    }\n};",
    "title_slug": "palindrome-linked-list",
    "problem_url": "https://leetcode.com/problems/palindrome-linked-list/"
  },
  {
    "question_id": 142,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        // if(!head || !head->next) return nullptr;\n        ListNode* slow=head;\n        ListNode* fast=head;\n        while(fast && fast->next ){\n            fast=fast->next->next;\n            slow=slow->next;\n            if(slow==fast){\n                slow=head;\n                while(slow!=fast){\n                    slow=slow->next;\n                    fast=fast->next;\n                }\n                return slow;\n            }\n        }\n        return nullptr;\n    }\n};",
    "title_slug": "linked-list-cycle-ii",
    "problem_url": "https://leetcode.com/problems/linked-list-cycle-ii/"
  },
  {
    "question_id": 142,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        // if(!head || !head->next) return nullptr;\n        ListNode* slow=head;\n        ListNode* fast=head;\n        while(fast && fast->next ){\n            fast=fast->next->next;\n            slow=slow->next;\n            if(slow==fast){\n                slow=head;\n                while(slow!=fast){\n                    slow=slow->next;\n                    fast=fast->next;\n                }\n                return slow;\n            }\n        }\n        return nullptr;\n    }\n};",
    "title_slug": "linked-list-cycle-ii",
    "problem_url": "https://leetcode.com/problems/linked-list-cycle-ii/"
  },
  {
    "question_id": 142,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        if(!head || !head->next) return nullptr;\n        ListNode* slow=head;\n        ListNode* fast=head;\n        while(fast && fast->next ){\n            fast=fast->next->next;\n            slow=slow->next;\n            if(slow && fast && slow==fast){\n                slow=head;\n                while(slow!=fast){\n                    slow=slow->next;\n                    fast=fast->next;\n                }\n                return slow;\n            }\n        }\n        return nullptr;\n    }\n};",
    "title_slug": "linked-list-cycle-ii",
    "problem_url": "https://leetcode.com/problems/linked-list-cycle-ii/"
  },
  {
    "question_id": 141,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        if(!head || !head->next) return false;\n        ListNode* slow=head;\n        ListNode* fast=head;\n        while(fast && fast->next ){\n            fast=fast->next->next;\n            if(slow && fast && slow->next==fast->next) return true;\n            if(fast==head) return false;\n            slow=slow->next;\n        }\n        return false;\n\n    }\n};",
    "title_slug": "linked-list-cycle",
    "problem_url": "https://leetcode.com/problems/linked-list-cycle/"
  },
  {
    "question_id": 2216,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteMiddle(ListNode* head) {\n        if(head==nullptr || head->next==nullptr) return nullptr;\n        ListNode* fast= head;\n        ListNode* slow= head;\n        ListNode* beforeSlow= nullptr;\n        while(fast!=nullptr && fast->next!=nullptr){\n            beforeSlow=slow;\n            slow=slow->next;\n            fast=fast->next->next;\n        }\n        beforeSlow->next=slow->next;\n        return head;\n    }\n};",
    "title_slug": "delete-the-middle-node-of-a-linked-list",
    "problem_url": "https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/"
  },
  {
    "question_id": 2216,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteMiddle(ListNode* head) {\n        if(!head || !head->next) return nullptr;\n        ListNode* fast= head;\n        ListNode* slow= head;\n        ListNode* beforeSlow= nullptr;\n        while(fast && fast->next){\n            beforeSlow=slow;\n            slow=slow->next;\n            fast=fast->next->next;\n        }\n\n        beforeSlow->next=slow->next;\n        return head;\n    }\n};",
    "title_slug": "delete-the-middle-node-of-a-linked-list",
    "problem_url": "https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/"
  },
  {
    "question_id": 2216,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteMiddle(ListNode* head) {\n        if(!head || !head->next) return nullptr;\n        ListNode* fast= head;\n        ListNode* slow= head;\n        ListNode* beforeSlow= nullptr;\n        while(fast && fast->next){\n            fast=fast->next->next;\n\n            beforeSlow=slow;\n            slow=slow->next;\n        }\n\n        beforeSlow->next=slow->next;\n        return head;\n    }\n};",
    "title_slug": "delete-the-middle-node-of-a-linked-list",
    "problem_url": "https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/"
  },
  {
    "question_id": 2216,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* deleteMiddle(ListNode* head) {\n        if(!head || !head->next) return nullptr;\n        ListNode* fast= head;\n        ListNode* slow= head;\n        ListNode* beforeSlow= head;\n        while(fast && fast->next){\n            fast=fast->next->next;\n\n            beforeSlow=slow;\n            slow=slow->next;\n        }\n\n        beforeSlow->next=slow->next;\n        return head;\n    }\n};",
    "title_slug": "delete-the-middle-node-of-a-linked-list",
    "problem_url": "https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/"
  },
  {
    "question_id": 908,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* fast= head;\n        ListNode* slow =head;\n        while(fast && fast->next){\n            fast=fast->next->next;\n\n            slow=slow->next;\n        }\n        return slow;\n    }\n};",
    "title_slug": "middle-of-the-linked-list",
    "problem_url": "https://leetcode.com/problems/middle-of-the-linked-list/"
  },
  {
    "question_id": 908,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        ListNode* fast= head;\n        ListNode* slow =head;\n        while(fast && fast->next){\n            fast=fast->next->next;\n\n            slow=slow->next;\n        }\n        return slow;\n    }\n};",
    "title_slug": "middle-of-the-linked-list",
    "problem_url": "https://leetcode.com/problems/middle-of-the-linked-list/"
  },
  {
    "question_id": 908,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* middleNode(ListNode* head) {\n        if(head==nullptr || head->next==nullptr) return head;\n        ListNode* temp=head;\n        int length=1;\n        while(temp->next!=nullptr){\n            length++;\n            temp=temp->next;\n        }\n\n        temp=head;\n        for(int i=0;i<length/2;i++){\n            temp=temp->next;\n        }\n        \n        return temp;\n    }\n};",
    "title_slug": "middle-of-the-linked-list",
    "problem_url": "https://leetcode.com/problems/middle-of-the-linked-list/"
  },
  {
    "question_id": 206,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if(head==nullptr || head->next==nullptr) return head;\n       \n    ListNode* saveHead=head;\n    ListNode* temp= head->next;\n    ListNode* previous= head;\n    \n    while(temp->next!=nullptr){\n        head=temp;\n        temp=temp->next;\n        head->next=previous;\n        previous=head;\n    }\n\n    head=temp;\n    head->next=previous;\n    saveHead->next=nullptr;\n    return head;\n    }\n};",
    "title_slug": "reverse-linked-list",
    "problem_url": "https://leetcode.com/problems/reverse-linked-list/"
  },
  {
    "question_id": 237,
    "code": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    void deleteNode(ListNode* node) {\n    ListNode *temp = node;\n    while(temp->next->next!=nullptr)\n    {   temp->val= temp->next->val;\n        temp= temp->next;\n        \n    }\n    temp->val= temp->next->val;\n    temp->next=nullptr;\n   \n    }\n};",
    "title_slug": "delete-node-in-a-linked-list",
    "problem_url": "https://leetcode.com/problems/delete-node-in-a-linked-list/"
  },
  {
    "question_id": 812,
    "code": "class Solution {\npublic:\n    bool rotateString(string p, string q) {\n        queue<char> q1, q2;\n    for(int i=0;i<p.size();i++){\n          q1.push(p[i]);\n          q2.push(q[i]);\n    }\n      int k = q2.size() -1;\n    while(k>0){\n          if(q1==q2) return 1;\n          char ch= q2.front();\n          q2.pop();\n          q2.push(ch);\n          k--;\n    }\n    return 0;\n    }\n};",
    "title_slug": "rotate-string",
    "problem_url": "https://leetcode.com/problems/rotate-string/"
  },
  {
    "question_id": 812,
    "code": "class Solution {\n    public boolean rotateString(String s, String goal) {\n        s= s+s;\n        return s.contains(goal) && (s.length()/2==goal.length());\n    }\n}",
    "title_slug": "rotate-string",
    "problem_url": "https://leetcode.com/problems/rotate-string/"
  },
  {
    "question_id": 1078,
    "code": "class Solution {\npublic:\n    string removeOuterParentheses(string s) {\n        string ansStr=\"\";\n        int count=0;\n        for(int i=0;i<s.length();i++){\n\n            if('(' == s[i] ){\n                count++;\n                if(count!=1)\n                    ansStr += s[i];\n            }\n            else {\n                count--;\n                if(count!=0)\n                    ansStr += s[i];\n                }\n                \n            if(!count) continue;\n\n        }\n        return ansStr;\n    }\n};",
    "title_slug": "remove-outermost-parentheses",
    "problem_url": "https://leetcode.com/problems/remove-outermost-parentheses/"
  },
  {
    "question_id": 242,
    "code": "class Solution {\n    public boolean isAnagram(String s, String t) {\n        char[] sChars = s.toCharArray();\n        char[] tChars = t.toCharArray();\n        \n        Arrays.sort(sChars);\n        Arrays.sort(tChars);\n        \n        return Arrays.equals(sChars, tChars);\n    }\n}",
    "title_slug": "valid-anagram",
    "problem_url": "https://leetcode.com/problems/valid-anagram/"
  },
  {
    "question_id": 151,
    "code": "class Solution {\n    public String reverseWords(String s) {\n       // Trim the input string to remove leading and trailing spaces\n        String[] str = s.trim().split(\"\\\\s+\");\n\n        // Initialize the output string\n        String out = \"\";\n\n        // Iterate through the words in reverse order\n        for (int i = str.length - 1; i > 0; i--) {\n            // Append the current word and a space to the output\n            out += str[i] + \" \";\n        }\n\n        // Append the first word to the output (without trailing space)\n        return out + str[0];\n    }\n}",
    "title_slug": "reverse-words-in-a-string",
    "problem_url": "https://leetcode.com/problems/reverse-words-in-a-string/"
  },
  {
    "question_id": 2271,
    "code": "class Solution {\n    public int[] rearrangeArray(int[] nums) {\n       int one=0;\n       int two =1;\n\n       int[] answer = new int[nums.length];\n       int i=0;\n       while(i<nums.length)\n        {   \n\n\n            if(nums[i]>0){ \n                answer[one]=nums[i];\n                one+=2;\n            }else{\n                answer[two]=nums[i];\n                two+=2;\n            }\n            i++;\n        }\n        return answer;\n    }\n}",
    "title_slug": "rearrange-array-elements-by-sign",
    "problem_url": "https://leetcode.com/problems/rearrange-array-elements-by-sign/"
  },
  {
    "question_id": 2271,
    "code": "class Solution {\n    public int[] rearrangeArray(int[] nums) {\n        int even=0,odd=0;\n        int[] answer = new int[nums.length];\n        int index=0;\n        while(index<nums.length ){\n            if( even<nums.length && nums[even]<0 ){\n                even++; continue;\n            }\n            if( odd<nums.length && nums[odd]>0){\n                odd++; continue;\n            }\n\n            if(index%2==0){ \n                answer[index]=nums[even];\n                even++;\n            }else{ \n                answer[index]=nums[odd];\n                odd++;\n            }\n            index++;\n\n        }\n        return answer;\n    }\n}",
    "title_slug": "rearrange-array-elements-by-sign",
    "problem_url": "https://leetcode.com/problems/rearrange-array-elements-by-sign/"
  },
  {
    "question_id": 75,
    "code": "class Solution {\n    public void sortColors(int[] nums) {\n        Arrays.sort(nums);\n    }\n}",
    "title_slug": "sort-colors",
    "problem_url": "https://leetcode.com/problems/sort-colors/"
  },
  {
    "question_id": 1,
    "code": "class Solution {\n  \n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer,Integer>hashMap= new HashMap<>();\n\n        for(int i=0;i<nums.length;i++){\n            int sum=target-nums[i];\n            if(hashMap.containsKey(sum)){\n                return new int[] {i,hashMap.get(sum)};\n            }\n            hashMap.put(nums[i],i);\n        }\n        return new int[] {};\n  }\n}",
    "title_slug": "two-sum",
    "problem_url": "https://leetcode.com/problems/two-sum/"
  },
  {
    "question_id": 1,
    "code": "class Solution {\n\n  \n    \n    public int[] twoSum(int[] nums, int target) {\n    \n       int[][] numsWithIndex = new int[nums.length][2];\n    for (int i = 0; i < nums.length; i++) {\n        numsWithIndex[i][0] = nums[i];\n        numsWithIndex[i][1] = i;\n    }\n\n\n    Arrays.sort(numsWithIndex, Comparator.comparingInt(arr -> arr[0]));\n    int left = 0, right = nums.length - 1;\n    while (left < right) {\n        int sum = numsWithIndex[left][0] + numsWithIndex[right][0];\n        if (sum == target) {\n            return new int[] {numsWithIndex[left][1], numsWithIndex[right][1]};\n        } else if (sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n    return new int[]{}; // No solution found!\n    }\n}",
    "title_slug": "two-sum",
    "problem_url": "https://leetcode.com/problems/two-sum/"
  },
  {
    "question_id": 1646,
    "code": "class Solution {\n   \n    public int findKthPositive(int[] arr, int k) {\n       int start = 0;\n        int end = arr.length - 1;\n        int mid;\n        while (start <= end) {\n            mid = (start + end) / 2;\n            int missingNumbers = arr[mid] - (mid + 1);\n            if (missingNumbers < k)\n                start = mid + 1;\n            else\n                end = mid - 1;\n        }\n        \n        //?  at the end of the while loop the answer will be arr[high] + k - missing number and start = high +1\n        //? but since for  [4,5,6] k=3 high will point to -1 which will result in error\n        //? missingNumber = arr[high]-(high +1) = arr[high] -start\n        //? ans =  arr[high] + k -(arr[high] - start) =  start+k \n        return start+k; \n    }\n}",
    "title_slug": "kth-missing-positive-number",
    "problem_url": "https://leetcode.com/problems/kth-missing-positive-number/"
  },
  {
    "question_id": 1646,
    "code": "class Solution {\n    public static boolean binarySearch(int[] arr,int target){\n        int start=0,end=arr.length-1;\n        int mid;\n        while(start<=end){\n            mid=(start+end)/2;\n\n            if(arr[mid]==target)\n                return true;\n            else if(target>arr[mid])\n                start=mid+1;\n            else end= mid-1;\n        }\n        return false;\n    }\n    public int findKthPositive(int[] arr, int k) {\n        int i=0;\n        int j=1;\n        int num=j;\n        while(i<k){\n            if(!binarySearch(arr,j)){\n                num=j;\n                i++;             \n              }\n            \n            j++;\n            \n        }\n        return num;\n    }\n}",
    "title_slug": "kth-missing-positive-number",
    "problem_url": "https://leetcode.com/problems/kth-missing-positive-number/"
  },
  {
    "question_id": 540,
    "code": "class Solution {\n    \n        public int singleNonDuplicate(int[] nums) {\n    int start = 0, end = nums.length - 1;\n    \n    while (start < end) {\n        int mid = start + (end - start) / 2;\n        \n        // Check if mid is even and the next element is the same.\n        if (mid % 2 == 0 && nums[mid] == nums[mid + 1]) {\n            start = mid + 2; // Move two steps to the right.\n        } \n        // Check if mid is odd and the previous element is the same.\n        else if (mid % 2 == 1 && nums[mid] == nums[mid - 1]) {\n            start = mid + 1; // Move one step to the right.\n        } \n        // Otherwise, the single element must be to the left of mid.\n        else {\n            end = mid;\n        }\n    }\n    \n    return nums[start];\n\n\n    }\n}",
    "title_slug": "single-element-in-a-sorted-array",
    "problem_url": "https://leetcode.com/problems/single-element-in-a-sorted-array/"
  },
  {
    "question_id": 540,
    "code": "class Solution {\n    public int singleNonDuplicate(int[] nums) {\n\n        int start=0,end=nums.length-1,mid;\n        if(end==0) return nums[0];\n        while(start<=end){\n            mid = (end+start)/2;\n            boolean isNotEqualPrevious=mid == 0 || nums[mid]!=nums[mid-1];\n            boolean isNotEqualNext=mid == nums.length-1 || nums[mid]!=nums[mid+1];\n            if(isNotEqualPrevious&&isNotEqualNext)\n                return nums[mid];\n            else if(!isNotEqualPrevious){\n                if((mid-1-start)%2==0)\n                    start=mid+1;\n                else end=mid-2;\n                // else start=mid+1;\n            }\n            else {\n                if((mid-start)%2==0)\n                 start=mid+2;\n                else end=mid-1;\n            }\n        }\n        return -1;\n    }\n}",
    "title_slug": "single-element-in-a-sorted-array",
    "problem_url": "https://leetcode.com/problems/single-element-in-a-sorted-array/"
  },
  {
    "question_id": 88,
    "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n    int[] mix=new int[m+n];\n\n        int i = 0;\n        int j = 0;\n        int k = 0;\n        //int p = m+n;\n        \n        while(i<m && j<n){\n            if(nums1[i] < nums2[j]){\n                mix[k]=nums1[i];\n                i++;\n            }else{\n                mix[k]=nums2[j];\n                j++;\n            }\n            k++;\n        }\n        while(i < m){\n            mix[k]=nums1[i];\n            i++;\n            k++;\n        }\n        while(j< n){\n            mix[k]=nums2[j];\n            j++;\n            k++;\n        }\n        for(int l=0;l<mix.length;l++){\n            nums1[l]=mix[l];\n        }\n    }\n}",
    "title_slug": "merge-sorted-array",
    "problem_url": "https://leetcode.com/problems/merge-sorted-array/"
  },
  {
    "question_id": 88,
    "code": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        // if(m==0) {\n        //     nums1=nums2;\n        //     return;\n        // }\n        // if(n==0){\n        //     return;\n        // }\n\n        // int i=0;\n        // int j=0;\n\n        // while(i<m && j<n){\n        //     if(nums1[i]<nums2[j]) i++;\n        //     else if(nums1[i]>nums2[j]){\n        //         int temp= nums1[i];\n        //         nums1[i]=nums2[j];\n        //         nums2[j]=temp;\n        //         i++;\n        //     }else{\n        //         int temp= nums1[i+1];\n        //         nums1[i+1]=nums2[j];\n        //         nums2[j]=temp;\n        //         i++; \n        //     }\n\n        // }\n        \n        // while(j<n){\n        //     nums1[i]=nums2[j];\n        //     j++;\n        // }\n        for (int j = 0, i = m; j < n; j++) {\n            nums1[i] = nums2[j];\n            i++;\n        }\n        Arrays.sort(nums1);\n        \n    }\n}",
    "title_slug": "merge-sorted-array",
    "problem_url": "https://leetcode.com/problems/merge-sorted-array/"
  },
  {
    "question_id": 9,
    "code": "class Solution {\n    public boolean isPalindrome(int x) {\n        int temp=x;\n        int num=0;\n        int rem=0;\n        while(x>0){\n            rem=x%10;\n            num= num*10 +rem;\n            x/=10;\n        }\n        if(temp==num) return true;\n        return false;\n    }\n}",
    "title_slug": "palindrome-number",
    "problem_url": "https://leetcode.com/problems/palindrome-number/"
  }
]